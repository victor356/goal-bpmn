{"ast":null,"code":"var fromCharCode = String.fromCharCode;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n}; // map UPPERCASE variants of supported special chars\n\nObject.keys(ENTITY_MAPPING).forEach(function (k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\n\nfunction replaceEntities(_, d, x, z) {\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  } // decimal encoded char\n\n\n  if (d) {\n    return fromCharCode(d);\n  } // hex encoded char\n\n\n  return fromCharCode(parseInt(x, 16));\n}\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} str\n *\n * @return {string} decoded string\n */\n\n\nfunction decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n\n  return s;\n}\n\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\nvar XSI_PREFIX = 'xsi';\nvar XSI_TYPE = 'xsi:type';\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\n\nfunction error(msg) {\n  return new Error(msg);\n}\n\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\n\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\n\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {},\n      key;\n\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n\n  return clone;\n}\n\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\n\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n      uri,\n      prefix;\n\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n\n  return nsMatrix;\n}\n\nfunction noopGetContext() {\n  return {\n    'line': 0,\n    'column': 0\n  };\n}\n\nfunction throwFunc(err) {\n  throw err;\n}\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\n\n\nfunction Parser(options) {\n  if (!this) {\n    return new Parser(options);\n  }\n\n  var proxy = options && options['proxy'];\n  var onText,\n      onOpenTag,\n      onCloseTag,\n      onCDATA,\n      onError = throwFunc,\n      onWarning,\n      onComment,\n      onQuestion,\n      onAttention;\n  var getContext = noopGetContext;\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n\n  var maybeNS = false;\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n\n  var isNamespace = false;\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n\n  var returnError = null;\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n\n  var parseStop = false;\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n\n  var nsUriToPrefix;\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    returnError = err;\n    onError(err, getContext);\n  }\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n\n\n  function handleWarning(err) {\n    if (!onWarning) {\n      return;\n    }\n\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    onWarning(err, getContext);\n  }\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n\n\n  this['on'] = function (name, cb) {\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n\n    switch (name) {\n      case 'openTag':\n        onOpenTag = cb;\n        break;\n\n      case 'text':\n        onText = cb;\n        break;\n\n      case 'closeTag':\n        onCloseTag = cb;\n        break;\n\n      case 'error':\n        onError = cb;\n        break;\n\n      case 'warn':\n        onWarning = cb;\n        break;\n\n      case 'cdata':\n        onCDATA = cb;\n        break;\n\n      case 'attention':\n        onAttention = cb;\n        break;\n      // <!XXXXX zzzz=\"eeee\">\n\n      case 'question':\n        onQuestion = cb;\n        break;\n      // <? ....  ?>\n\n      case 'comment':\n        onComment = cb;\n        break;\n\n      default:\n        throw error('unsupported event: ' + name);\n    }\n\n    return this;\n  };\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n\n\n  this['ns'] = function (nsMap) {\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n\n    var _nsUriToPrefix = {},\n        k;\n\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    } // FORCE default mapping for schema instance\n\n\n    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n    return this;\n  };\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n\n\n  this['parse'] = function (xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n\n    returnError = null;\n    parse(xml);\n    getContext = noopGetContext;\n    parseStop = false;\n    return returnError;\n  };\n  /**\n   * Stop parsing.\n   */\n\n\n  this['stop'] = function () {\n    parseStop = true;\n  };\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n\n\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n        _nsMatrix,\n        nodeStack = [],\n        anonymousNsCount = 0,\n        tagStart = false,\n        tagEnd = false,\n        i = 0,\n        j = 0,\n        x,\n        y,\n        q,\n        w,\n        v,\n        xmlns,\n        elementName,\n        _elementName,\n        elementProxy;\n\n    var attrsString = '',\n        attrsStart = 0,\n        cachedAttrs // false = parsed with errors, null = needs parsing\n    ;\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n\n      var nsUri,\n          nsUriPrefix,\n          nsName,\n          defaultAlias = isNamespace && nsMatrix['xmlns'],\n          attrList = isNamespace && maybeNS ? [] : null,\n          i = attrsStart,\n          s = attrsString,\n          l = s.length,\n          hasNewMatrix,\n          newalias,\n          value,\n          alias,\n          name,\n          attrs = {},\n          seenAttrs = {},\n          skipAttr,\n          w,\n          j;\n\n      parseAttr: for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n\n        if (w === 32 || w < 14 && w > 8) {\n          // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        } // wait for non whitespace character\n\n\n        if (w < 65 || w > 122 || w > 90 && w < 97) {\n          if (w !== 95 && w !== 58) {\n            // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        } // parse attribute name\n\n\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 46 || // '.'\n          w === 45 || // '-'\n          w === 95 // '_'\n          ) {\n              continue;\n            } // unexpected whitespace\n\n\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n            continue parseAttr;\n          } // expected \"=\"\n\n\n          if (w === 61) {\n            // \"=\" == 61\n            break;\n          }\n\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n\n        name = s.substring(i, j);\n\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n\n        w = s.charCodeAt(j + 1);\n\n        if (w === 34) {\n          // '\"'\n          j = s.indexOf('\"', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else if (w === 39) {\n          // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true; // skip to next space\n\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || w < 14 && w > 8) {\n              // WHITESPACE\n              break;\n            }\n          }\n        }\n\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n          j = l;\n          skipAttr = true;\n        }\n\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n\n        i = j; // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            break;\n          } // FIRST ILLEGAL CHAR\n\n\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        } // advance cursor to next attribute\n\n\n        i = j + 1;\n\n        if (skipAttr) {\n          continue parseAttr;\n        } // check attribute re-declaration\n\n\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n\n        seenAttrs[name] = true;\n\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        } // try to extract namespace information\n\n\n        if (maybeNS) {\n          newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' ? name.substr(6) : null; // handle xmlns(:alias) assignment\n\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n            alias = nsUriToPrefix[nsUri];\n\n            if (!alias) {\n              // no prefix defined or prefix collision\n              if (newalias === 'xmlns' || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + anonymousNsCount++;\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n\n              nsUriToPrefix[nsUri] = alias;\n            }\n\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n\n              nsMatrix[newalias] = alias;\n\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n\n              nsMatrix[nsUriPrefix] = nsUri;\n            } // expose xmlns(:asd)=\"...\" in attributes\n\n\n            attrs[name] = value;\n            continue;\n          } // collect attributes until all namespace\n          // declarations are processed\n\n\n          attrList.push(name, value);\n          continue;\n        }\n        /** end if (maybeNs) */\n        // handle attributes on element without\n        // namespace declarations\n\n\n        w = name.indexOf(':');\n\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        } // normalize ns attribute name\n\n\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n\n        name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w); // end: normalize ns attribute name\n        // normalize xsi:type ns attribute value\n\n        if (name === XSI_TYPE) {\n          w = value.indexOf(':');\n\n          if (w !== -1) {\n            nsName = value.substring(0, w); // handle default prefixes, i.e. xs:String gracefully\n\n            nsName = nsMatrix[nsName] || nsName;\n            value = nsName + value.substring(w);\n          } else {\n            value = defaultAlias + ':' + value;\n          }\n        } // end: normalize xsi:type ns attribute value\n\n\n        attrs[name] = value;\n      } // handle deferred, possibly namespaced attributes\n\n\n      if (maybeNS) {\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n          name = attrList[i++];\n          value = attrList[i];\n          w = name.indexOf(':');\n\n          if (w !== -1) {\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n\n            name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w); // end: normalize ns attribute name\n            // normalize xsi:type ns attribute value\n\n            if (name === XSI_TYPE) {\n              w = value.indexOf(':');\n\n              if (w !== -1) {\n                nsName = value.substring(0, w); // handle default prefixes, i.e. xs:String gracefully\n\n                nsName = nsMatrix[nsName] || nsName;\n                value = nsName + value.substring(w);\n              } else {\n                value = defaultAlias + ':' + value;\n              }\n            } // end: normalize xsi:type ns attribute value\n\n          }\n\n          attrs[name] = value;\n        } // end: normalize captured attributes\n\n      }\n\n      return cachedAttrs = attrs;\n    }\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n\n\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n\n      while (i >= startOfLine) {\n        match = splitsRe.exec(xml);\n\n        if (!match) {\n          break;\n        } // end of line = (break idx + break chars)\n\n\n        endOfLine = match[0].length + match.index;\n\n        if (endOfLine > i) {\n          break;\n        } // advance to next line\n\n\n        line += 1;\n        startOfLine = endOfLine;\n      } // EOF errors\n\n\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else // start errors\n        if (j === 0) {\n          data = xml.substring(j, i);\n        } // other errors\n        else {\n            column = i - startOfLine;\n            data = j == -1 ? xml.substring(i) : xml.substring(i, j + 1);\n          }\n\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n\n    getContext = getParseContext;\n\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function () {\n          return elementName;\n        }),\n        'originalName': getter(function () {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function () {\n          return nsMatrix;\n        })\n      });\n    } // actual parse logic\n\n\n    while (j !== -1) {\n      if (xml.charCodeAt(j) === 60) {\n        // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      } // parse end\n\n\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n\n        return;\n      } // parse text\n\n\n      if (j !== i) {\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n\n      w = xml.charCodeAt(i + 1); // parse comments + CDATA\n\n      if (w === 33) {\n        // \"!\"\n        q = xml.charCodeAt(i + 2); // CDATA section\n\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') {\n          // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        } // comment\n\n\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) {\n          // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n      } // parse question <? ... ?>\n\n\n      if (w === 63) {\n        // \"?\"\n        j = xml.indexOf('?>', i);\n\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 2;\n        continue;\n      } // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n\n\n      for (x = i + 1;; x++) {\n        v = xml.charCodeAt(x);\n\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        } // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n\n\n        if (v === 34) {\n          //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) {\n          // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) {\n          // '>'\n          j = x;\n          break;\n        }\n      } // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n\n\n      if (w === 33) {\n        // \"!\"\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 1;\n        continue;\n      } // don't process attributes;\n      // there are none\n\n\n      cachedAttrs = {}; // if (xml.charCodeAt(i+1) === 47) { // </...\n\n      if (w === 47) {\n        // </...\n        tagStart = false;\n        tagEnd = true;\n\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        } // verify open <-> close tag match\n\n\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        } // verify chars in close tag\n\n\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n\n          if (w === 32 || w > 8 && w < 14) {\n            // \\f\\n\\r\\t\\v space\n            continue;\n          }\n\n          return handleError('close tag');\n        }\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) {\n          // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n          tagStart = true;\n          tagEnd = true;\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n          tagStart = true;\n          tagEnd = false;\n        }\n\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {\n          // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n\n          if (w === 32 || w < 14 && w > 8) {\n            // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q); // maybe there are attributes\n\n            cachedAttrs = null;\n            break;\n          }\n\n          return handleError('invalid nodeName');\n        }\n\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n\n      if (isNamespace) {\n        _nsMatrix = nsMatrix;\n\n        if (tagStart) {\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n\n          if (cachedAttrs === null) {\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if (maybeNS = x.indexOf('xmlns', q) !== -1) {\n              attrsStart = q;\n              attrsString = x;\n              getAttrs();\n              maybeNS = false;\n            }\n          }\n        }\n\n        _elementName = elementName;\n        w = elementName.indexOf(':');\n\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)]; // prefix given; namespace must exist\n\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns']; // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        } // adjust namespace prefixs as configured\n\n\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n      }\n\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n\n          if (parseStop) {\n            return;\n          }\n        }\n      }\n\n      if (tagEnd) {\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        } // restore old namespace\n\n\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n\n      j += 1;\n    }\n  }\n  /** end parse */\n\n}\n\nexport { Parser, decodeEntities as decode };","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/saxen/dist/index.esm.js"],"names":["fromCharCode","String","hasOwnProperty","Object","prototype","ENTITY_PATTERN","ENTITY_MAPPING","keys","forEach","k","toUpperCase","replaceEntities","_","d","x","z","call","parseInt","decodeEntities","s","length","indexOf","replace","XSI_URI","XSI_PREFIX","XSI_TYPE","NON_WHITESPACE_OUTSIDE_ROOT_NODE","error","msg","Error","missingNamespaceForPrefix","prefix","getter","getFn","cloneNsMatrix","nsMatrix","clone","key","uriPrefix","buildNsMatrix","nsUriToPrefix","uri","noopGetContext","throwFunc","err","Parser","options","proxy","onText","onOpenTag","onCloseTag","onCDATA","onError","onWarning","onComment","onQuestion","onAttention","getContext","maybeNS","isNamespace","returnError","parseStop","handleError","handleWarning","name","cb","nsMap","_nsUriToPrefix","xml","parse","nsMatrixStack","_nsMatrix","nodeStack","anonymousNsCount","tagStart","tagEnd","i","j","y","q","w","v","xmlns","elementName","_elementName","elementProxy","attrsString","attrsStart","cachedAttrs","getAttrs","nsUri","nsUriPrefix","nsName","defaultAlias","attrList","l","hasNewMatrix","newalias","value","alias","attrs","seenAttrs","skipAttr","parseAttr","charCodeAt","substring","substr","push","getParseContext","splitsRe","line","column","startOfLine","endOfLine","match","data","exec","index","create","trim","isNaN","pop","decode"],"mappings":"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","sourcesContent":["var fromCharCode = String.fromCharCode;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\n\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n};\n\n// map UPPERCASE variants of supported special chars\nObject.keys(ENTITY_MAPPING).forEach(function(k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\n\n\nfunction replaceEntities(_, d, x, z) {\n\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  }\n\n  // decimal encoded char\n  if (d) {\n    return fromCharCode(d);\n  }\n\n  // hex encoded char\n  return fromCharCode(parseInt(x, 16));\n}\n\n\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} str\n *\n * @return {string} decoded string\n */\nfunction decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n\n  return s;\n}\n\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\nvar XSI_PREFIX = 'xsi';\nvar XSI_TYPE = 'xsi:type';\n\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\n\nfunction error(msg) {\n  return new Error(msg);\n}\n\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\n\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\n\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {}, key;\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n  return clone;\n}\n\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\n\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n      uri,\n      prefix;\n\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n\n  return nsMatrix;\n}\n\nfunction noopGetContext() {\n  return { 'line': 0, 'column': 0 };\n}\n\nfunction throwFunc(err) {\n  throw err;\n}\n\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\nfunction Parser(options) {\n\n  if (!this) {\n    return new Parser(options);\n  }\n\n  var proxy = options && options['proxy'];\n\n  var onText,\n      onOpenTag,\n      onCloseTag,\n      onCDATA,\n      onError = throwFunc,\n      onWarning,\n      onComment,\n      onQuestion,\n      onAttention;\n\n  var getContext = noopGetContext;\n\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n  var maybeNS = false;\n\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n  var isNamespace = false;\n\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n  var returnError = null;\n\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n  var parseStop = false;\n\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n  var nsUriToPrefix;\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    returnError = err;\n\n    onError(err, getContext);\n  }\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleWarning(err) {\n\n    if (!onWarning) {\n      return;\n    }\n\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    onWarning(err, getContext);\n  }\n\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n  this['on'] = function(name, cb) {\n\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n\n    switch (name) {\n    case 'openTag': onOpenTag = cb; break;\n    case 'text': onText = cb; break;\n    case 'closeTag': onCloseTag = cb; break;\n    case 'error': onError = cb; break;\n    case 'warn': onWarning = cb; break;\n    case 'cdata': onCDATA = cb; break;\n    case 'attention': onAttention = cb; break; // <!XXXXX zzzz=\"eeee\">\n    case 'question': onQuestion = cb; break; // <? ....  ?>\n    case 'comment': onComment = cb; break;\n    default:\n      throw error('unsupported event: ' + name);\n    }\n\n    return this;\n  };\n\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n  this['ns'] = function(nsMap) {\n\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n\n    var _nsUriToPrefix = {}, k;\n\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    }\n\n    // FORCE default mapping for schema instance\n    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;\n\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n\n    return this;\n  };\n\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n  this['parse'] = function(xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n\n    returnError = null;\n\n    parse(xml);\n\n    getContext = noopGetContext;\n    parseStop = false;\n\n    return returnError;\n  };\n\n  /**\n   * Stop parsing.\n   */\n  this['stop'] = function() {\n    parseStop = true;\n  };\n\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n        _nsMatrix,\n        nodeStack = [],\n        anonymousNsCount = 0,\n        tagStart = false,\n        tagEnd = false,\n        i = 0, j = 0,\n        x, y, q, w, v,\n        xmlns,\n        elementName,\n        _elementName,\n        elementProxy\n        ;\n\n    var attrsString = '',\n        attrsStart = 0,\n        cachedAttrs // false = parsed with errors, null = needs parsing\n        ;\n\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n\n      var nsUri,\n          nsUriPrefix,\n          nsName,\n          defaultAlias = isNamespace && nsMatrix['xmlns'],\n          attrList = isNamespace && maybeNS ? [] : null,\n          i = attrsStart,\n          s = attrsString,\n          l = s.length,\n          hasNewMatrix,\n          newalias,\n          value,\n          alias,\n          name,\n          attrs = {},\n          seenAttrs = {},\n          skipAttr,\n          w,\n          j;\n\n      parseAttr:\n      for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n\n        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        }\n\n        // wait for non whitespace character\n        if (w < 65 || w > 122 || (w > 90 && w < 97)) {\n          if (w !== 95 && w !== 58) { // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        }\n\n        // parse attribute name\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n\n          if (\n            w > 96 && w < 123 ||\n            w > 64 && w < 91 ||\n            w > 47 && w < 59 ||\n            w === 46 || // '.'\n            w === 45 || // '-'\n            w === 95 // '_'\n          ) {\n            continue;\n          }\n\n          // unexpected whitespace\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n\n            continue parseAttr;\n          }\n\n          // expected \"=\"\n          if (w === 61) { // \"=\" == 61\n            break;\n          }\n\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n\n        name = s.substring(i, j);\n\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n\n        w = s.charCodeAt(j + 1);\n\n        if (w === 34) { // '\"'\n          j = s.indexOf('\"', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else if (w === 39) { // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true;\n\n          // skip to next space\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              break;\n            }\n          }\n\n        }\n\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n\n          j = l;\n          skipAttr = true;\n        }\n\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n\n        i = j;\n\n        // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            break;\n          }\n\n          // FIRST ILLEGAL CHAR\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        }\n\n        // advance cursor to next attribute\n        i = j + 1;\n\n        if (skipAttr) {\n          continue parseAttr;\n        }\n\n        // check attribute re-declaration\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n\n        seenAttrs[name] = true;\n\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // try to extract namespace information\n        if (maybeNS) {\n          newalias = (\n            name === 'xmlns'\n              ? 'xmlns'\n              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')\n                ? name.substr(6)\n                : null\n          );\n\n          // handle xmlns(:alias) assignment\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n\n            alias = nsUriToPrefix[nsUri];\n\n            if (!alias) {\n\n              // no prefix defined or prefix collision\n              if (\n                (newalias === 'xmlns') ||\n                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)\n              ) {\n\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + (anonymousNsCount++);\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n\n              nsUriToPrefix[nsUri] = alias;\n            }\n\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n\n              nsMatrix[newalias] = alias;\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n\n              nsMatrix[nsUriPrefix] = nsUri;\n            }\n\n            // expose xmlns(:asd)=\"...\" in attributes\n            attrs[name] = value;\n            continue;\n          }\n\n          // collect attributes until all namespace\n          // declarations are processed\n          attrList.push(name, value);\n          continue;\n\n        } /** end if (maybeNs) */\n\n        // handle attributes on element without\n        // namespace declarations\n        w = name.indexOf(':');\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // normalize ns attribute name\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n\n        name = defaultAlias === nsName\n          ? name.substr(w + 1)\n          : nsName + name.substr(w);\n\n        // end: normalize ns attribute name\n\n        // normalize xsi:type ns attribute value\n        if (name === XSI_TYPE) {\n          w = value.indexOf(':');\n\n          if (w !== -1) {\n            nsName = value.substring(0, w);\n\n            // handle default prefixes, i.e. xs:String gracefully\n            nsName = nsMatrix[nsName] || nsName;\n            value = nsName + value.substring(w);\n          } else {\n            value = defaultAlias + ':' + value;\n          }\n        }\n\n        // end: normalize xsi:type ns attribute value\n\n        attrs[name] = value;\n      }\n\n\n      // handle deferred, possibly namespaced attributes\n      if (maybeNS) {\n\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n\n          name = attrList[i++];\n          value = attrList[i];\n\n          w = name.indexOf(':');\n\n          if (w !== -1) {\n\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n\n            name = defaultAlias === nsName\n              ? name.substr(w + 1)\n              : nsName + name.substr(w);\n\n            // end: normalize ns attribute name\n\n            // normalize xsi:type ns attribute value\n            if (name === XSI_TYPE) {\n              w = value.indexOf(':');\n\n              if (w !== -1) {\n                nsName = value.substring(0, w);\n\n                // handle default prefixes, i.e. xs:String gracefully\n                nsName = nsMatrix[nsName] || nsName;\n                value = nsName + value.substring(w);\n              } else {\n                value = defaultAlias + ':' + value;\n              }\n            }\n\n            // end: normalize xsi:type ns attribute value\n          }\n\n          attrs[name] = value;\n        }\n\n        // end: normalize captured attributes\n      }\n\n      return cachedAttrs = attrs;\n    }\n\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n\n      while (i >= startOfLine) {\n\n        match = splitsRe.exec(xml);\n\n        if (!match) {\n          break;\n        }\n\n        // end of line = (break idx + break chars)\n        endOfLine = match[0].length + match.index;\n\n        if (endOfLine > i) {\n          break;\n        }\n\n        // advance to next line\n        line += 1;\n\n        startOfLine = endOfLine;\n      }\n\n      // EOF errors\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else\n\n      // start errors\n      if (j === 0) {\n        data = xml.substring(j, i);\n      }\n\n      // other errors\n      else {\n        column = i - startOfLine;\n        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));\n      }\n\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n\n    getContext = getParseContext;\n\n\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function() {\n          return elementName;\n        }),\n        'originalName': getter(function() {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function() {\n          return nsMatrix;\n        })\n      });\n    }\n\n    // actual parse logic\n    while (j !== -1) {\n\n      if (xml.charCodeAt(j) === 60) { // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      }\n\n      // parse end\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n\n        return;\n      }\n\n      // parse text\n      if (j !== i) {\n\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n\n      w = xml.charCodeAt(i+1);\n\n      // parse comments + CDATA\n      if (w === 33) { // \"!\"\n        q = xml.charCodeAt(i+2);\n\n        // CDATA section\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n\n        // comment\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n\n\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n      }\n\n      // parse question <? ... ?>\n      if (w === 63) { // \"?\"\n        j = xml.indexOf('?>', i);\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 2;\n        continue;\n      }\n\n      // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n      for (x = i + 1; ; x++) {\n        v = xml.charCodeAt(x);\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        }\n\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n        if (v === 34) { //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) { // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) { // '>'\n          j = x;\n          break;\n        }\n      }\n\n\n      // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n      if (w === 33) { // \"!\"\n\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 1;\n        continue;\n      }\n\n      // don't process attributes;\n      // there are none\n      cachedAttrs = {};\n\n      // if (xml.charCodeAt(i+1) === 47) { // </...\n      if (w === 47) { // </...\n        tagStart = false;\n        tagEnd = true;\n\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        }\n\n        // verify open <-> close tag match\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        }\n\n        // verify chars in close tag\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n\n          if (w === 32 || (w > 8 && w < 14)) { // \\f\\n\\r\\t\\v space\n            continue;\n          }\n\n          return handleError('close tag');\n        }\n\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) { // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n\n          tagStart = true;\n          tagEnd = true;\n\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n\n          tagStart = true;\n          tagEnd = false;\n        }\n\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n\n          if (w === 32 || (w < 14 && w > 8)) { // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q);\n\n            // maybe there are attributes\n            cachedAttrs = null;\n            break;\n          }\n\n          return handleError('invalid nodeName');\n        }\n\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n\n      if (isNamespace) {\n\n        _nsMatrix = nsMatrix;\n\n        if (tagStart) {\n\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n\n          if (cachedAttrs === null) {\n\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {\n              attrsStart = q;\n              attrsString = x;\n\n              getAttrs();\n\n              maybeNS = false;\n            }\n          }\n        }\n\n        _elementName = elementName;\n\n        w = elementName.indexOf(':');\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)];\n\n          // prefix given; namespace must exist\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns'];\n\n          // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        }\n\n        // adjust namespace prefixs as configured\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n\n      }\n\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n      }\n\n      if (tagEnd) {\n\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        // restore old namespace\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n\n      j += 1;\n    }\n  } /** end parse */\n\n}\n\nexport { Parser, decodeEntities as decode };\n"]},"metadata":{},"sourceType":"module"}