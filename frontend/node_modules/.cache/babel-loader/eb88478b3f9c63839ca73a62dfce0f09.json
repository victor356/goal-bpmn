{"ast":null,"code":"import { forEach, filter, some, sortBy, isArray } from 'min-dash';\nimport { IGNORED_PROPERTIES } from './ModelCloneUtils';\n\nfunction isAllowedIn(extProp, type) {\n  var allowedIn = extProp.meta.allowedIn; // '*' is a wildcard, which means any element is allowed to use this property\n\n  if (allowedIn.length === 1 && allowedIn[0] === '*') {\n    return true;\n  }\n\n  return allowedIn.indexOf(type) !== -1;\n}\n\nfunction isType(element, types) {\n  return some(types, function (type) {\n    return typeof element === type;\n  });\n}\n/**\n * A bpmn properties cloning interface\n *\n */\n\n\nexport default function ModelCloneHelper(eventBus, bpmnFactory) {\n  this._eventBus = eventBus;\n  this._bpmnFactory = bpmnFactory;\n}\n\nModelCloneHelper.prototype.clone = function (refElement, newElement, properties) {\n  var self = this; // hasNestedProperty: property allows us to avoid ending up with empty (xml) tags\n  // f.ex: if extensionElements.values is empty, don't set it\n\n  var context = {\n    newElement: newElement,\n    hasNestedProperty: false\n  }; // we want the extensionElements to be cloned last\n  // so that they can check certain properties\n\n  properties = sortBy(properties, function (prop) {\n    return prop === 'bpmn:extensionElements';\n  });\n  forEach(properties, function (propName) {\n    var refElementProp = refElement.get(propName),\n        newElementProp = newElement.get(propName),\n        propDescriptor = newElement.$model.getPropertyDescriptor(newElement, propName),\n        newProperty,\n        name; // we're not interested in cloning:\n    // - same values from simple types\n    // - cloning id's\n    // - cloning reference elements\n\n    if (newElementProp === refElementProp) {\n      return;\n    }\n\n    if (propDescriptor && (propDescriptor.isId || propDescriptor.isReference)) {\n      return;\n    } // if the property is of type 'boolean', 'string', 'number' or 'null', just set it\n\n\n    if (isType(refElementProp, ['boolean', 'string', 'number']) || refElementProp === null) {\n      newElement.set(propName, refElementProp);\n      return;\n    }\n\n    if (isArray(refElementProp)) {\n      forEach(refElementProp, function (extElement) {\n        var newProp;\n        context.refTopLevelProperty = extElement;\n        newProp = self._deepClone(extElement, context);\n\n        if (context.hasNestedProperty) {\n          newProp.$parent = newElement;\n          newElementProp.push(newProp);\n        }\n\n        context.hasNestedProperty = false;\n      });\n    } else {\n      name = propName.replace(/bpmn:/, '');\n      context.refTopLevelProperty = refElementProp;\n      newProperty = self._deepClone(refElementProp, context);\n\n      if (context.hasNestedProperty) {\n        newProperty.$parent = newElement;\n        newElement.set(name, newProperty);\n      }\n\n      context.hasNestedProperty = false;\n    }\n  });\n  return newElement;\n};\n\nModelCloneHelper.prototype._deepClone = function _deepClone(propertyElement, context) {\n  var self = this;\n  var eventBus = this._eventBus;\n  var bpmnFactory = this._bpmnFactory;\n  var newProp = bpmnFactory.create(propertyElement.$type);\n  var properties = filter(Object.keys(propertyElement), function (prop) {\n    var descriptor = newProp.$model.getPropertyDescriptor(newProp, prop);\n\n    if (descriptor && (descriptor.isId || descriptor.isReference)) {\n      return false;\n    } // we need to make sure we don't clone certain properties\n    // which we cannot easily know if they hold references or not\n\n\n    if (IGNORED_PROPERTIES.indexOf(prop) !== -1) {\n      return false;\n    } // make sure we don't copy the type\n\n\n    return prop !== '$type';\n  });\n\n  if (!properties.length) {\n    context.hasNestedProperty = true;\n  }\n\n  forEach(properties, function (propName) {\n    // check if the propertyElement has this property defined\n    if (propertyElement[propName] !== undefined && (propertyElement[propName].$type || isArray(propertyElement[propName]))) {\n      if (isArray(propertyElement[propName])) {\n        newProp[propName] = [];\n        forEach(propertyElement[propName], function (property) {\n          var extProp = propertyElement.$model.getTypeDescriptor(property.$type),\n              newDeepProp; // we're not going to copy undefined types\n\n          if (!extProp) {\n            return;\n          }\n\n          var canClone = eventBus.fire('property.clone', {\n            newElement: context.newElement,\n            refTopLevelProperty: context.refTopLevelProperty,\n            propertyDescriptor: extProp\n          });\n\n          if (!canClone) {\n            // if can clone is 'undefined' or 'false'\n            // check for the meta information if it is allowed\n            if (propertyElement.$type === 'bpmn:ExtensionElements' && extProp.meta && extProp.meta.allowedIn && !isAllowedIn(extProp, context.newElement.$type)) {\n              return false;\n            }\n          }\n\n          newDeepProp = self._deepClone(property, context);\n          newDeepProp.$parent = newProp;\n\n          if (!newProp[propName]) {\n            newProp[propName] = [];\n          }\n\n          context.hasNestedProperty = true;\n          newProp[propName].push(newDeepProp);\n        });\n      } else if (propertyElement[propName].$type) {\n        newProp[propName] = self._deepClone(propertyElement[propName], context);\n\n        if (newProp[propName]) {\n          context.hasNestedProperty = true;\n          newProp[propName].$parent = newProp;\n        }\n      }\n    } else {\n      context.hasNestedProperty = true; // just assign directly if it's a value\n\n      newProp[propName] = propertyElement[propName];\n    }\n  });\n  return newProp;\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/util/model/ModelCloneHelper.js"],"names":["forEach","filter","some","sortBy","isArray","IGNORED_PROPERTIES","isAllowedIn","extProp","type","allowedIn","meta","length","indexOf","isType","element","types","ModelCloneHelper","eventBus","bpmnFactory","_eventBus","_bpmnFactory","prototype","clone","refElement","newElement","properties","self","context","hasNestedProperty","prop","propName","refElementProp","get","newElementProp","propDescriptor","$model","getPropertyDescriptor","newProperty","name","isId","isReference","set","extElement","newProp","refTopLevelProperty","_deepClone","$parent","push","replace","propertyElement","create","$type","Object","keys","descriptor","undefined","property","getTypeDescriptor","newDeepProp","canClone","fire","propertyDescriptor"],"mappings":"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","sourcesContent":["import {\n  forEach,\n  filter,\n  some,\n  sortBy,\n  isArray\n} from 'min-dash';\n\nimport {\n  IGNORED_PROPERTIES\n} from './ModelCloneUtils';\n\n\nfunction isAllowedIn(extProp, type) {\n  var allowedIn = extProp.meta.allowedIn;\n\n  // '*' is a wildcard, which means any element is allowed to use this property\n  if (allowedIn.length === 1 && allowedIn[0] === '*') {\n    return true;\n  }\n\n  return allowedIn.indexOf(type) !== -1;\n}\n\nfunction isType(element, types) {\n  return some(types, function(type) {\n    return typeof element === type;\n  });\n}\n\n/**\n * A bpmn properties cloning interface\n *\n */\nexport default function ModelCloneHelper(eventBus, bpmnFactory) {\n  this._eventBus = eventBus;\n  this._bpmnFactory = bpmnFactory;\n}\n\n\nModelCloneHelper.prototype.clone = function(refElement, newElement, properties) {\n\n  var self = this;\n\n  // hasNestedProperty: property allows us to avoid ending up with empty (xml) tags\n  // f.ex: if extensionElements.values is empty, don't set it\n  var context = {\n    newElement: newElement,\n    hasNestedProperty: false\n  };\n\n  // we want the extensionElements to be cloned last\n  // so that they can check certain properties\n  properties = sortBy(properties, function(prop) {\n    return prop === 'bpmn:extensionElements';\n  });\n\n  forEach(properties, function(propName) {\n    var refElementProp = refElement.get(propName),\n        newElementProp = newElement.get(propName),\n        propDescriptor = newElement.$model.getPropertyDescriptor(newElement, propName),\n        newProperty, name;\n\n    // we're not interested in cloning:\n    // - same values from simple types\n    // - cloning id's\n    // - cloning reference elements\n    if (newElementProp === refElementProp) {\n      return;\n    }\n\n    if (propDescriptor && (propDescriptor.isId || propDescriptor.isReference)) {\n      return;\n    }\n\n    // if the property is of type 'boolean', 'string', 'number' or 'null', just set it\n    if (isType(refElementProp, [ 'boolean', 'string', 'number' ]) || refElementProp === null) {\n      newElement.set(propName, refElementProp);\n\n      return;\n    }\n\n    if (isArray(refElementProp)) {\n\n      forEach(refElementProp, function(extElement) {\n        var newProp;\n\n        context.refTopLevelProperty = extElement;\n\n        newProp = self._deepClone(extElement, context);\n\n        if (context.hasNestedProperty) {\n          newProp.$parent = newElement;\n\n          newElementProp.push(newProp);\n        }\n\n        context.hasNestedProperty = false;\n      });\n\n    } else {\n      name = propName.replace(/bpmn:/, '');\n\n      context.refTopLevelProperty = refElementProp;\n\n      newProperty = self._deepClone(refElementProp, context);\n\n      if (context.hasNestedProperty) {\n        newProperty.$parent = newElement;\n\n        newElement.set(name, newProperty);\n      }\n\n      context.hasNestedProperty = false;\n    }\n  });\n\n  return newElement;\n};\n\nModelCloneHelper.prototype._deepClone = function _deepClone(propertyElement, context) {\n  var self = this;\n\n  var eventBus = this._eventBus;\n  var bpmnFactory = this._bpmnFactory;\n\n  var newProp = bpmnFactory.create(propertyElement.$type);\n\n  var properties = filter(Object.keys(propertyElement), function(prop) {\n    var descriptor = newProp.$model.getPropertyDescriptor(newProp, prop);\n\n    if (descriptor && (descriptor.isId || descriptor.isReference)) {\n      return false;\n    }\n\n    // we need to make sure we don't clone certain properties\n    // which we cannot easily know if they hold references or not\n    if (IGNORED_PROPERTIES.indexOf(prop) !== -1) {\n      return false;\n    }\n\n    // make sure we don't copy the type\n    return prop !== '$type';\n  });\n\n  if (!properties.length) {\n    context.hasNestedProperty = true;\n  }\n\n  forEach(properties, function(propName) {\n    // check if the propertyElement has this property defined\n    if (propertyElement[propName] !== undefined &&\n       (propertyElement[propName].$type || isArray(propertyElement[propName]))) {\n\n      if (isArray(propertyElement[propName])) {\n        newProp[propName] = [];\n\n        forEach(propertyElement[propName], function(property) {\n          var extProp = propertyElement.$model.getTypeDescriptor(property.$type),\n              newDeepProp;\n\n          // we're not going to copy undefined types\n          if (!extProp) {\n            return;\n          }\n\n          var canClone = eventBus.fire('property.clone', {\n            newElement: context.newElement,\n            refTopLevelProperty: context.refTopLevelProperty,\n            propertyDescriptor: extProp\n          });\n\n          if (!canClone) {\n            // if can clone is 'undefined' or 'false'\n            // check for the meta information if it is allowed\n            if (propertyElement.$type === 'bpmn:ExtensionElements' &&\n                extProp.meta && extProp.meta.allowedIn &&\n                !isAllowedIn(extProp, context.newElement.$type)) {\n              return false;\n            }\n          }\n\n          newDeepProp = self._deepClone(property, context);\n\n          newDeepProp.$parent = newProp;\n\n          if (!newProp[propName]) {\n            newProp[propName] = [];\n          }\n\n          context.hasNestedProperty = true;\n\n          newProp[propName].push(newDeepProp);\n        });\n\n      } else if (propertyElement[propName].$type) {\n        newProp[propName] = self._deepClone(propertyElement[propName], context);\n\n        if (newProp[propName]) {\n          context.hasNestedProperty = true;\n\n          newProp[propName].$parent = newProp;\n        }\n      }\n    } else {\n      context.hasNestedProperty = true;\n\n      // just assign directly if it's a value\n      newProp[propName] = propertyElement[propName];\n    }\n  });\n\n  return newProp;\n};\n"]},"metadata":{},"sourceType":"module"}