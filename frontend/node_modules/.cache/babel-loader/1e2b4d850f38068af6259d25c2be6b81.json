{"ast":null,"code":"import { domify, classes as domClasses, matches as domMatches, delegate as domDelegate, query as domQuery, queryAll as domQueryAll, event as domEvent, attr as domAttr } from 'min-dom';\nimport { filter, assign } from 'min-dash';\nimport createEmitter from 'mitt';\nvar DEFAULT_OPTIONS = {\n  scrollSymbolLeft: '‹',\n  scrollSymbolRight: '›'\n};\n/**\n * This component adds the functionality to scroll over a list of tabs.\n *\n * It adds scroll buttons on the left and right side of the tabs container\n * if not all tabs are visible. It also adds a mouse wheel listener on the\n * container.\n *\n * If either a button is clicked or the mouse wheel is used over the tabs,\n * a 'scroll' event is being fired. This event contains the node elements\n * of the new and old active tab, and the direction in which the tab has\n * changed relative to the old active tab.\n *\n * @example:\n * (1) provide a tabs-container:\n *\n * var $el = (\n *   <div>\n *     <!-- button added by scrollTabs -->\n *     <span class=\"scroll-tabs-button scroll-tabs-left\"></span>\n *     <ul class=\"my-tabs-container\">\n *       <li class=\"my-tab i-am-active\"></li>\n *       <li class=\"my-tab\"></li>\n *       <li class=\"my-tab ignore-me\"></li>\n *     </ul>\n *     <!-- button added by scrollTabs -->\n *     <span class=\"scroll-tabs-button scroll-tabs-right\"></span>\n *   </div>\n * );\n *\n *\n * (2) initialize scrollTabs:\n *\n *  var scroller = scrollTabs(tabBarNode, {\n *    selectors: {\n *      tabsContainer: '.my-tabs-container',\n *      tab: '.my-tab',\n *      ignore: '.ignore-me',\n *      active: '.i-am-active'\n *    }\n *  });\n *\n *\n * (3) listen to the scroll event:\n *\n * scroller.on('scroll', function(newActiveNode, oldActiveNode, direction) {\n *   // direction is any of (-1: left, 1: right)\n *   // activate the new active tab\n * });\n *\n *\n * (4) update the scroller if tabs change and or the tab container resizes:\n *\n * scroller.update();\n *\n *\n * @param  {DOMElement} el\n * @param  {Object} options\n * @param  {Object} options.selectors\n * @param  {String} options.selectors.tabsContainer the container all tabs are contained in\n * @param  {String} options.selectors.tab a single tab inside the tab container\n * @param  {String} options.selectors.ignore tabs that should be ignored during scroll left/right\n * @param  {String} options.selectors.active selector for the current active tab\n * @param  {String} [options.scrollSymbolLeft]\n * @param  {String} [options.scrollSymbolRight]\n */\n\nfunction ScrollTabs($el, options) {\n  // we are an event emitter\n  assign(this, createEmitter());\n  this.options = options = assign({}, DEFAULT_OPTIONS, options);\n  this.container = $el;\n\n  this._createScrollButtons($el, options);\n\n  this._bindEvents($el);\n}\n/**\n * Create a clickable scroll button\n *\n * @param {Object} options\n * @param {String} options.className\n * @param {String} options.label\n * @param {Number} options.direction\n *\n * @return {DOMElement} The created scroll button node\n */\n\n\nScrollTabs.prototype._createButton = function (parentNode, options) {\n  var className = options.className,\n      direction = options.direction;\n  var button = domQuery('.' + className, parentNode);\n\n  if (!button) {\n    button = domify('<span class=\"scroll-tabs-button ' + className + '\">' + options.label + '</span>');\n    parentNode.insertBefore(button, parentNode.childNodes[0]);\n  }\n\n  domAttr(button, 'data-direction', direction);\n  return button;\n};\n/**\n * Create both scroll buttons\n *\n * @param  {DOMElement} parentNode\n * @param  {Object} options\n * @param  {String} options.scrollSymbolLeft\n * @param  {String} options.scrollSymbolRight\n */\n\n\nScrollTabs.prototype._createScrollButtons = function (parentNode, options) {\n  // Create a button that scrolls to the tab left to the currently active tab\n  this._createButton(parentNode, {\n    className: 'scroll-tabs-left',\n    label: options.scrollSymbolLeft,\n    direction: -1\n  }); // Create a button that scrolls to the tab right to the currently active tab\n\n\n  this._createButton(parentNode, {\n    className: 'scroll-tabs-right',\n    label: options.scrollSymbolRight,\n    direction: 1\n  });\n};\n/**\n * Get the current active tab\n *\n * @return {DOMElement}\n */\n\n\nScrollTabs.prototype.getActiveTabNode = function () {\n  return domQuery(this.options.selectors.active, this.container);\n};\n/**\n * Get the container all tabs are contained in\n *\n * @return {DOMElement}\n */\n\n\nScrollTabs.prototype.getTabsContainerNode = function () {\n  return domQuery(this.options.selectors.tabsContainer, this.container);\n};\n/**\n * Get all tabs (visible and invisible ones)\n *\n * @return {Array<DOMElement>}\n */\n\n\nScrollTabs.prototype.getAllTabNodes = function () {\n  return domQueryAll(this.options.selectors.tab, this.container);\n};\n/**\n * Gets all tabs that don't have the ignore class set\n *\n * @return {Array<DOMElement>}\n */\n\n\nScrollTabs.prototype.getVisibleTabs = function () {\n  var allTabs = this.getAllTabNodes();\n  var ignore = this.options.selectors.ignore;\n  return filter(allTabs, function (tabNode) {\n    return !domMatches(tabNode, ignore);\n  });\n};\n/**\n * Get a tab relative to a reference tab.\n *\n * @param  {DOMElement} referenceTabNode\n * @param  {Number} n gets the nth tab next or previous to the reference tab\n *\n * @return {DOMElement}\n *\n * @example:\n * Visible tabs: [ A | B | C | D | E ]\n * Assume tab 'C' is the reference tab:\n * If direction === -1, it returns tab 'B',\n * if direction ===  2, it returns tab 'E'\n */\n\n\nScrollTabs.prototype.getAdjacentTab = function (referenceTabNode, n) {\n  var visibleTabs = this.getVisibleTabs();\n  var index = visibleTabs.indexOf(referenceTabNode);\n  return visibleTabs[index + n];\n};\n\nScrollTabs.prototype._bindEvents = function (node) {\n  this._bindWheelEvent(node);\n\n  this._bindTabClickEvents(node);\n\n  this._bindScrollButtonEvents(node);\n};\n/**\n *  Bind a click listener to a DOM node.\n *  Make sure a tab link is entirely visible after onClick.\n *\n * @param {DOMElement} node\n */\n\n\nScrollTabs.prototype._bindTabClickEvents = function (node) {\n  var selector = this.options.selectors.tab;\n  var self = this;\n  domDelegate.bind(node, selector, 'click', function onClick(event) {\n    self.scrollToTabNode(event.delegateTarget);\n  });\n};\n/**\n * Bind the wheel event listener to a DOM node\n *\n * @param {DOMElement} node\n */\n\n\nScrollTabs.prototype._bindWheelEvent = function (node) {\n  var self = this;\n  domEvent.bind(node, 'wheel', function (e) {\n    // scroll direction (-1: left, 1: right)\n    var direction = Math.sign(e.deltaY);\n    var oldActiveTab = self.getActiveTabNode();\n    var newActiveTab = self.getAdjacentTab(oldActiveTab, direction);\n\n    if (newActiveTab) {\n      self.scrollToTabNode(newActiveTab);\n      self.emit('scroll', newActiveTab, oldActiveTab, direction);\n    }\n\n    e.preventDefault();\n  });\n};\n/**\n * Bind scroll button events to a DOM node\n *\n * @param  {DOMElement} node\n */\n\n\nScrollTabs.prototype._bindScrollButtonEvents = function (node) {\n  var self = this;\n  domDelegate.bind(node, '.scroll-tabs-button', 'click', function (event) {\n    var target = event.delegateTarget; // data-direction is either -1 or 1\n\n    var direction = parseInt(domAttr(target, 'data-direction'), 10);\n    var oldActiveTabNode = self.getActiveTabNode();\n    var newActiveTabNode = self.getAdjacentTab(oldActiveTabNode, direction);\n\n    if (newActiveTabNode) {\n      self.scrollToTabNode(newActiveTabNode);\n      self.emit('scroll', newActiveTabNode, oldActiveTabNode, direction);\n    }\n\n    event.preventDefault();\n  });\n};\n/**\n* Scroll to a tab if it is not entirely visible\n*\n* @param  {DOMElement} tabNode tab node to scroll to\n*/\n\n\nScrollTabs.prototype.scrollToTabNode = function (tabNode) {\n  if (!tabNode) {\n    return;\n  }\n\n  var tabsContainerNode = tabNode.parentNode;\n  var tabWidth = tabNode.offsetWidth,\n      tabOffsetLeft = tabNode.offsetLeft,\n      tabOffsetRight = tabOffsetLeft + tabWidth,\n      containerWidth = tabsContainerNode.offsetWidth,\n      containerScrollLeft = tabsContainerNode.scrollLeft;\n\n  if (containerScrollLeft > tabOffsetLeft) {\n    // scroll to the left, if the tab is overflowing on the left side\n    tabsContainerNode.scrollLeft = 0;\n  } else if (tabOffsetRight > containerWidth) {\n    // scroll to the right, if the tab is overflowing on the right side\n    tabsContainerNode.scrollLeft = tabOffsetRight - containerWidth;\n  }\n};\n/**\n * React on tab changes from outside (resize/show/hide/add/remove),\n * update scroll button visibility.\n */\n\n\nScrollTabs.prototype.update = function () {\n  var tabsContainerNode = this.getTabsContainerNode(); // check if tabs fit in container\n\n  var overflow = tabsContainerNode.scrollWidth > tabsContainerNode.offsetWidth; // TODO(nikku): distinguish overflow left / overflow right?\n\n  var overflowClass = 'scroll-tabs-overflow';\n  domClasses(this.container).toggle(overflowClass, overflow);\n\n  if (overflow) {\n    // make sure the current active tab is always visible\n    this.scrollToTabNode(this.getActiveTabNode());\n  }\n}; // exports ////////////////\n\n/**\n * Create a scrollTabs instance on the given element.\n *\n * @param {DOMElement} $el\n * @param {Object} options\n *\n * @return {ScrollTabs}\n */\n\n\nexport default function create($el, options) {\n  var scrollTabs = get($el);\n\n  if (!scrollTabs) {\n    scrollTabs = new ScrollTabs($el, options);\n    $el.__scrollTabs = scrollTabs;\n  }\n\n  return scrollTabs;\n}\n/**\n * Return the scrollTabs instance that has been previously\n * initialized on the element.\n *\n * @param {DOMElement} $el\n * @return {ScrollTabs}\n */\n\nfunction get($el) {\n  return $el.__scrollTabs;\n}\n\ncreate.get = get;","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/scroll-tabs/index.js"],"names":["domify","classes","domClasses","matches","domMatches","delegate","domDelegate","query","domQuery","queryAll","domQueryAll","event","domEvent","attr","domAttr","filter","assign","createEmitter","DEFAULT_OPTIONS","scrollSymbolLeft","scrollSymbolRight","ScrollTabs","$el","options","container","_createScrollButtons","_bindEvents","prototype","_createButton","parentNode","className","direction","button","label","insertBefore","childNodes","getActiveTabNode","selectors","active","getTabsContainerNode","tabsContainer","getAllTabNodes","tab","getVisibleTabs","allTabs","ignore","tabNode","getAdjacentTab","referenceTabNode","n","visibleTabs","index","indexOf","node","_bindWheelEvent","_bindTabClickEvents","_bindScrollButtonEvents","selector","self","bind","onClick","scrollToTabNode","delegateTarget","e","Math","sign","deltaY","oldActiveTab","newActiveTab","emit","preventDefault","target","parseInt","oldActiveTabNode","newActiveTabNode","tabsContainerNode","tabWidth","offsetWidth","tabOffsetLeft","offsetLeft","tabOffsetRight","containerWidth","containerScrollLeft","scrollLeft","update","overflow","scrollWidth","overflowClass","toggle","create","scrollTabs","get","__scrollTabs"],"mappings":"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","sourcesContent":["import {\n  domify,\n  classes as domClasses,\n  matches as domMatches,\n  delegate as domDelegate,\n  query as domQuery,\n  queryAll as domQueryAll,\n  event as domEvent,\n  attr as domAttr\n} from 'min-dom';\n\nimport {\n  filter,\n  assign\n} from 'min-dash';\n\nimport createEmitter from 'mitt';\n\nvar DEFAULT_OPTIONS = {\n  scrollSymbolLeft: '‹',\n  scrollSymbolRight: '›'\n};\n\n\n/**\n * This component adds the functionality to scroll over a list of tabs.\n *\n * It adds scroll buttons on the left and right side of the tabs container\n * if not all tabs are visible. It also adds a mouse wheel listener on the\n * container.\n *\n * If either a button is clicked or the mouse wheel is used over the tabs,\n * a 'scroll' event is being fired. This event contains the node elements\n * of the new and old active tab, and the direction in which the tab has\n * changed relative to the old active tab.\n *\n * @example:\n * (1) provide a tabs-container:\n *\n * var $el = (\n *   <div>\n *     <!-- button added by scrollTabs -->\n *     <span class=\"scroll-tabs-button scroll-tabs-left\"></span>\n *     <ul class=\"my-tabs-container\">\n *       <li class=\"my-tab i-am-active\"></li>\n *       <li class=\"my-tab\"></li>\n *       <li class=\"my-tab ignore-me\"></li>\n *     </ul>\n *     <!-- button added by scrollTabs -->\n *     <span class=\"scroll-tabs-button scroll-tabs-right\"></span>\n *   </div>\n * );\n *\n *\n * (2) initialize scrollTabs:\n *\n *  var scroller = scrollTabs(tabBarNode, {\n *    selectors: {\n *      tabsContainer: '.my-tabs-container',\n *      tab: '.my-tab',\n *      ignore: '.ignore-me',\n *      active: '.i-am-active'\n *    }\n *  });\n *\n *\n * (3) listen to the scroll event:\n *\n * scroller.on('scroll', function(newActiveNode, oldActiveNode, direction) {\n *   // direction is any of (-1: left, 1: right)\n *   // activate the new active tab\n * });\n *\n *\n * (4) update the scroller if tabs change and or the tab container resizes:\n *\n * scroller.update();\n *\n *\n * @param  {DOMElement} el\n * @param  {Object} options\n * @param  {Object} options.selectors\n * @param  {String} options.selectors.tabsContainer the container all tabs are contained in\n * @param  {String} options.selectors.tab a single tab inside the tab container\n * @param  {String} options.selectors.ignore tabs that should be ignored during scroll left/right\n * @param  {String} options.selectors.active selector for the current active tab\n * @param  {String} [options.scrollSymbolLeft]\n * @param  {String} [options.scrollSymbolRight]\n */\nfunction ScrollTabs($el, options) {\n\n  // we are an event emitter\n  assign(this, createEmitter());\n\n  this.options = options = assign({}, DEFAULT_OPTIONS, options);\n  this.container = $el;\n\n  this._createScrollButtons($el, options);\n\n  this._bindEvents($el);\n}\n\n\n/**\n * Create a clickable scroll button\n *\n * @param {Object} options\n * @param {String} options.className\n * @param {String} options.label\n * @param {Number} options.direction\n *\n * @return {DOMElement} The created scroll button node\n */\nScrollTabs.prototype._createButton = function(parentNode, options) {\n\n  var className = options.className,\n      direction = options.direction;\n\n\n  var button = domQuery('.' + className, parentNode);\n\n  if (!button) {\n    button = domify('<span class=\"scroll-tabs-button ' + className + '\">' +\n                                options.label +\n                              '</span>');\n\n    parentNode.insertBefore(button, parentNode.childNodes[0]);\n  }\n\n  domAttr(button, 'data-direction', direction);\n\n  return button;\n};\n\n/**\n * Create both scroll buttons\n *\n * @param  {DOMElement} parentNode\n * @param  {Object} options\n * @param  {String} options.scrollSymbolLeft\n * @param  {String} options.scrollSymbolRight\n */\nScrollTabs.prototype._createScrollButtons = function(parentNode, options) {\n\n  // Create a button that scrolls to the tab left to the currently active tab\n  this._createButton(parentNode, {\n    className: 'scroll-tabs-left',\n    label: options.scrollSymbolLeft,\n    direction: -1\n  });\n\n  // Create a button that scrolls to the tab right to the currently active tab\n  this._createButton(parentNode, {\n    className: 'scroll-tabs-right',\n    label: options.scrollSymbolRight,\n    direction: 1\n  });\n};\n\n/**\n * Get the current active tab\n *\n * @return {DOMElement}\n */\nScrollTabs.prototype.getActiveTabNode = function() {\n  return domQuery(this.options.selectors.active, this.container);\n};\n\n\n/**\n * Get the container all tabs are contained in\n *\n * @return {DOMElement}\n */\nScrollTabs.prototype.getTabsContainerNode = function() {\n  return domQuery(this.options.selectors.tabsContainer, this.container);\n};\n\n\n/**\n * Get all tabs (visible and invisible ones)\n *\n * @return {Array<DOMElement>}\n */\nScrollTabs.prototype.getAllTabNodes = function() {\n  return domQueryAll(this.options.selectors.tab, this.container);\n};\n\n\n/**\n * Gets all tabs that don't have the ignore class set\n *\n * @return {Array<DOMElement>}\n */\nScrollTabs.prototype.getVisibleTabs = function() {\n  var allTabs = this.getAllTabNodes();\n\n  var ignore = this.options.selectors.ignore;\n\n  return filter(allTabs, function(tabNode) {\n    return !domMatches(tabNode, ignore);\n  });\n};\n\n\n/**\n * Get a tab relative to a reference tab.\n *\n * @param  {DOMElement} referenceTabNode\n * @param  {Number} n gets the nth tab next or previous to the reference tab\n *\n * @return {DOMElement}\n *\n * @example:\n * Visible tabs: [ A | B | C | D | E ]\n * Assume tab 'C' is the reference tab:\n * If direction === -1, it returns tab 'B',\n * if direction ===  2, it returns tab 'E'\n */\nScrollTabs.prototype.getAdjacentTab = function(referenceTabNode, n) {\n  var visibleTabs = this.getVisibleTabs();\n\n  var index = visibleTabs.indexOf(referenceTabNode);\n\n  return visibleTabs[index + n];\n};\n\nScrollTabs.prototype._bindEvents = function(node) {\n  this._bindWheelEvent(node);\n  this._bindTabClickEvents(node);\n  this._bindScrollButtonEvents(node);\n};\n\n/**\n *  Bind a click listener to a DOM node.\n *  Make sure a tab link is entirely visible after onClick.\n *\n * @param {DOMElement} node\n */\nScrollTabs.prototype._bindTabClickEvents = function(node) {\n  var selector = this.options.selectors.tab;\n\n  var self = this;\n\n  domDelegate.bind(node, selector, 'click', function onClick(event) {\n    self.scrollToTabNode(event.delegateTarget);\n  });\n};\n\n\n/**\n * Bind the wheel event listener to a DOM node\n *\n * @param {DOMElement} node\n */\nScrollTabs.prototype._bindWheelEvent = function(node) {\n  var self = this;\n\n  domEvent.bind(node, 'wheel', function(e) {\n\n    // scroll direction (-1: left, 1: right)\n    var direction = Math.sign(e.deltaY);\n\n    var oldActiveTab = self.getActiveTabNode();\n\n    var newActiveTab = self.getAdjacentTab(oldActiveTab, direction);\n\n    if (newActiveTab) {\n      self.scrollToTabNode(newActiveTab);\n      self.emit('scroll', newActiveTab, oldActiveTab, direction);\n    }\n\n    e.preventDefault();\n  });\n};\n\n/**\n * Bind scroll button events to a DOM node\n *\n * @param  {DOMElement} node\n */\nScrollTabs.prototype._bindScrollButtonEvents = function(node) {\n\n  var self = this;\n\n  domDelegate.bind(node, '.scroll-tabs-button', 'click', function(event) {\n\n    var target = event.delegateTarget;\n\n    // data-direction is either -1 or 1\n    var direction = parseInt(domAttr(target, 'data-direction'), 10);\n\n    var oldActiveTabNode = self.getActiveTabNode();\n\n    var newActiveTabNode = self.getAdjacentTab(oldActiveTabNode, direction);\n\n    if (newActiveTabNode) {\n      self.scrollToTabNode(newActiveTabNode);\n      self.emit('scroll', newActiveTabNode, oldActiveTabNode, direction);\n    }\n\n    event.preventDefault();\n  });\n};\n\n\n/**\n* Scroll to a tab if it is not entirely visible\n*\n* @param  {DOMElement} tabNode tab node to scroll to\n*/\nScrollTabs.prototype.scrollToTabNode = function(tabNode) {\n  if (!tabNode) {\n    return;\n  }\n\n  var tabsContainerNode = tabNode.parentNode;\n\n  var tabWidth = tabNode.offsetWidth,\n      tabOffsetLeft = tabNode.offsetLeft,\n      tabOffsetRight = tabOffsetLeft + tabWidth,\n      containerWidth = tabsContainerNode.offsetWidth,\n      containerScrollLeft = tabsContainerNode.scrollLeft;\n\n  if (containerScrollLeft > tabOffsetLeft) {\n    // scroll to the left, if the tab is overflowing on the left side\n    tabsContainerNode.scrollLeft = 0;\n  } else if (tabOffsetRight > containerWidth) {\n    // scroll to the right, if the tab is overflowing on the right side\n    tabsContainerNode.scrollLeft = tabOffsetRight - containerWidth;\n  }\n};\n\n\n/**\n * React on tab changes from outside (resize/show/hide/add/remove),\n * update scroll button visibility.\n */\nScrollTabs.prototype.update = function() {\n\n  var tabsContainerNode = this.getTabsContainerNode();\n\n  // check if tabs fit in container\n  var overflow = tabsContainerNode.scrollWidth > tabsContainerNode.offsetWidth;\n\n  // TODO(nikku): distinguish overflow left / overflow right?\n  var overflowClass = 'scroll-tabs-overflow';\n\n  domClasses(this.container).toggle(overflowClass, overflow);\n\n  if (overflow) {\n    // make sure the current active tab is always visible\n    this.scrollToTabNode(this.getActiveTabNode());\n  }\n};\n\n\n// exports ////////////////\n\n/**\n * Create a scrollTabs instance on the given element.\n *\n * @param {DOMElement} $el\n * @param {Object} options\n *\n * @return {ScrollTabs}\n */\nexport default function create($el, options) {\n\n  var scrollTabs = get($el);\n\n  if (!scrollTabs) {\n    scrollTabs = new ScrollTabs($el, options);\n\n    $el.__scrollTabs = scrollTabs;\n  }\n\n  return scrollTabs;\n}\n\n\n/**\n * Return the scrollTabs instance that has been previously\n * initialized on the element.\n *\n * @param {DOMElement} $el\n * @return {ScrollTabs}\n */\nfunction get($el) {\n  return $el.__scrollTabs;\n}\n\ncreate.get = get;"]},"metadata":{},"sourceType":"module"}