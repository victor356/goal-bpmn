{"ast":null,"code":"import inherits from 'inherits';\nimport { assign, find, filter } from 'min-dash';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { getApproxIntersection } from 'diagram-js/lib/util/LineIntersection';\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, position) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore,\n        waypointsAfter,\n        dockingPoint,\n        source,\n        target,\n        incomingConnection,\n        outgoingConnection,\n        oldOutgoing = shape.outgoing.slice(),\n        oldIncoming = shape.incoming.slice();\n    var intersection = getApproxIntersection(waypoints, position);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0)); // due to inaccuracy intersection might have been found\n\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : position; // if last waypointBefore is inside shape's bounds, ignore docking point\n\n      if (!isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      } // if first waypointAfter is inside shape's bounds, ignore docking point\n\n\n      if (!isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || position);\n      incomingConnection = targetFlow;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n      if (!incomingConnection) {\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || position);\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(shape, target, {\n          type: targetFlow.type,\n          waypoints: waypointsAfter\n        });\n      }\n    }\n\n    var duplicateConnections = [].concat(incomingConnection && filter(oldIncoming, function (connection) {\n      return connection.source === incomingConnection.source;\n    }) || [], outgoingConnection && filter(oldOutgoing, function (connection) {\n      return connection.source === outgoingConnection.source;\n    }) || []);\n\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n\n  this.preExecute('elements.move', function (context) {\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    } // if the new parent is a connection,\n    // change it to the new parent's parent\n\n\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    }; // find a connection which intersects with the\n    // element's mid point\n\n    var connection = find(newParent.children, function (element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n  }, true);\n  this.postExecuted('elements.move', function (context) {\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n  }, true);\n  this.preExecute('shape.create', function (context) {\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n  this.postExecuted('shape.create', function (context) {\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, position);\n    }\n  }, true);\n}\ninherits(DropOnFlowBehavior, CommandInterceptor);\nDropOnFlowBehavior.$inject = ['eventBus', 'bpmnRules', 'modeling']; // helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\n\nfunction copy(obj) {\n  return assign({}, obj);\n}\n\nfunction getMid(bounds) {\n  return {\n    x: Math.round(bounds.x + bounds.width / 2),\n    y: Math.round(bounds.y + bounds.height / 2)\n  };\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/modeling/behavior/DropOnFlowBehavior.js"],"names":["inherits","assign","find","filter","CommandInterceptor","getApproxIntersection","DropOnFlowBehavior","eventBus","bpmnRules","modeling","call","insertShape","shape","targetFlow","position","waypoints","waypointsBefore","waypointsAfter","dockingPoint","source","target","incomingConnection","outgoingConnection","oldOutgoing","outgoing","slice","oldIncoming","incoming","intersection","index","bendpoint","length","isPointInsideBBox","push","copy","unshift","canConnect","reconnectEnd","reconnectStart","connect","type","duplicateConnections","concat","connection","removeElements","preExecute","context","newParent","shapes","delta","parent","shapeMid","getMid","newShapeMid","x","y","children","element","canInsert","postExecuted","$inject","bbox","point","width","height","obj","bounds","Math","round"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport {\n  assign,\n  find,\n  filter\n} from 'min-dash';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  getApproxIntersection\n} from 'diagram-js/lib/util/LineIntersection';\n\n\nexport default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  /**\n   * Reconnect start / end of a connection after\n   * dropping an element on a flow.\n   */\n\n  function insertShape(shape, targetFlow, position) {\n    var waypoints = targetFlow.waypoints,\n        waypointsBefore,\n        waypointsAfter,\n        dockingPoint,\n        source,\n        target,\n        incomingConnection,\n        outgoingConnection,\n        oldOutgoing = shape.outgoing.slice(),\n        oldIncoming = shape.incoming.slice();\n\n    var intersection = getApproxIntersection(waypoints, position);\n\n    if (intersection) {\n      waypointsBefore = waypoints.slice(0, intersection.index);\n      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));\n\n      // due to inaccuracy intersection might have been found\n      if (!waypointsBefore.length || !waypointsAfter.length) {\n        return;\n      }\n\n      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : position;\n\n      // if last waypointBefore is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length-1])) {\n        waypointsBefore.push(copy(dockingPoint));\n      }\n\n      // if first waypointAfter is inside shape's bounds, ignore docking point\n      if (!isPointInsideBBox(shape, waypointsAfter[0])) {\n        waypointsAfter.unshift(copy(dockingPoint));\n      }\n    }\n\n    source = targetFlow.source;\n    target = targetFlow.target;\n\n    if (bpmnRules.canConnect(source, shape, targetFlow)) {\n      // reconnect source -> inserted shape\n      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || position);\n\n      incomingConnection = targetFlow;\n    }\n\n    if (bpmnRules.canConnect(shape, target, targetFlow)) {\n\n      if (!incomingConnection) {\n        // reconnect inserted shape -> end\n        modeling.reconnectStart(targetFlow, shape, waypointsAfter || position);\n\n        outgoingConnection = targetFlow;\n      } else {\n        outgoingConnection = modeling.connect(\n          shape, target, { type: targetFlow.type, waypoints: waypointsAfter }\n        );\n      }\n    }\n\n    var duplicateConnections = [].concat(\n\n      incomingConnection && filter(oldIncoming, function(connection) {\n        return connection.source === incomingConnection.source;\n      }) || [],\n\n      outgoingConnection && filter(oldOutgoing, function(connection) {\n        return connection.source === outgoingConnection.source;\n      }) || []\n    );\n\n    if (duplicateConnections.length) {\n      modeling.removeElements(duplicateConnections);\n    }\n  }\n\n  this.preExecute('elements.move', function(context) {\n\n    var newParent = context.newParent,\n        shapes = context.shapes,\n        delta = context.delta,\n        shape = shapes[0];\n\n    if (!shape || !newParent) {\n      return;\n    }\n\n    // if the new parent is a connection,\n    // change it to the new parent's parent\n    if (newParent && newParent.waypoints) {\n      context.newParent = newParent = newParent.parent;\n    }\n\n    var shapeMid = getMid(shape);\n    var newShapeMid = {\n      x: shapeMid.x + delta.x,\n      y: shapeMid.y + delta.y\n    };\n\n    // find a connection which intersects with the\n    // element's mid point\n    var connection = find(newParent.children, function(element) {\n      var canInsert = bpmnRules.canInsert(shapes, element);\n\n      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);\n    });\n\n    if (connection) {\n      context.targetFlow = connection;\n      context.position = newShapeMid;\n    }\n\n  }, true);\n\n  this.postExecuted('elements.move', function(context) {\n\n    var shapes = context.shapes,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shapes[0], targetFlow, position);\n    }\n\n  }, true);\n\n  this.preExecute('shape.create', function(context) {\n\n    var parent = context.parent,\n        shape = context.shape;\n\n    if (bpmnRules.canInsert(shape, parent)) {\n      context.targetFlow = parent;\n      context.parent = parent.parent;\n    }\n  }, true);\n\n  this.postExecuted('shape.create', function(context) {\n\n    var shape = context.shape,\n        targetFlow = context.targetFlow,\n        position = context.position;\n\n    if (targetFlow) {\n      insertShape(shape, targetFlow, position);\n    }\n  }, true);\n}\n\ninherits(DropOnFlowBehavior, CommandInterceptor);\n\nDropOnFlowBehavior.$inject = [\n  'eventBus',\n  'bpmnRules',\n  'modeling'\n];\n\n\n// helpers /////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n      y = point.y;\n\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}\n\nfunction copy(obj) {\n  return assign({}, obj);\n}\n\nfunction getMid(bounds) {\n\n  return {\n    x: Math.round(bounds.x + bounds.width / 2),\n    y: Math.round(bounds.y + bounds.height / 2)\n  };\n}\n\n"]},"metadata":{},"sourceType":"module"}