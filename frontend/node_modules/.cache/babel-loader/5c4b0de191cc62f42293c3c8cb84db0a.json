{"ast":null,"code":"import { isArray, forEach, map, matchPattern, find, findIndex, sortBy, reduce } from 'min-dash';\nimport { getBBox } from '../../util/Elements';\nimport { center, delta as posDelta } from '../../util/PositionUtil';\nimport { getTopLevel } from '../../util/CopyPasteUtil';\nimport { eachElement } from '../../util/Elements';\nexport default function CopyPaste(eventBus, modeling, elementFactory, rules, clipboard, canvas) {\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._elementFactory = elementFactory;\n  this._rules = rules;\n  this._canvas = canvas;\n  this._clipboard = clipboard;\n  this._descriptors = []; // Element creation priorities:\n  // - 1: Independent shapes\n  // - 2: Attached shapes\n  // - 3: Connections\n  // - 4: labels\n\n  this.registerDescriptor(function (element, descriptor) {\n    // Base priority\n    descriptor.priority = 1;\n    descriptor.id = element.id;\n\n    if (element.parent) {\n      descriptor.parent = element.parent.id;\n    }\n\n    if (element.labelTarget) {\n      // Labels priority\n      descriptor.priority = 4;\n      descriptor.labelTarget = element.labelTarget.id;\n    }\n\n    if (element.host) {\n      // Attached shapes priority\n      descriptor.priority = 2;\n      descriptor.host = element.host.id;\n    }\n\n    if (typeof element.x === 'number') {\n      descriptor.x = element.x;\n      descriptor.y = element.y;\n    }\n\n    if (element.width) {\n      descriptor.width = element.width;\n      descriptor.height = element.height;\n    }\n\n    if (element.waypoints) {\n      // Connections priority\n      descriptor.priority = 3;\n      descriptor.waypoints = [];\n      forEach(element.waypoints, function (waypoint) {\n        var wp = {\n          x: waypoint.x,\n          y: waypoint.y\n        };\n\n        if (waypoint.original) {\n          wp.original = {\n            x: waypoint.original.x,\n            y: waypoint.original.y\n          };\n        }\n\n        descriptor.waypoints.push(wp);\n      });\n    }\n\n    if (element.source && element.target) {\n      descriptor.source = element.source.id;\n      descriptor.target = element.target.id;\n    }\n\n    return descriptor;\n  });\n}\nCopyPaste.$inject = ['eventBus', 'modeling', 'elementFactory', 'rules', 'clipboard', 'canvas'];\n/**\n * Copy a number of elements.\n *\n * @param {djs.model.Base} selectedElements\n *\n * @return {Object} the copied tree\n */\n\nCopyPaste.prototype.copy = function (selectedElements) {\n  var clipboard = this._clipboard,\n      tree,\n      bbox;\n\n  if (!isArray(selectedElements)) {\n    selectedElements = selectedElements ? [selectedElements] : [];\n  }\n\n  if (!selectedElements.length) {\n    return;\n  }\n\n  tree = this.createTree(selectedElements);\n  bbox = this._bbox = center(getBBox(tree.allShapes)); // not needed after computing the center position of the copied elements\n\n  delete tree.allShapes;\n  forEach(tree, function (elements) {\n    forEach(elements, function (element) {\n      var delta, labelTarget; // set label's relative position to their label target\n\n      if (element.labelTarget) {\n        labelTarget = find(elements, matchPattern({\n          id: element.labelTarget\n        })); // just grab the delta from the first waypoint\n\n        if (labelTarget.waypoints) {\n          delta = posDelta(element, labelTarget.waypoints[0]);\n        } else {\n          delta = posDelta(element, labelTarget);\n        }\n      } else if (element.priority === 3) {\n        // connections have priority 3\n        delta = [];\n        forEach(element.waypoints, function (waypoint) {\n          var waypointDelta = posDelta(waypoint, bbox);\n          delta.push(waypointDelta);\n        });\n      } else {\n        delta = posDelta(element, bbox);\n      }\n\n      element.delta = delta;\n    });\n  });\n\n  this._eventBus.fire('elements.copy', {\n    context: {\n      tree: tree\n    }\n  }); // if tree is empty, means that nothing can be or is allowed to be copied\n\n\n  if (Object.keys(tree).length === 0) {\n    clipboard.clear();\n  } else {\n    clipboard.set(tree);\n  }\n\n  this._eventBus.fire('elements.copied', {\n    context: {\n      tree: tree\n    }\n  });\n\n  return tree;\n}; // Allow pasting under the cursor\n\n\nCopyPaste.prototype.paste = function (context) {\n  var clipboard = this._clipboard,\n      modeling = this._modeling,\n      eventBus = this._eventBus,\n      rules = this._rules;\n  var tree = clipboard.get(),\n      topParent = context.element,\n      position = context.point,\n      newTree,\n      canPaste;\n\n  if (clipboard.isEmpty()) {\n    return;\n  }\n\n  newTree = reduce(tree, function (pasteTree, elements, depthStr) {\n    var depth = parseInt(depthStr, 10);\n\n    if (isNaN(depth)) {\n      return pasteTree;\n    }\n\n    pasteTree[depth] = elements;\n    return pasteTree;\n  }, {});\n  canPaste = rules.allowed('elements.paste', {\n    tree: newTree,\n    target: topParent\n  });\n\n  if (!canPaste) {\n    eventBus.fire('elements.paste.rejected', {\n      context: {\n        tree: newTree,\n        position: position,\n        target: topParent\n      }\n    });\n    return;\n  }\n\n  modeling.pasteElements(newTree, topParent, position);\n};\n\nCopyPaste.prototype._computeDelta = function (elements, element) {\n  var bbox = this._bbox,\n      delta = {}; // set label's relative position to their label target\n\n  if (element.labelTarget) {\n    return posDelta(element, element.labelTarget);\n  } // connections have prority 3\n\n\n  if (element.priority === 3) {\n    delta = [];\n    forEach(element.waypoints, function (waypoint) {\n      var waypointDelta = posDelta(waypoint, bbox);\n      delta.push(waypointDelta);\n    });\n  } else {\n    delta = posDelta(element, bbox);\n  }\n\n  return delta;\n};\n/**\n * Checks if the element in question has a relations to other elements.\n * Possible dependants: connections, labels, attachers\n *\n * @param  {Array} elements\n * @param  {Object} element\n *\n * @return {Boolean}\n */\n\n\nCopyPaste.prototype.hasRelations = function (elements, element) {\n  var source, target, labelTarget;\n\n  if (element.waypoints) {\n    source = find(elements, matchPattern({\n      id: element.source.id\n    }));\n    target = find(elements, matchPattern({\n      id: element.target.id\n    }));\n\n    if (!source || !target) {\n      return false;\n    }\n  }\n\n  if (element.labelTarget) {\n    labelTarget = find(elements, matchPattern({\n      id: element.labelTarget.id\n    }));\n\n    if (!labelTarget) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nCopyPaste.prototype.registerDescriptor = function (descriptor) {\n  if (typeof descriptor !== 'function') {\n    throw new Error('the descriptor must be a function');\n  }\n\n  if (this._descriptors.indexOf(descriptor) !== -1) {\n    throw new Error('this descriptor is already registered');\n  }\n\n  this._descriptors.push(descriptor);\n};\n\nCopyPaste.prototype._executeDescriptors = function (data) {\n  if (!data.descriptor) {\n    data.descriptor = {};\n  }\n\n  forEach(this._descriptors, function (descriptor) {\n    data.descriptor = descriptor(data.element, data.descriptor);\n  });\n  return data;\n};\n/**\n * Creates a tree like structure from an arbitrary collection of elements\n *\n * @example\n * tree: {\n *\t0: [\n *\t\t{ id: 'shape_12da', priority: 1, ... },\n *\t\t{ id: 'shape_01bj', priority: 1, ... },\n *\t\t{ id: 'connection_79fa', source: 'shape_12da', target: 'shape_01bj', priority: 3, ... },\n *\t],\n *\t1: [ ... ]\n * };\n *\n * @param  {Array} elements\n * @return {Object}\n */\n\n\nCopyPaste.prototype.createTree = function (elements) {\n  var rules = this._rules,\n      self = this;\n\n  var tree = {},\n      includedElements = [],\n      _elements;\n\n  var topLevel = getTopLevel(elements);\n  tree.allShapes = [];\n\n  function canCopy(collection, element) {\n    return rules.allowed('element.copy', {\n      collection: collection,\n      element: element\n    });\n  }\n\n  function includeElement(data) {\n    var idx = findIndex(includedElements, matchPattern({\n      element: data.element\n    })),\n        element;\n\n    if (idx !== -1) {\n      element = includedElements[idx];\n    } else {\n      return includedElements.push(data);\n    } // makes sure that it has the correct depth\n\n\n    if (element.depth < data.depth) {\n      includedElements.splice(idx, 1);\n      includedElements.push(data);\n    }\n  }\n\n  eachElement(topLevel, function (element, i, depth) {\n    var nestedChildren = element.children; // don't add labels directly\n\n    if (element.labelTarget) {\n      return;\n    }\n\n    function getNested(lists) {\n      forEach(lists, function (list) {\n        if (list && list.length) {\n          forEach(list, function (elem) {\n            forEach(elem.labels, function (label) {\n              includeElement({\n                element: label,\n                depth: depth\n              });\n            });\n            includeElement({\n              element: elem,\n              depth: depth\n            });\n          });\n        }\n      });\n    } // fetch element's labels\n\n\n    forEach(element.labels, function (label) {\n      includeElement({\n        element: label,\n        depth: depth\n      });\n    });\n    getNested([element.attachers, element.incoming, element.outgoing]);\n    includeElement({\n      element: element,\n      depth: depth\n    });\n\n    if (nestedChildren) {\n      return nestedChildren;\n    }\n  });\n  includedElements = map(includedElements, function (data) {\n    // this is where other registered descriptors hook in\n    return self._executeDescriptors(data);\n  }); // order the elements to check if the ones dependant on others (by relationship)\n  // can be copied. f.ex: label needs it's label target\n\n  includedElements = sortBy(includedElements, function (data) {\n    return data.descriptor.priority;\n  });\n  _elements = map(includedElements, function (data) {\n    return data.element;\n  });\n  forEach(includedElements, function (data) {\n    var depth = data.depth;\n\n    if (!self.hasRelations(tree.allShapes, data.element)) {\n      return;\n    }\n\n    if (!canCopy(_elements, data.element)) {\n      return;\n    }\n\n    tree.allShapes.push(data.element); // create depth branches\n\n    if (!tree[depth]) {\n      tree[depth] = [];\n    }\n\n    tree[depth].push(data.descriptor);\n  });\n  return tree;\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js"],"names":["isArray","forEach","map","matchPattern","find","findIndex","sortBy","reduce","getBBox","center","delta","posDelta","getTopLevel","eachElement","CopyPaste","eventBus","modeling","elementFactory","rules","clipboard","canvas","_eventBus","_modeling","_elementFactory","_rules","_canvas","_clipboard","_descriptors","registerDescriptor","element","descriptor","priority","id","parent","labelTarget","host","x","y","width","height","waypoints","waypoint","wp","original","push","source","target","$inject","prototype","copy","selectedElements","tree","bbox","length","createTree","_bbox","allShapes","elements","waypointDelta","fire","context","Object","keys","clear","set","paste","get","topParent","position","point","newTree","canPaste","isEmpty","pasteTree","depthStr","depth","parseInt","isNaN","allowed","pasteElements","_computeDelta","hasRelations","Error","indexOf","_executeDescriptors","data","self","includedElements","_elements","topLevel","canCopy","collection","includeElement","idx","splice","i","nestedChildren","children","getNested","lists","list","elem","labels","label","attachers","incoming","outgoing"],"mappings":"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","sourcesContent":["import {\n  isArray,\n  forEach,\n  map,\n  matchPattern,\n  find,\n  findIndex,\n  sortBy,\n  reduce\n} from 'min-dash';\n\nimport { getBBox } from '../../util/Elements';\n\nimport {\n  center,\n  delta as posDelta\n} from '../../util/PositionUtil';\n\nimport {\n  getTopLevel\n} from '../../util/CopyPasteUtil';\n\nimport {\n  eachElement\n} from '../../util/Elements';\n\n\nexport default function CopyPaste(\n    eventBus, modeling, elementFactory,\n    rules, clipboard, canvas) {\n\n  this._eventBus = eventBus;\n  this._modeling = modeling;\n  this._elementFactory = elementFactory;\n  this._rules = rules;\n  this._canvas = canvas;\n\n  this._clipboard = clipboard;\n\n  this._descriptors = [];\n\n\n  // Element creation priorities:\n  // - 1: Independent shapes\n  // - 2: Attached shapes\n  // - 3: Connections\n  // - 4: labels\n  this.registerDescriptor(function(element, descriptor) {\n    // Base priority\n    descriptor.priority = 1;\n\n    descriptor.id = element.id;\n\n    if (element.parent) {\n      descriptor.parent = element.parent.id;\n    }\n\n    if (element.labelTarget) {\n      // Labels priority\n      descriptor.priority = 4;\n      descriptor.labelTarget = element.labelTarget.id;\n    }\n\n    if (element.host) {\n      // Attached shapes priority\n      descriptor.priority = 2;\n      descriptor.host = element.host.id;\n    }\n\n    if (typeof element.x === 'number') {\n      descriptor.x = element.x;\n      descriptor.y = element.y;\n    }\n\n    if (element.width) {\n      descriptor.width = element.width;\n      descriptor.height = element.height;\n    }\n\n    if (element.waypoints) {\n      // Connections priority\n      descriptor.priority = 3;\n      descriptor.waypoints = [];\n\n      forEach(element.waypoints, function(waypoint) {\n        var wp = {\n          x: waypoint.x,\n          y: waypoint.y\n        };\n\n        if (waypoint.original) {\n          wp.original = {\n            x: waypoint.original.x,\n            y: waypoint.original.y\n          };\n        }\n\n        descriptor.waypoints.push(wp);\n      });\n    }\n\n    if (element.source && element.target) {\n      descriptor.source = element.source.id;\n      descriptor.target = element.target.id;\n    }\n\n    return descriptor;\n  });\n}\n\nCopyPaste.$inject = [\n  'eventBus',\n  'modeling',\n  'elementFactory',\n  'rules',\n  'clipboard',\n  'canvas'\n];\n\n\n/**\n * Copy a number of elements.\n *\n * @param {djs.model.Base} selectedElements\n *\n * @return {Object} the copied tree\n */\nCopyPaste.prototype.copy = function(selectedElements) {\n  var clipboard = this._clipboard,\n      tree, bbox;\n\n  if (!isArray(selectedElements)) {\n    selectedElements = selectedElements ? [ selectedElements ] : [];\n  }\n\n  if (!selectedElements.length) {\n    return;\n  }\n\n  tree = this.createTree(selectedElements);\n\n  bbox = this._bbox = center(getBBox(tree.allShapes));\n\n  // not needed after computing the center position of the copied elements\n  delete tree.allShapes;\n\n  forEach(tree, function(elements) {\n\n    forEach(elements, function(element) {\n      var delta, labelTarget;\n\n      // set label's relative position to their label target\n      if (element.labelTarget) {\n        labelTarget = find(elements, matchPattern({ id: element.labelTarget }));\n\n        // just grab the delta from the first waypoint\n        if (labelTarget.waypoints) {\n          delta = posDelta(element, labelTarget.waypoints[0]);\n        } else {\n          delta = posDelta(element, labelTarget);\n        }\n\n      } else\n      if (element.priority === 3) {\n        // connections have priority 3\n        delta = [];\n\n        forEach(element.waypoints, function(waypoint) {\n          var waypointDelta = posDelta(waypoint, bbox);\n\n          delta.push(waypointDelta);\n        });\n      } else {\n        delta = posDelta(element, bbox);\n      }\n\n      element.delta = delta;\n    });\n  });\n\n  this._eventBus.fire('elements.copy', { context: { tree: tree } });\n\n  // if tree is empty, means that nothing can be or is allowed to be copied\n  if (Object.keys(tree).length === 0) {\n    clipboard.clear();\n  } else {\n    clipboard.set(tree);\n  }\n\n  this._eventBus.fire('elements.copied', { context: { tree: tree } });\n\n  return tree;\n};\n\n\n// Allow pasting under the cursor\nCopyPaste.prototype.paste = function(context) {\n  var clipboard = this._clipboard,\n      modeling = this._modeling,\n      eventBus = this._eventBus,\n      rules = this._rules;\n\n  var tree = clipboard.get(),\n      topParent = context.element,\n      position = context.point,\n      newTree, canPaste;\n\n  if (clipboard.isEmpty()) {\n    return;\n  }\n\n  newTree = reduce(tree, function(pasteTree, elements, depthStr) {\n    var depth = parseInt(depthStr, 10);\n\n    if (isNaN(depth)) {\n      return pasteTree;\n    }\n\n    pasteTree[depth] = elements;\n\n    return pasteTree;\n  }, {});\n\n\n  canPaste = rules.allowed('elements.paste', {\n    tree: newTree,\n    target: topParent\n  });\n\n  if (!canPaste) {\n    eventBus.fire('elements.paste.rejected', {\n      context: {\n        tree: newTree,\n        position: position,\n        target: topParent\n      }\n    });\n\n    return;\n  }\n\n  modeling.pasteElements(newTree, topParent, position);\n};\n\n\nCopyPaste.prototype._computeDelta = function(elements, element) {\n  var bbox = this._bbox,\n      delta = {};\n\n  // set label's relative position to their label target\n  if (element.labelTarget) {\n    return posDelta(element, element.labelTarget);\n  }\n\n  // connections have prority 3\n  if (element.priority === 3) {\n    delta = [];\n\n    forEach(element.waypoints, function(waypoint) {\n      var waypointDelta = posDelta(waypoint, bbox);\n\n      delta.push(waypointDelta);\n    });\n  } else {\n    delta = posDelta(element, bbox);\n  }\n\n  return delta;\n};\n\n\n/**\n * Checks if the element in question has a relations to other elements.\n * Possible dependants: connections, labels, attachers\n *\n * @param  {Array} elements\n * @param  {Object} element\n *\n * @return {Boolean}\n */\nCopyPaste.prototype.hasRelations = function(elements, element) {\n  var source, target, labelTarget;\n\n  if (element.waypoints) {\n    source = find(elements, matchPattern({ id: element.source.id }));\n    target = find(elements, matchPattern({ id: element.target.id }));\n\n    if (!source || !target) {\n      return false;\n    }\n  }\n\n  if (element.labelTarget) {\n    labelTarget = find(elements, matchPattern({ id: element.labelTarget.id }));\n\n    if (!labelTarget) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n\nCopyPaste.prototype.registerDescriptor = function(descriptor) {\n  if (typeof descriptor !== 'function') {\n    throw new Error('the descriptor must be a function');\n  }\n\n  if (this._descriptors.indexOf(descriptor) !== -1) {\n    throw new Error('this descriptor is already registered');\n  }\n\n  this._descriptors.push(descriptor);\n};\n\n\nCopyPaste.prototype._executeDescriptors = function(data) {\n  if (!data.descriptor) {\n    data.descriptor = {};\n  }\n\n  forEach(this._descriptors, function(descriptor) {\n    data.descriptor = descriptor(data.element, data.descriptor);\n  });\n\n  return data;\n};\n\n/**\n * Creates a tree like structure from an arbitrary collection of elements\n *\n * @example\n * tree: {\n *\t0: [\n *\t\t{ id: 'shape_12da', priority: 1, ... },\n *\t\t{ id: 'shape_01bj', priority: 1, ... },\n *\t\t{ id: 'connection_79fa', source: 'shape_12da', target: 'shape_01bj', priority: 3, ... },\n *\t],\n *\t1: [ ... ]\n * };\n *\n * @param  {Array} elements\n * @return {Object}\n */\nCopyPaste.prototype.createTree = function(elements) {\n  var rules = this._rules,\n      self = this;\n\n  var tree = {},\n      includedElements = [],\n      _elements;\n\n  var topLevel = getTopLevel(elements);\n\n  tree.allShapes = [];\n\n  function canCopy(collection, element) {\n    return rules.allowed('element.copy', {\n      collection: collection,\n      element: element\n    });\n  }\n\n  function includeElement(data) {\n    var idx = findIndex(includedElements, matchPattern({ element: data.element })),\n        element;\n\n    if (idx !== -1) {\n      element = includedElements[idx];\n    } else {\n      return includedElements.push(data);\n    }\n\n    // makes sure that it has the correct depth\n    if (element.depth < data.depth) {\n      includedElements.splice(idx, 1);\n\n      includedElements.push(data);\n    }\n  }\n\n\n  eachElement(topLevel, function(element, i, depth) {\n    var nestedChildren = element.children;\n\n    // don't add labels directly\n    if (element.labelTarget) {\n      return;\n    }\n\n    function getNested(lists) {\n      forEach(lists, function(list) {\n        if (list && list.length) {\n\n          forEach(list, function(elem) {\n\n            forEach(elem.labels, function(label) {\n              includeElement({\n                element: label,\n                depth: depth\n              });\n            });\n\n            includeElement({\n              element: elem,\n              depth: depth\n            });\n          });\n        }\n      });\n    }\n\n    // fetch element's labels\n    forEach(element.labels, function(label) {\n\n      includeElement({\n        element: label,\n        depth: depth\n      });\n    });\n\n    getNested([ element.attachers, element.incoming, element.outgoing ]);\n\n    includeElement({\n      element: element,\n      depth: depth\n    });\n\n    if (nestedChildren) {\n      return nestedChildren;\n    }\n  });\n\n  includedElements = map(includedElements, function(data) {\n    // this is where other registered descriptors hook in\n    return self._executeDescriptors(data);\n  });\n\n  // order the elements to check if the ones dependant on others (by relationship)\n  // can be copied. f.ex: label needs it's label target\n  includedElements = sortBy(includedElements, function(data) {\n    return data.descriptor.priority;\n  });\n\n  _elements = map(includedElements, function(data) {\n    return data.element;\n  });\n\n  forEach(includedElements, function(data) {\n    var depth = data.depth;\n\n    if (!self.hasRelations(tree.allShapes, data.element)) {\n      return;\n    }\n\n    if (!canCopy(_elements, data.element)) {\n      return;\n    }\n\n    tree.allShapes.push(data.element);\n\n    // create depth branches\n    if (!tree[depth]) {\n      tree[depth] = [];\n    }\n\n    tree[depth].push(data.descriptor);\n  });\n\n  return tree;\n};\n"]},"metadata":{},"sourceType":"module"}