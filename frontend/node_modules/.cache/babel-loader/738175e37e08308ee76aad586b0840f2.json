{"ast":null,"code":"import { sortBy, forEach, filter } from 'min-dash';\nvar AXIS_DIMENSIONS = {\n  horizontal: ['x', 'width'],\n  vertical: ['y', 'height']\n};\nvar THRESHOLD = 5;\n/**\n * Groups and filters elements and then trigger even distribution.\n */\n\nexport default function DistributeElements(modeling) {\n  this._modeling = modeling;\n  this._filters = []; // register filter for filtering big elements\n\n  this.registerFilter(function (elements, axis, dimension) {\n    var elementsSize = 0,\n        numOfShapes = 0,\n        avgDimension;\n    forEach(elements, function (element) {\n      if (element.waypoints || element.labelTarget) {\n        return;\n      }\n\n      elementsSize += element[dimension];\n      numOfShapes += 1;\n    });\n    avgDimension = Math.round(elementsSize / numOfShapes);\n    return filter(elements, function (element) {\n      return element[dimension] < avgDimension + 50;\n    });\n  });\n}\nDistributeElements.$inject = ['modeling'];\n/**\n * Registers filter functions that allow external parties to filter\n * out certain elements.\n *\n * @param  {Function} filterFn\n */\n\nDistributeElements.prototype.registerFilter = function (filterFn) {\n  if (typeof filterFn !== 'function') {\n    throw new Error('the filter has to be a function');\n  }\n\n  this._filters.push(filterFn);\n};\n/**\n * Distributes the elements with a given orientation\n *\n * @param  {Array} elements    [description]\n * @param  {String} orientation [description]\n */\n\n\nDistributeElements.prototype.trigger = function (elements, orientation) {\n  var modeling = this._modeling;\n  var groups, distributableElements;\n\n  if (elements.length < 3) {\n    return;\n  }\n\n  this._setOrientation(orientation);\n\n  distributableElements = this._filterElements(elements);\n  groups = this._createGroups(distributableElements); // nothing to distribute\n\n  if (groups.length <= 2) {\n    return;\n  }\n\n  modeling.distributeElements(groups, this._axis, this._dimension);\n  return groups;\n};\n/**\n * Filters the elements with provided filters by external parties\n *\n * @param  {Array[Elements]} elements\n *\n * @return {Array[Elements]}\n */\n\n\nDistributeElements.prototype._filterElements = function (elements) {\n  var filters = this._filters,\n      axis = this._axis,\n      dimension = this._dimension,\n      distributableElements = [].concat(elements);\n\n  if (!filters.length) {\n    return elements;\n  }\n\n  forEach(filters, function (filterFn) {\n    distributableElements = filterFn(distributableElements, axis, dimension);\n  });\n  return distributableElements;\n};\n/**\n * Create range (min, max) groups. Also tries to group elements\n * together that share the same range.\n *\n * @example\n * \tvar distributableElements = [\n * \t\t{\n * \t\t\trange: {\n * \t\t\t\tmin: 100,\n * \t\t\t\tmax: 200\n * \t\t\t},\n * \t\t\telements: [ { id: 'shape1', .. }]\n * \t\t}\n * \t]\n *\n * @param  {Array} elements\n *\n * @return {Array[Objects]}\n */\n\n\nDistributeElements.prototype._createGroups = function (elements) {\n  var rangeGroups = [],\n      self = this,\n      axis = this._axis,\n      dimension = this._dimension;\n\n  if (!axis) {\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\n  } // sort by 'left->right' or 'top->bottom'\n\n\n  var sortedElements = sortBy(elements, axis);\n  forEach(sortedElements, function (element, idx) {\n    var elementRange = self._findRange(element, axis, dimension),\n        range;\n\n    var previous = rangeGroups[rangeGroups.length - 1];\n\n    if (previous && self._hasIntersection(previous.range, elementRange)) {\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\n    } else {\n      range = {\n        range: elementRange,\n        elements: [element]\n      };\n      rangeGroups.push(range);\n    }\n  });\n  return rangeGroups;\n};\n/**\n * Maps a direction to the according axis and dimension\n *\n * @param  {String} direction 'horizontal' or 'vertical'\n */\n\n\nDistributeElements.prototype._setOrientation = function (direction) {\n  var orientation = AXIS_DIMENSIONS[direction];\n  this._axis = orientation[0];\n  this._dimension = orientation[1];\n};\n/**\n * Checks if the two ranges intercept each other\n *\n * @param  {Object} rangeA {min, max}\n * @param  {Object} rangeB {min, max}\n *\n * @return {Boolean}\n */\n\n\nDistributeElements.prototype._hasIntersection = function (rangeA, rangeB) {\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\n};\n/**\n * Returns the min and max values for an element\n *\n * @param  {[type]} element   [description]\n * @param  {[type]} axis      [description]\n * @param  {[type]} dimension [description]\n *\n * @return {[type]}           [description]\n */\n\n\nDistributeElements.prototype._findRange = function (element) {\n  var axis = element[this._axis],\n      dimension = element[this._dimension];\n  return {\n    min: axis + THRESHOLD,\n    max: axis + dimension - THRESHOLD\n  };\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/features/distribute-elements/DistributeElements.js"],"names":["sortBy","forEach","filter","AXIS_DIMENSIONS","horizontal","vertical","THRESHOLD","DistributeElements","modeling","_modeling","_filters","registerFilter","elements","axis","dimension","elementsSize","numOfShapes","avgDimension","element","waypoints","labelTarget","Math","round","$inject","prototype","filterFn","Error","push","trigger","orientation","groups","distributableElements","length","_setOrientation","_filterElements","_createGroups","distributeElements","_axis","_dimension","filters","concat","rangeGroups","self","sortedElements","idx","elementRange","_findRange","range","previous","_hasIntersection","direction","rangeA","rangeB","max","min"],"mappings":"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","sourcesContent":["import {\n  sortBy,\n  forEach,\n  filter\n} from 'min-dash';\n\nvar AXIS_DIMENSIONS = {\n  horizontal: [ 'x', 'width' ],\n  vertical: [ 'y', 'height' ]\n};\n\nvar THRESHOLD = 5;\n\n\n/**\n * Groups and filters elements and then trigger even distribution.\n */\nexport default function DistributeElements(modeling) {\n  this._modeling = modeling;\n\n  this._filters = [];\n\n  // register filter for filtering big elements\n  this.registerFilter(function(elements, axis, dimension) {\n    var elementsSize = 0,\n        numOfShapes = 0,\n        avgDimension;\n\n    forEach(elements, function(element) {\n      if (element.waypoints || element.labelTarget) {\n        return;\n      }\n\n      elementsSize += element[dimension];\n\n      numOfShapes += 1;\n    });\n\n    avgDimension = Math.round(elementsSize / numOfShapes);\n\n    return filter(elements, function(element) {\n      return element[dimension] < (avgDimension + 50);\n    });\n  });\n\n}\n\nDistributeElements.$inject = [ 'modeling' ];\n\n\n/**\n * Registers filter functions that allow external parties to filter\n * out certain elements.\n *\n * @param  {Function} filterFn\n */\nDistributeElements.prototype.registerFilter = function(filterFn) {\n  if (typeof filterFn !== 'function') {\n    throw new Error('the filter has to be a function');\n  }\n\n  this._filters.push(filterFn);\n};\n\n/**\n * Distributes the elements with a given orientation\n *\n * @param  {Array} elements    [description]\n * @param  {String} orientation [description]\n */\nDistributeElements.prototype.trigger = function(elements, orientation) {\n  var modeling = this._modeling;\n\n  var groups,\n      distributableElements;\n\n  if (elements.length < 3) {\n    return;\n  }\n\n  this._setOrientation(orientation);\n\n  distributableElements = this._filterElements(elements);\n\n  groups = this._createGroups(distributableElements);\n\n  // nothing to distribute\n  if (groups.length <= 2) {\n    return;\n  }\n\n  modeling.distributeElements(groups, this._axis, this._dimension);\n\n  return groups;\n};\n\n/**\n * Filters the elements with provided filters by external parties\n *\n * @param  {Array[Elements]} elements\n *\n * @return {Array[Elements]}\n */\nDistributeElements.prototype._filterElements = function(elements) {\n  var filters = this._filters,\n      axis = this._axis,\n      dimension = this._dimension,\n      distributableElements = [].concat(elements);\n\n  if (!filters.length) {\n    return elements;\n  }\n\n  forEach(filters, function(filterFn) {\n    distributableElements = filterFn(distributableElements, axis, dimension);\n  });\n\n  return distributableElements;\n};\n\n\n/**\n * Create range (min, max) groups. Also tries to group elements\n * together that share the same range.\n *\n * @example\n * \tvar distributableElements = [\n * \t\t{\n * \t\t\trange: {\n * \t\t\t\tmin: 100,\n * \t\t\t\tmax: 200\n * \t\t\t},\n * \t\t\telements: [ { id: 'shape1', .. }]\n * \t\t}\n * \t]\n *\n * @param  {Array} elements\n *\n * @return {Array[Objects]}\n */\nDistributeElements.prototype._createGroups = function(elements) {\n  var rangeGroups = [],\n      self = this,\n      axis = this._axis,\n      dimension = this._dimension;\n\n  if (!axis) {\n    throw new Error('must have a defined \"axis\" and \"dimension\"');\n  }\n\n  // sort by 'left->right' or 'top->bottom'\n  var sortedElements = sortBy(elements, axis);\n\n  forEach(sortedElements, function(element, idx) {\n    var elementRange = self._findRange(element, axis, dimension),\n        range;\n\n    var previous = rangeGroups[rangeGroups.length - 1];\n\n    if (previous && self._hasIntersection(previous.range, elementRange)) {\n      rangeGroups[rangeGroups.length - 1].elements.push(element);\n    } else {\n      range = { range: elementRange, elements: [ element ] };\n\n      rangeGroups.push(range);\n    }\n  });\n\n  return rangeGroups;\n};\n\n\n/**\n * Maps a direction to the according axis and dimension\n *\n * @param  {String} direction 'horizontal' or 'vertical'\n */\nDistributeElements.prototype._setOrientation = function(direction) {\n  var orientation = AXIS_DIMENSIONS[direction];\n\n  this._axis = orientation[0];\n  this._dimension = orientation[1];\n};\n\n\n/**\n * Checks if the two ranges intercept each other\n *\n * @param  {Object} rangeA {min, max}\n * @param  {Object} rangeB {min, max}\n *\n * @return {Boolean}\n */\nDistributeElements.prototype._hasIntersection = function(rangeA, rangeB) {\n  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) &&\n         Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);\n};\n\n\n/**\n * Returns the min and max values for an element\n *\n * @param  {[type]} element   [description]\n * @param  {[type]} axis      [description]\n * @param  {[type]} dimension [description]\n *\n * @return {[type]}           [description]\n */\nDistributeElements.prototype._findRange = function(element) {\n  var axis = element[this._axis],\n      dimension = element[this._dimension];\n\n  return {\n    min: axis + THRESHOLD,\n    max: axis + dimension - THRESHOLD\n  };\n};\n"]},"metadata":{},"sourceType":"module"}