{"ast":null,"code":"import { add as collectionAdd, indexOf as collectionIdx } from '../../../util/Collections';\nimport { saveClear } from '../../../util/Removal';\n/**\n * A handler that implements reversible deletion of shapes.\n *\n */\n\nexport default function DeleteShapeHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\nDeleteShapeHandler.$inject = ['canvas', 'modeling'];\n/**\n * - Remove connections\n * - Remove all direct children\n */\n\nDeleteShapeHandler.prototype.preExecute = function (context) {\n  var modeling = this._modeling;\n  var shape = context.shape; // remove connections\n\n  saveClear(shape.incoming, function (connection) {\n    // To make sure that the connection isn't removed twice\n    // For example if a container is removed\n    modeling.removeConnection(connection, {\n      nested: true\n    });\n  });\n  saveClear(shape.outgoing, function (connection) {\n    modeling.removeConnection(connection, {\n      nested: true\n    });\n  }); // remove child shapes and connections\n\n  saveClear(shape.children, function (child) {\n    if (isConnection(child)) {\n      modeling.removeConnection(child, {\n        nested: true\n      });\n    } else {\n      modeling.removeShape(child, {\n        nested: true\n      });\n    }\n  });\n};\n/**\n * Remove shape and remember the parent\n */\n\n\nDeleteShapeHandler.prototype.execute = function (context) {\n  var canvas = this._canvas;\n  var shape = context.shape,\n      oldParent = shape.parent;\n  context.oldParent = oldParent; // remove containment\n\n  context.oldParentIndex = collectionIdx(oldParent.children, shape); // remove shape\n\n  canvas.removeShape(shape);\n  return shape;\n};\n/**\n * Command revert implementation\n */\n\n\nDeleteShapeHandler.prototype.revert = function (context) {\n  var canvas = this._canvas;\n  var shape = context.shape,\n      oldParent = context.oldParent,\n      oldParentIndex = context.oldParentIndex; // restore containment\n\n  collectionAdd(oldParent.children, shape, oldParentIndex);\n  canvas.addShape(shape, oldParent);\n  return shape;\n};\n\nfunction isConnection(element) {\n  return element.waypoints;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js"],"names":["add","collectionAdd","indexOf","collectionIdx","saveClear","DeleteShapeHandler","canvas","modeling","_canvas","_modeling","$inject","prototype","preExecute","context","shape","incoming","connection","removeConnection","nested","outgoing","children","child","isConnection","removeShape","execute","oldParent","parent","oldParentIndex","revert","addShape","element","waypoints"],"mappings":"AAAA,SACEA,GAAG,IAAIC,aADT,EAEEC,OAAO,IAAIC,aAFb,QAGO,2BAHP;AAKA,SAASC,SAAT,QAA0B,uBAA1B;AAGA;AACA;AACA;AACA;;AACA,eAAe,SAASC,kBAAT,CAA4BC,MAA5B,EAAoCC,QAApC,EAA8C;AAC3D,OAAKC,OAAL,GAAeF,MAAf;AACA,OAAKG,SAAL,GAAiBF,QAAjB;AACD;AAEDF,kBAAkB,CAACK,OAAnB,GAA6B,CAAE,QAAF,EAAY,UAAZ,CAA7B;AAGA;AACA;AACA;AACA;;AACAL,kBAAkB,CAACM,SAAnB,CAA6BC,UAA7B,GAA0C,UAASC,OAAT,EAAkB;AAE1D,MAAIN,QAAQ,GAAG,KAAKE,SAApB;AAEA,MAAIK,KAAK,GAAGD,OAAO,CAACC,KAApB,CAJ0D,CAM1D;;AACAV,EAAAA,SAAS,CAACU,KAAK,CAACC,QAAP,EAAiB,UAASC,UAAT,EAAqB;AAC7C;AACA;AACAT,IAAAA,QAAQ,CAACU,gBAAT,CAA0BD,UAA1B,EAAsC;AAAEE,MAAAA,MAAM,EAAE;AAAV,KAAtC;AACD,GAJQ,CAAT;AAMAd,EAAAA,SAAS,CAACU,KAAK,CAACK,QAAP,EAAiB,UAASH,UAAT,EAAqB;AAC7CT,IAAAA,QAAQ,CAACU,gBAAT,CAA0BD,UAA1B,EAAsC;AAAEE,MAAAA,MAAM,EAAE;AAAV,KAAtC;AACD,GAFQ,CAAT,CAb0D,CAiB1D;;AACAd,EAAAA,SAAS,CAACU,KAAK,CAACM,QAAP,EAAiB,UAASC,KAAT,EAAgB;AACxC,QAAIC,YAAY,CAACD,KAAD,CAAhB,EAAyB;AACvBd,MAAAA,QAAQ,CAACU,gBAAT,CAA0BI,KAA1B,EAAiC;AAAEH,QAAAA,MAAM,EAAE;AAAV,OAAjC;AACD,KAFD,MAEO;AACLX,MAAAA,QAAQ,CAACgB,WAAT,CAAqBF,KAArB,EAA4B;AAAEH,QAAAA,MAAM,EAAE;AAAV,OAA5B;AACD;AACF,GANQ,CAAT;AAOD,CAzBD;AA2BA;AACA;AACA;;;AACAb,kBAAkB,CAACM,SAAnB,CAA6Ba,OAA7B,GAAuC,UAASX,OAAT,EAAkB;AACvD,MAAIP,MAAM,GAAG,KAAKE,OAAlB;AAEA,MAAIM,KAAK,GAAGD,OAAO,CAACC,KAApB;AAAA,MACIW,SAAS,GAAGX,KAAK,CAACY,MADtB;AAGAb,EAAAA,OAAO,CAACY,SAAR,GAAoBA,SAApB,CANuD,CAQvD;;AACAZ,EAAAA,OAAO,CAACc,cAAR,GAAyBxB,aAAa,CAACsB,SAAS,CAACL,QAAX,EAAqBN,KAArB,CAAtC,CATuD,CAWvD;;AACAR,EAAAA,MAAM,CAACiB,WAAP,CAAmBT,KAAnB;AAEA,SAAOA,KAAP;AACD,CAfD;AAkBA;AACA;AACA;;;AACAT,kBAAkB,CAACM,SAAnB,CAA6BiB,MAA7B,GAAsC,UAASf,OAAT,EAAkB;AAEtD,MAAIP,MAAM,GAAG,KAAKE,OAAlB;AAEA,MAAIM,KAAK,GAAGD,OAAO,CAACC,KAApB;AAAA,MACIW,SAAS,GAAGZ,OAAO,CAACY,SADxB;AAAA,MAEIE,cAAc,GAAGd,OAAO,CAACc,cAF7B,CAJsD,CAQtD;;AACA1B,EAAAA,aAAa,CAACwB,SAAS,CAACL,QAAX,EAAqBN,KAArB,EAA4Ba,cAA5B,CAAb;AAEArB,EAAAA,MAAM,CAACuB,QAAP,CAAgBf,KAAhB,EAAuBW,SAAvB;AAEA,SAAOX,KAAP;AACD,CAdD;;AAgBA,SAASQ,YAAT,CAAsBQ,OAAtB,EAA+B;AAC7B,SAAOA,OAAO,CAACC,SAAf;AACD","sourcesContent":["import {\n  add as collectionAdd,\n  indexOf as collectionIdx\n} from '../../../util/Collections';\n\nimport { saveClear } from '../../../util/Removal';\n\n\n/**\n * A handler that implements reversible deletion of shapes.\n *\n */\nexport default function DeleteShapeHandler(canvas, modeling) {\n  this._canvas = canvas;\n  this._modeling = modeling;\n}\n\nDeleteShapeHandler.$inject = [ 'canvas', 'modeling' ];\n\n\n/**\n * - Remove connections\n * - Remove all direct children\n */\nDeleteShapeHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling;\n\n  var shape = context.shape;\n\n  // remove connections\n  saveClear(shape.incoming, function(connection) {\n    // To make sure that the connection isn't removed twice\n    // For example if a container is removed\n    modeling.removeConnection(connection, { nested: true });\n  });\n\n  saveClear(shape.outgoing, function(connection) {\n    modeling.removeConnection(connection, { nested: true });\n  });\n\n  // remove child shapes and connections\n  saveClear(shape.children, function(child) {\n    if (isConnection(child)) {\n      modeling.removeConnection(child, { nested: true });\n    } else {\n      modeling.removeShape(child, { nested: true });\n    }\n  });\n};\n\n/**\n * Remove shape and remember the parent\n */\nDeleteShapeHandler.prototype.execute = function(context) {\n  var canvas = this._canvas;\n\n  var shape = context.shape,\n      oldParent = shape.parent;\n\n  context.oldParent = oldParent;\n\n  // remove containment\n  context.oldParentIndex = collectionIdx(oldParent.children, shape);\n\n  // remove shape\n  canvas.removeShape(shape);\n\n  return shape;\n};\n\n\n/**\n * Command revert implementation\n */\nDeleteShapeHandler.prototype.revert = function(context) {\n\n  var canvas = this._canvas;\n\n  var shape = context.shape,\n      oldParent = context.oldParent,\n      oldParentIndex = context.oldParentIndex;\n\n  // restore containment\n  collectionAdd(oldParent.children, shape, oldParentIndex);\n\n  canvas.addShape(shape, oldParent);\n\n  return shape;\n};\n\nfunction isConnection(element) {\n  return element.waypoints;\n}\n"]},"metadata":{},"sourceType":"module"}