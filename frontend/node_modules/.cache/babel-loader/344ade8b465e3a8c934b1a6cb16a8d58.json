{"ast":null,"code":"import { filter, find, forEach } from 'min-dash';\nimport Refs from 'object-refs';\nimport { elementToString } from './Util';\nvar diRefs = new Refs({\n  name: 'bpmnElement',\n  enumerable: true\n}, {\n  name: 'di',\n  configurable: true\n});\n/**\n * Returns true if an element has the given meta-model type\n *\n * @param  {ModdleElement}  element\n * @param  {String}         type\n *\n * @return {Boolean}\n */\n\nfunction is(element, type) {\n  return element.$instanceOf(type);\n}\n/**\n * Find a suitable display candidate for definitions where the DI does not\n * correctly specify one.\n */\n\n\nfunction findDisplayCandidate(definitions) {\n  return find(definitions.rootElements, function (e) {\n    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\n  });\n}\n\nexport default function BpmnTreeWalker(handler, translate) {\n  // list of containers already walked\n  var handledElements = {}; // list of elements to handle deferred to ensure\n  // prerequisites are drawn\n\n  var deferred = []; // Helpers //////////////////////\n\n  function contextual(fn, ctx) {\n    return function (e) {\n      fn(e, ctx);\n    };\n  }\n\n  function handled(element) {\n    handledElements[element.id] = element;\n  }\n\n  function isHandled(element) {\n    return handledElements[element.id];\n  }\n\n  function visit(element, ctx) {\n    var gfx = element.gfx; // avoid multiple rendering of elements\n\n    if (gfx) {\n      throw new Error(translate('already rendered {element}', {\n        element: elementToString(element)\n      }));\n    } // call handler\n\n\n    return handler.element(element, ctx);\n  }\n\n  function visitRoot(element, diagram) {\n    return handler.root(element, diagram);\n  }\n\n  function visitIfDi(element, ctx) {\n    try {\n      var gfx = element.di && visit(element, ctx);\n      handled(element);\n      return gfx;\n    } catch (e) {\n      logError(e.message, {\n        element: element,\n        error: e\n      });\n      console.error(translate('failed to import {element}', {\n        element: elementToString(element)\n      }));\n      console.error(e);\n    }\n  }\n\n  function logError(message, context) {\n    handler.error(message, context);\n  } // DI handling //////////////////////\n\n\n  function registerDi(di) {\n    var bpmnElement = di.bpmnElement;\n\n    if (bpmnElement) {\n      if (bpmnElement.di) {\n        logError(translate('multiple DI elements defined for {element}', {\n          element: elementToString(bpmnElement)\n        }), {\n          element: bpmnElement\n        });\n      } else {\n        diRefs.bind(bpmnElement, 'di');\n        bpmnElement.di = di;\n      }\n    } else {\n      logError(translate('no bpmnElement referenced in {element}', {\n        element: elementToString(di)\n      }), {\n        element: di\n      });\n    }\n  }\n\n  function handleDiagram(diagram) {\n    handlePlane(diagram.plane);\n  }\n\n  function handlePlane(plane) {\n    registerDi(plane);\n    forEach(plane.planeElement, handlePlaneElement);\n  }\n\n  function handlePlaneElement(planeElement) {\n    registerDi(planeElement);\n  } // Semantic handling //////////////////////\n\n  /**\n   * Handle definitions and return the rendered diagram (if any)\n   *\n   * @param {ModdleElement} definitions to walk and import\n   * @param {ModdleElement} [diagram] specific diagram to import and display\n   *\n   * @throws {Error} if no diagram to display could be found\n   */\n\n\n  function handleDefinitions(definitions, diagram) {\n    // make sure we walk the correct bpmnElement\n    var diagrams = definitions.diagrams;\n\n    if (diagram && diagrams.indexOf(diagram) === -1) {\n      throw new Error(translate('diagram not part of bpmn:Definitions'));\n    }\n\n    if (!diagram && diagrams && diagrams.length) {\n      diagram = diagrams[0];\n    } // no diagram -> nothing to import\n\n\n    if (!diagram) {\n      throw new Error(translate('no diagram to display'));\n    } // load DI from selected diagram only\n\n\n    handleDiagram(diagram);\n    var plane = diagram.plane;\n\n    if (!plane) {\n      throw new Error(translate('no plane for {element}', {\n        element: elementToString(diagram)\n      }));\n    }\n\n    var rootElement = plane.bpmnElement; // ensure we default to a suitable display candidate (process or collaboration),\n    // even if non is specified in DI\n\n    if (!rootElement) {\n      rootElement = findDisplayCandidate(definitions);\n\n      if (!rootElement) {\n        throw new Error(translate('no process or collaboration to display'));\n      } else {\n        logError(translate('correcting missing bpmnElement on {plane} to {rootElement}', {\n          plane: elementToString(plane),\n          rootElement: elementToString(rootElement)\n        })); // correct DI on the fly\n\n        plane.bpmnElement = rootElement;\n        registerDi(plane);\n      }\n    }\n\n    var ctx = visitRoot(rootElement, plane);\n\n    if (is(rootElement, 'bpmn:Process')) {\n      handleProcess(rootElement, ctx);\n    } else if (is(rootElement, 'bpmn:Collaboration')) {\n      handleCollaboration(rootElement, ctx); // force drawing of everything not yet drawn that is part of the target DI\n\n      handleUnhandledProcesses(definitions.rootElements, ctx);\n    } else {\n      throw new Error(translate('unsupported bpmnElement for {plane}: {rootElement}', {\n        plane: elementToString(plane),\n        rootElement: elementToString(rootElement)\n      }));\n    } // handle all deferred elements\n\n\n    handleDeferred(deferred);\n  }\n\n  function handleDeferred() {\n    var fn; // drain deferred until empty\n\n    while (deferred.length) {\n      fn = deferred.shift();\n      fn();\n    }\n  }\n\n  function handleProcess(process, context) {\n    handleFlowElementsContainer(process, context);\n    handleIoSpecification(process.ioSpecification, context);\n    handleArtifacts(process.artifacts, context); // log process handled\n\n    handled(process);\n  }\n\n  function handleUnhandledProcesses(rootElements, ctx) {\n    // walk through all processes that have not yet been drawn and draw them\n    // if they contain lanes with DI information.\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\n    var processes = filter(rootElements, function (e) {\n      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\n    });\n    processes.forEach(contextual(handleProcess, ctx));\n  }\n\n  function handleMessageFlow(messageFlow, context) {\n    visitIfDi(messageFlow, context);\n  }\n\n  function handleMessageFlows(messageFlows, context) {\n    forEach(messageFlows, contextual(handleMessageFlow, context));\n  }\n\n  function handleDataAssociation(association, context) {\n    visitIfDi(association, context);\n  }\n\n  function handleDataInput(dataInput, context) {\n    visitIfDi(dataInput, context);\n  }\n\n  function handleDataOutput(dataOutput, context) {\n    visitIfDi(dataOutput, context);\n  }\n\n  function handleArtifact(artifact, context) {\n    // bpmn:TextAnnotation\n    // bpmn:Group\n    // bpmn:Association\n    visitIfDi(artifact, context);\n  }\n\n  function handleArtifacts(artifacts, context) {\n    forEach(artifacts, function (e) {\n      if (is(e, 'bpmn:Association')) {\n        deferred.push(function () {\n          handleArtifact(e, context);\n        });\n      } else {\n        handleArtifact(e, context);\n      }\n    });\n  }\n\n  function handleIoSpecification(ioSpecification, context) {\n    if (!ioSpecification) {\n      return;\n    }\n\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\n  }\n\n  function handleSubProcess(subProcess, context) {\n    handleFlowElementsContainer(subProcess, context);\n    handleArtifacts(subProcess.artifacts, context);\n  }\n\n  function handleFlowNode(flowNode, context) {\n    var childCtx = visitIfDi(flowNode, context);\n\n    if (is(flowNode, 'bpmn:SubProcess')) {\n      handleSubProcess(flowNode, childCtx || context);\n    }\n\n    if (is(flowNode, 'bpmn:Activity')) {\n      handleIoSpecification(flowNode.ioSpecification, context);\n    } // defer handling of associations\n    // affected types:\n    //\n    //   * bpmn:Activity\n    //   * bpmn:ThrowEvent\n    //   * bpmn:CatchEvent\n    //\n\n\n    deferred.push(function () {\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\n    });\n  }\n\n  function handleSequenceFlow(sequenceFlow, context) {\n    visitIfDi(sequenceFlow, context);\n  }\n\n  function handleDataElement(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleBoundaryEvent(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleLane(lane, context) {\n    deferred.push(function () {\n      var newContext = visitIfDi(lane, context);\n\n      if (lane.childLaneSet) {\n        handleLaneSet(lane.childLaneSet, newContext || context);\n      }\n\n      wireFlowNodeRefs(lane);\n    });\n  }\n\n  function handleLaneSet(laneSet, context) {\n    forEach(laneSet.lanes, contextual(handleLane, context));\n  }\n\n  function handleLaneSets(laneSets, context) {\n    forEach(laneSets, contextual(handleLaneSet, context));\n  }\n\n  function handleFlowElementsContainer(container, context) {\n    handleFlowElements(container.flowElements, context);\n\n    if (container.laneSets) {\n      handleLaneSets(container.laneSets, context);\n    }\n  }\n\n  function handleFlowElements(flowElements, context) {\n    forEach(flowElements, function (e) {\n      if (is(e, 'bpmn:SequenceFlow')) {\n        deferred.push(function () {\n          handleSequenceFlow(e, context);\n        });\n      } else if (is(e, 'bpmn:BoundaryEvent')) {\n        deferred.unshift(function () {\n          handleBoundaryEvent(e, context);\n        });\n      } else if (is(e, 'bpmn:FlowNode')) {\n        handleFlowNode(e, context);\n      } else if (is(e, 'bpmn:DataObject')) {// SKIP (assume correct referencing via DataObjectReference)\n      } else if (is(e, 'bpmn:DataStoreReference')) {\n        handleDataElement(e, context);\n      } else if (is(e, 'bpmn:DataObjectReference')) {\n        handleDataElement(e, context);\n      } else {\n        logError(translate('unrecognized flowElement {element} in context {context}', {\n          element: elementToString(e),\n          context: context ? elementToString(context.businessObject) : 'null'\n        }), {\n          element: e,\n          context: context\n        });\n      }\n    });\n  }\n\n  function handleParticipant(participant, context) {\n    var newCtx = visitIfDi(participant, context);\n    var process = participant.processRef;\n\n    if (process) {\n      handleProcess(process, newCtx || context);\n    }\n  }\n\n  function handleCollaboration(collaboration) {\n    forEach(collaboration.participants, contextual(handleParticipant));\n    handleArtifacts(collaboration.artifacts); // handle message flows latest in the process\n\n    deferred.push(function () {\n      handleMessageFlows(collaboration.messageFlows);\n    });\n  }\n\n  function wireFlowNodeRefs(lane) {\n    // wire the virtual flowNodeRefs <-> relationship\n    forEach(lane.flowNodeRef, function (flowNode) {\n      var lanes = flowNode.get('lanes');\n\n      if (lanes) {\n        lanes.push(lane);\n      }\n    });\n  } // API //////////////////////\n\n\n  return {\n    handleDeferred: handleDeferred,\n    handleDefinitions: handleDefinitions,\n    handleSubProcess: handleSubProcess,\n    registerDi: registerDi\n  };\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/import/BpmnTreeWalker.js"],"names":["filter","find","forEach","Refs","elementToString","diRefs","name","enumerable","configurable","is","element","type","$instanceOf","findDisplayCandidate","definitions","rootElements","e","BpmnTreeWalker","handler","translate","handledElements","deferred","contextual","fn","ctx","handled","id","isHandled","visit","gfx","Error","visitRoot","diagram","root","visitIfDi","di","logError","message","error","console","context","registerDi","bpmnElement","bind","handleDiagram","handlePlane","plane","planeElement","handlePlaneElement","handleDefinitions","diagrams","indexOf","length","rootElement","handleProcess","handleCollaboration","handleUnhandledProcesses","handleDeferred","shift","process","handleFlowElementsContainer","handleIoSpecification","ioSpecification","handleArtifacts","artifacts","processes","laneSets","handleMessageFlow","messageFlow","handleMessageFlows","messageFlows","handleDataAssociation","association","handleDataInput","dataInput","handleDataOutput","dataOutput","handleArtifact","artifact","push","dataInputs","dataOutputs","handleSubProcess","subProcess","handleFlowNode","flowNode","childCtx","dataInputAssociations","dataOutputAssociations","handleSequenceFlow","sequenceFlow","handleDataElement","dataObject","handleBoundaryEvent","handleLane","lane","newContext","childLaneSet","handleLaneSet","wireFlowNodeRefs","laneSet","lanes","handleLaneSets","container","handleFlowElements","flowElements","unshift","businessObject","handleParticipant","participant","newCtx","processRef","collaboration","participants","flowNodeRef","get"],"mappings":"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","sourcesContent":["import {\n  filter,\n  find,\n  forEach\n} from 'min-dash';\n\nimport Refs from 'object-refs';\n\nimport {\n  elementToString\n} from './Util';\n\nvar diRefs = new Refs(\n  { name: 'bpmnElement', enumerable: true },\n  { name: 'di', configurable: true }\n);\n\n/**\n * Returns true if an element has the given meta-model type\n *\n * @param  {ModdleElement}  element\n * @param  {String}         type\n *\n * @return {Boolean}\n */\nfunction is(element, type) {\n  return element.$instanceOf(type);\n}\n\n\n/**\n * Find a suitable display candidate for definitions where the DI does not\n * correctly specify one.\n */\nfunction findDisplayCandidate(definitions) {\n  return find(definitions.rootElements, function(e) {\n    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');\n  });\n}\n\n\nexport default function BpmnTreeWalker(handler, translate) {\n\n  // list of containers already walked\n  var handledElements = {};\n\n  // list of elements to handle deferred to ensure\n  // prerequisites are drawn\n  var deferred = [];\n\n  // Helpers //////////////////////\n\n  function contextual(fn, ctx) {\n    return function(e) {\n      fn(e, ctx);\n    };\n  }\n\n  function handled(element) {\n    handledElements[element.id] = element;\n  }\n\n  function isHandled(element) {\n    return handledElements[element.id];\n  }\n\n  function visit(element, ctx) {\n\n    var gfx = element.gfx;\n\n    // avoid multiple rendering of elements\n    if (gfx) {\n      throw new Error(\n        translate('already rendered {element}', { element: elementToString(element) })\n      );\n    }\n\n    // call handler\n    return handler.element(element, ctx);\n  }\n\n  function visitRoot(element, diagram) {\n    return handler.root(element, diagram);\n  }\n\n  function visitIfDi(element, ctx) {\n\n    try {\n      var gfx = element.di && visit(element, ctx);\n\n      handled(element);\n\n      return gfx;\n    } catch (e) {\n      logError(e.message, { element: element, error: e });\n\n      console.error(translate('failed to import {element}', { element: elementToString(element) }));\n      console.error(e);\n    }\n  }\n\n  function logError(message, context) {\n    handler.error(message, context);\n  }\n\n  // DI handling //////////////////////\n\n  function registerDi(di) {\n    var bpmnElement = di.bpmnElement;\n\n    if (bpmnElement) {\n      if (bpmnElement.di) {\n        logError(\n          translate('multiple DI elements defined for {element}', {\n            element: elementToString(bpmnElement)\n          }),\n          { element: bpmnElement }\n        );\n      } else {\n        diRefs.bind(bpmnElement, 'di');\n        bpmnElement.di = di;\n      }\n    } else {\n      logError(\n        translate('no bpmnElement referenced in {element}', {\n          element: elementToString(di)\n        }),\n        { element: di }\n      );\n    }\n  }\n\n  function handleDiagram(diagram) {\n    handlePlane(diagram.plane);\n  }\n\n  function handlePlane(plane) {\n    registerDi(plane);\n\n    forEach(plane.planeElement, handlePlaneElement);\n  }\n\n  function handlePlaneElement(planeElement) {\n    registerDi(planeElement);\n  }\n\n\n  // Semantic handling //////////////////////\n\n  /**\n   * Handle definitions and return the rendered diagram (if any)\n   *\n   * @param {ModdleElement} definitions to walk and import\n   * @param {ModdleElement} [diagram] specific diagram to import and display\n   *\n   * @throws {Error} if no diagram to display could be found\n   */\n  function handleDefinitions(definitions, diagram) {\n    // make sure we walk the correct bpmnElement\n\n    var diagrams = definitions.diagrams;\n\n    if (diagram && diagrams.indexOf(diagram) === -1) {\n      throw new Error(translate('diagram not part of bpmn:Definitions'));\n    }\n\n    if (!diagram && diagrams && diagrams.length) {\n      diagram = diagrams[0];\n    }\n\n    // no diagram -> nothing to import\n    if (!diagram) {\n      throw new Error(translate('no diagram to display'));\n    }\n\n    // load DI from selected diagram only\n    handleDiagram(diagram);\n\n\n    var plane = diagram.plane;\n\n    if (!plane) {\n      throw new Error(translate(\n        'no plane for {element}',\n        { element: elementToString(diagram) }\n      ));\n    }\n\n    var rootElement = plane.bpmnElement;\n\n    // ensure we default to a suitable display candidate (process or collaboration),\n    // even if non is specified in DI\n    if (!rootElement) {\n      rootElement = findDisplayCandidate(definitions);\n\n      if (!rootElement) {\n        throw new Error(translate('no process or collaboration to display'));\n      } else {\n\n        logError(\n          translate('correcting missing bpmnElement on {plane} to {rootElement}', {\n            plane: elementToString(plane),\n            rootElement: elementToString(rootElement)\n          })\n        );\n\n        // correct DI on the fly\n        plane.bpmnElement = rootElement;\n        registerDi(plane);\n      }\n    }\n\n\n    var ctx = visitRoot(rootElement, plane);\n\n    if (is(rootElement, 'bpmn:Process')) {\n      handleProcess(rootElement, ctx);\n    } else if (is(rootElement, 'bpmn:Collaboration')) {\n      handleCollaboration(rootElement, ctx);\n\n      // force drawing of everything not yet drawn that is part of the target DI\n      handleUnhandledProcesses(definitions.rootElements, ctx);\n    } else {\n      throw new Error(\n        translate('unsupported bpmnElement for {plane}: {rootElement}', {\n          plane: elementToString(plane),\n          rootElement: elementToString(rootElement)\n        })\n      );\n    }\n\n    // handle all deferred elements\n    handleDeferred(deferred);\n  }\n\n  function handleDeferred() {\n\n    var fn;\n\n    // drain deferred until empty\n    while (deferred.length) {\n      fn = deferred.shift();\n\n      fn();\n    }\n  }\n\n  function handleProcess(process, context) {\n    handleFlowElementsContainer(process, context);\n    handleIoSpecification(process.ioSpecification, context);\n\n    handleArtifacts(process.artifacts, context);\n\n    // log process handled\n    handled(process);\n  }\n\n  function handleUnhandledProcesses(rootElements, ctx) {\n\n    // walk through all processes that have not yet been drawn and draw them\n    // if they contain lanes with DI information.\n    // we do this to pass the free-floating lane test cases in the MIWG test suite\n    var processes = filter(rootElements, function(e) {\n      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;\n    });\n\n    processes.forEach(contextual(handleProcess, ctx));\n  }\n\n  function handleMessageFlow(messageFlow, context) {\n    visitIfDi(messageFlow, context);\n  }\n\n  function handleMessageFlows(messageFlows, context) {\n    forEach(messageFlows, contextual(handleMessageFlow, context));\n  }\n\n  function handleDataAssociation(association, context) {\n    visitIfDi(association, context);\n  }\n\n  function handleDataInput(dataInput, context) {\n    visitIfDi(dataInput, context);\n  }\n\n  function handleDataOutput(dataOutput, context) {\n    visitIfDi(dataOutput, context);\n  }\n\n  function handleArtifact(artifact, context) {\n\n    // bpmn:TextAnnotation\n    // bpmn:Group\n    // bpmn:Association\n\n    visitIfDi(artifact, context);\n  }\n\n  function handleArtifacts(artifacts, context) {\n\n    forEach(artifacts, function(e) {\n      if (is(e, 'bpmn:Association')) {\n        deferred.push(function() {\n          handleArtifact(e, context);\n        });\n      } else {\n        handleArtifact(e, context);\n      }\n    });\n  }\n\n  function handleIoSpecification(ioSpecification, context) {\n\n    if (!ioSpecification) {\n      return;\n    }\n\n    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));\n    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));\n  }\n\n  function handleSubProcess(subProcess, context) {\n    handleFlowElementsContainer(subProcess, context);\n    handleArtifacts(subProcess.artifacts, context);\n  }\n\n  function handleFlowNode(flowNode, context) {\n    var childCtx = visitIfDi(flowNode, context);\n\n    if (is(flowNode, 'bpmn:SubProcess')) {\n      handleSubProcess(flowNode, childCtx || context);\n    }\n\n    if (is(flowNode, 'bpmn:Activity')) {\n      handleIoSpecification(flowNode.ioSpecification, context);\n    }\n\n    // defer handling of associations\n    // affected types:\n    //\n    //   * bpmn:Activity\n    //   * bpmn:ThrowEvent\n    //   * bpmn:CatchEvent\n    //\n    deferred.push(function() {\n      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));\n      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));\n    });\n  }\n\n  function handleSequenceFlow(sequenceFlow, context) {\n    visitIfDi(sequenceFlow, context);\n  }\n\n  function handleDataElement(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleBoundaryEvent(dataObject, context) {\n    visitIfDi(dataObject, context);\n  }\n\n  function handleLane(lane, context) {\n\n    deferred.push(function() {\n\n      var newContext = visitIfDi(lane, context);\n\n      if (lane.childLaneSet) {\n        handleLaneSet(lane.childLaneSet, newContext || context);\n      }\n\n      wireFlowNodeRefs(lane);\n    });\n  }\n\n  function handleLaneSet(laneSet, context) {\n    forEach(laneSet.lanes, contextual(handleLane, context));\n  }\n\n  function handleLaneSets(laneSets, context) {\n    forEach(laneSets, contextual(handleLaneSet, context));\n  }\n\n  function handleFlowElementsContainer(container, context) {\n    handleFlowElements(container.flowElements, context);\n\n    if (container.laneSets) {\n      handleLaneSets(container.laneSets, context);\n    }\n  }\n\n  function handleFlowElements(flowElements, context) {\n    forEach(flowElements, function(e) {\n      if (is(e, 'bpmn:SequenceFlow')) {\n        deferred.push(function() {\n          handleSequenceFlow(e, context);\n        });\n      } else if (is(e, 'bpmn:BoundaryEvent')) {\n        deferred.unshift(function() {\n          handleBoundaryEvent(e, context);\n        });\n      } else if (is(e, 'bpmn:FlowNode')) {\n        handleFlowNode(e, context);\n      } else if (is(e, 'bpmn:DataObject')) {\n        // SKIP (assume correct referencing via DataObjectReference)\n      } else if (is(e, 'bpmn:DataStoreReference')) {\n        handleDataElement(e, context);\n      } else if (is(e, 'bpmn:DataObjectReference')) {\n        handleDataElement(e, context);\n      } else {\n        logError(\n          translate('unrecognized flowElement {element} in context {context}', {\n            element: elementToString(e),\n            context: (context ? elementToString(context.businessObject) : 'null')\n          }),\n          { element: e, context: context }\n        );\n      }\n    });\n  }\n\n  function handleParticipant(participant, context) {\n    var newCtx = visitIfDi(participant, context);\n\n    var process = participant.processRef;\n    if (process) {\n      handleProcess(process, newCtx || context);\n    }\n  }\n\n  function handleCollaboration(collaboration) {\n\n    forEach(collaboration.participants, contextual(handleParticipant));\n\n    handleArtifacts(collaboration.artifacts);\n\n    // handle message flows latest in the process\n    deferred.push(function() {\n      handleMessageFlows(collaboration.messageFlows);\n    });\n  }\n\n\n  function wireFlowNodeRefs(lane) {\n    // wire the virtual flowNodeRefs <-> relationship\n    forEach(lane.flowNodeRef, function(flowNode) {\n      var lanes = flowNode.get('lanes');\n\n      if (lanes) {\n        lanes.push(lane);\n      }\n    });\n  }\n\n  // API //////////////////////\n\n  return {\n    handleDeferred: handleDeferred,\n    handleDefinitions: handleDefinitions,\n    handleSubProcess: handleSubProcess,\n    registerDi: registerDi\n  };\n}"]},"metadata":{},"sourceType":"module"}