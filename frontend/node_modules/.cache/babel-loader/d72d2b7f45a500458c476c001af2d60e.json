{"ast":null,"code":"import { collectLanes, getLanesRoot } from '../util/LaneUtil';\nimport { is } from '../../../util/ModelUtil';\nimport { add as collectionAdd, remove as collectionRemove } from 'diagram-js/lib/util/Collections';\nimport { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nvar FLOW_NODE_REFS_ATTR = 'flowNodeRef',\n    LANES_ATTR = 'lanes';\n/**\n * A handler that updates lane refs on changed elements\n */\n\nexport default function UpdateFlowNodeRefsHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\nUpdateFlowNodeRefsHandler.$inject = ['elementRegistry'];\n\nUpdateFlowNodeRefsHandler.prototype.computeUpdates = function (flowNodeShapes, laneShapes) {\n  var handledNodes = {};\n  var updates = [];\n  var participantCache = {};\n  var allFlowNodeShapes = [];\n\n  function isInLaneShape(element, laneShape) {\n    var laneTrbl = asTRBL(laneShape);\n    var elementMid = {\n      x: element.x + element.width / 2,\n      y: element.y + element.height / 2\n    };\n    return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;\n  }\n\n  function addFlowNodeShape(flowNodeShape) {\n    if (!handledNodes[flowNodeShape.id]) {\n      allFlowNodeShapes.push(flowNodeShape);\n      handledNodes[flowNodeShape.id] = flowNodeShape;\n    }\n  }\n\n  function getAllLaneShapes(flowNodeShape) {\n    var root = getLanesRoot(flowNodeShape);\n\n    if (!participantCache[root.id]) {\n      participantCache[root.id] = collectLanes(root);\n    }\n\n    return participantCache[root.id];\n  }\n\n  function getNewLanes(flowNodeShape) {\n    if (!flowNodeShape.parent) {\n      return [];\n    }\n\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\n    return allLaneShapes.filter(function (l) {\n      return isInLaneShape(flowNodeShape, l);\n    }).map(function (shape) {\n      return shape.businessObject;\n    });\n  }\n\n  laneShapes.forEach(function (laneShape) {\n    var root = getLanesRoot(laneShape);\n\n    if (!root || handledNodes[root.id]) {\n      return;\n    }\n\n    var children = root.children.filter(function (c) {\n      return is(c, 'bpmn:FlowNode');\n    });\n    children.forEach(addFlowNodeShape);\n    handledNodes[root.id] = root;\n  });\n  flowNodeShapes.forEach(addFlowNodeShape);\n  allFlowNodeShapes.forEach(function (flowNodeShape) {\n    var flowNode = flowNodeShape.businessObject;\n    var lanes = flowNode.get(LANES_ATTR),\n        remove = lanes.slice(),\n        add = getNewLanes(flowNodeShape);\n    updates.push({\n      flowNode: flowNode,\n      remove: remove,\n      add: add\n    });\n  });\n  laneShapes.forEach(function (laneShape) {\n    var lane = laneShape.businessObject; // lane got removed XX-)\n\n    if (!laneShape.parent) {\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function (flowNode) {\n        updates.push({\n          flowNode: flowNode,\n          remove: [lane],\n          add: []\n        });\n      });\n    }\n  });\n  return updates;\n};\n\nUpdateFlowNodeRefsHandler.prototype.execute = function (context) {\n  var updates = context.updates;\n\n  if (!updates) {\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\n  }\n\n  updates.forEach(function (update) {\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR); // unwire old\n\n    update.remove.forEach(function (oldLane) {\n      collectionRemove(lanes, oldLane);\n      collectionRemove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    }); // wire new\n\n    update.add.forEach(function (newLane) {\n      collectionAdd(lanes, newLane);\n      collectionAdd(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  }); // TODO(nikku): return changed elements\n  // return [ ... ];\n};\n\nUpdateFlowNodeRefsHandler.prototype.revert = function (context) {\n  var updates = context.updates;\n  updates.forEach(function (update) {\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR); // unwire new\n\n    update.add.forEach(function (newLane) {\n      collectionRemove(lanes, newLane);\n      collectionRemove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    }); // wire old\n\n    update.remove.forEach(function (oldLane) {\n      collectionAdd(lanes, oldLane);\n      collectionAdd(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  }); // TODO(nikku): return changed elements\n  // return [ ... ];\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/features/modeling/cmd/UpdateFlowNodeRefsHandler.js"],"names":["collectLanes","getLanesRoot","is","add","collectionAdd","remove","collectionRemove","asTRBL","FLOW_NODE_REFS_ATTR","LANES_ATTR","UpdateFlowNodeRefsHandler","elementRegistry","_elementRegistry","$inject","prototype","computeUpdates","flowNodeShapes","laneShapes","handledNodes","updates","participantCache","allFlowNodeShapes","isInLaneShape","element","laneShape","laneTrbl","elementMid","x","width","y","height","left","right","top","bottom","addFlowNodeShape","flowNodeShape","id","push","getAllLaneShapes","root","getNewLanes","parent","allLaneShapes","filter","l","map","shape","businessObject","forEach","children","c","flowNode","lanes","get","slice","lane","execute","context","update","oldLane","newLane","revert"],"mappings":"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","sourcesContent":["import {\n  collectLanes,\n  getLanesRoot\n} from '../util/LaneUtil';\n\nimport {\n  is\n} from '../../../util/ModelUtil';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  asTRBL\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nvar FLOW_NODE_REFS_ATTR = 'flowNodeRef',\n    LANES_ATTR = 'lanes';\n\n\n/**\n * A handler that updates lane refs on changed elements\n */\nexport default function UpdateFlowNodeRefsHandler(elementRegistry) {\n  this._elementRegistry = elementRegistry;\n}\n\nUpdateFlowNodeRefsHandler.$inject = [\n  'elementRegistry'\n];\n\n\nUpdateFlowNodeRefsHandler.prototype.computeUpdates = function(flowNodeShapes, laneShapes) {\n\n  var handledNodes = {};\n\n  var updates = [];\n\n  var participantCache = {};\n\n  var allFlowNodeShapes = [];\n\n  function isInLaneShape(element, laneShape) {\n\n    var laneTrbl = asTRBL(laneShape);\n\n    var elementMid = {\n      x: element.x + element.width / 2,\n      y: element.y + element.height / 2\n    };\n\n    return elementMid.x > laneTrbl.left &&\n           elementMid.x < laneTrbl.right &&\n           elementMid.y > laneTrbl.top &&\n           elementMid.y < laneTrbl.bottom;\n  }\n\n  function addFlowNodeShape(flowNodeShape) {\n    if (!handledNodes[flowNodeShape.id]) {\n      allFlowNodeShapes.push(flowNodeShape);\n      handledNodes[flowNodeShape.id] = flowNodeShape;\n    }\n  }\n\n  function getAllLaneShapes(flowNodeShape) {\n\n    var root = getLanesRoot(flowNodeShape);\n\n    if (!participantCache[root.id]) {\n      participantCache[root.id] = collectLanes(root);\n    }\n\n    return participantCache[root.id];\n  }\n\n  function getNewLanes(flowNodeShape) {\n    if (!flowNodeShape.parent) {\n      return [];\n    }\n\n    var allLaneShapes = getAllLaneShapes(flowNodeShape);\n\n    return allLaneShapes.filter(function(l) {\n      return isInLaneShape(flowNodeShape, l);\n    }).map(function(shape) {\n      return shape.businessObject;\n    });\n  }\n\n  laneShapes.forEach(function(laneShape) {\n    var root = getLanesRoot(laneShape);\n\n    if (!root || handledNodes[root.id]) {\n      return;\n    }\n\n    var children = root.children.filter(function(c) {\n      return is(c, 'bpmn:FlowNode');\n    });\n\n    children.forEach(addFlowNodeShape);\n\n    handledNodes[root.id] = root;\n  });\n\n  flowNodeShapes.forEach(addFlowNodeShape);\n\n\n  allFlowNodeShapes.forEach(function(flowNodeShape) {\n\n    var flowNode = flowNodeShape.businessObject;\n\n    var lanes = flowNode.get(LANES_ATTR),\n        remove = lanes.slice(),\n        add = getNewLanes(flowNodeShape);\n\n    updates.push({ flowNode: flowNode, remove: remove, add: add });\n  });\n\n  laneShapes.forEach(function(laneShape) {\n\n    var lane = laneShape.businessObject;\n\n    // lane got removed XX-)\n    if (!laneShape.parent) {\n      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {\n        updates.push({ flowNode: flowNode, remove: [ lane ], add: [] });\n      });\n    }\n  });\n\n  return updates;\n};\n\nUpdateFlowNodeRefsHandler.prototype.execute = function(context) {\n\n  var updates = context.updates;\n\n  if (!updates) {\n    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);\n  }\n\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire old\n    update.remove.forEach(function(oldLane) {\n      collectionRemove(lanes, oldLane);\n      collectionRemove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire new\n    update.add.forEach(function(newLane) {\n      collectionAdd(lanes, newLane);\n      collectionAdd(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};\n\n\nUpdateFlowNodeRefsHandler.prototype.revert = function(context) {\n\n  var updates = context.updates;\n\n  updates.forEach(function(update) {\n\n    var flowNode = update.flowNode,\n        lanes = flowNode.get(LANES_ATTR);\n\n    // unwire new\n    update.add.forEach(function(newLane) {\n      collectionRemove(lanes, newLane);\n      collectionRemove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n\n    // wire old\n    update.remove.forEach(function(oldLane) {\n      collectionAdd(lanes, oldLane);\n      collectionAdd(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);\n    });\n  });\n\n  // TODO(nikku): return changed elements\n  // return [ ... ];\n};"]},"metadata":{},"sourceType":"module"}