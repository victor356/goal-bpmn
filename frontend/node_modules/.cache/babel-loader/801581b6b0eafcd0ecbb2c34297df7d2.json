{"ast":null,"code":"import { isString, isObject, forEach } from 'min-dash';\nimport Factory from './factory';\nimport Registry from './registry';\nimport Properties from './properties';\nimport { parseName as parseNameNs } from './ns'; //// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n */\n\nexport default function Moddle(packages) {\n  this.properties = new Properties(this);\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n  this.typeCache = {};\n}\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\n\nModdle.prototype.create = function (descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\n\n\nModdle.prototype.getType = function (descriptor) {\n  var cache = this.typeCache;\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\n\n\nModdle.prototype.createAny = function (name, nsUri, properties) {\n  var nameNs = parseNameNs(name);\n  var element = {\n    $type: name,\n    $instanceOf: function (type) {\n      return type === this.$type;\n    }\n  };\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, '$parent', {\n    enumerable: false,\n    writable: true\n  });\n  forEach(properties, function (a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n  return element;\n};\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\n\n\nModdle.prototype.getPackage = function (uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\n\n\nModdle.prototype.getPackages = function () {\n  return this.registry.getPackages();\n};\n/**\n * Returns the descriptor for an element\n */\n\n\nModdle.prototype.getElementDescriptor = function (element) {\n  return element.$descriptor;\n};\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\n\n\nModdle.prototype.hasType = function (element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n  return type in descriptor.allTypesByName;\n};\n/**\n * Returns the descriptor of an elements named property\n */\n\n\nModdle.prototype.getPropertyDescriptor = function (element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n/**\n * Returns a mapped type's descriptor\n */\n\n\nModdle.prototype.getTypeDescriptor = function (type) {\n  return this.registry.typeMap[type];\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/moddle/lib/moddle.js"],"names":["isString","isObject","forEach","Factory","Registry","Properties","parseName","parseNameNs","Moddle","packages","properties","factory","registry","typeCache","prototype","create","descriptor","attrs","Type","getType","Error","cache","name","ns","type","getEffectiveDescriptor","createType","createAny","nsUri","nameNs","element","$type","$instanceOf","isGeneric","prefix","localName","uri","defineDescriptor","defineModel","define","enumerable","writable","a","key","value","undefined","getPackage","uriOrPrefix","getPackages","getElementDescriptor","$descriptor","hasType","$model","allTypesByName","getPropertyDescriptor","property","propertiesByName","getTypeDescriptor","typeMap"],"mappings":"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","sourcesContent":["import {\n  isString,\n  isObject,\n  forEach\n} from 'min-dash';\n\nimport Factory from './factory';\nimport Registry from './registry';\nimport Properties from './properties';\n\nimport {\n  parseName as parseNameNs\n} from './ns';\n\n\n//// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n */\nexport default function Moddle(packages) {\n\n  this.properties = new Properties(this);\n\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n\n  this.typeCache = {};\n}\n\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function(descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function(descriptor) {\n\n  var cache = this.typeCache;\n\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function(name, nsUri, properties) {\n\n  var nameNs = parseNameNs(name);\n\n  var element = {\n    $type: name,\n    $instanceOf: function(type) {\n      return type === this.$type;\n    }\n  };\n\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, '$parent', { enumerable: false, writable: true });\n\n  forEach(properties, function(a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function(uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function() {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function(element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function(element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n\n  return (type in descriptor.allTypesByName);\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function(element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function(type) {\n  return this.registry.typeMap[type];\n};"]},"metadata":{},"sourceType":"module"}