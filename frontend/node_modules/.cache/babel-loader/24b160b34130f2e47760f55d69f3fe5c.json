{"ast":null,"code":"var sqrt = Math.sqrt,\n    min = Math.min,\n    max = Math.max,\n    abs = Math.abs;\n/**\n * Calculate the square (power to two) of a number.\n *\n * @param {Number} n\n *\n * @return {Number}\n */\n\nfunction sq(n) {\n  return Math.pow(n, 2);\n}\n/**\n * Get distance between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Number}\n */\n\n\nfunction getDistance(p1, p2) {\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\n}\n/**\n * Return the attachment of the given point on the specified line.\n *\n * The attachment is either a bendpoint (attached to the given point)\n * or segment (attached to a location on a line segment) attachment:\n *\n * ```javascript\n * var pointAttachment = {\n *   type: 'bendpoint',\n *   bendpointIndex: 3,\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n *\n * var segmentAttachment = {\n *   type: 'segment',\n *   segmentIndex: 2,\n *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n * ```\n *\n * @param {Point} point\n * @param {Array<Point>} line\n *\n * @return {Object} attachment\n */\n\n\nexport function getAttachment(point, line) {\n  var idx = 0,\n      segmentStart,\n      segmentEnd,\n      segmentStartDistance,\n      segmentEndDistance,\n      attachmentPosition,\n      minDistance,\n      intersections,\n      attachment,\n      attachmentDistance,\n      closestAttachmentDistance,\n      closestAttachment;\n\n  for (idx = 0; idx < line.length - 1; idx++) {\n    segmentStart = line[idx];\n    segmentEnd = line[idx + 1];\n\n    if (pointsEqual(segmentStart, segmentEnd)) {\n      intersections = [segmentStart];\n    } else {\n      segmentStartDistance = getDistance(point, segmentStart);\n      segmentEndDistance = getDistance(point, segmentEnd);\n      minDistance = min(segmentStartDistance, segmentEndDistance);\n      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\n    }\n\n    if (intersections.length < 1) {\n      throw new Error('expected between [1, 2] circle -> line intersections');\n    } // one intersection -> bendpoint attachment\n\n\n    if (intersections.length === 1) {\n      attachment = {\n        type: 'bendpoint',\n        position: intersections[0],\n        segmentIndex: idx,\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\n      };\n    } // two intersections -> segment attachment\n\n\n    if (intersections.length === 2) {\n      attachmentPosition = mid(intersections[0], intersections[1]);\n      attachment = {\n        type: 'segment',\n        position: attachmentPosition,\n        segmentIndex: idx,\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\n      };\n    }\n\n    attachmentDistance = getDistance(attachment.position, point);\n\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\n      closestAttachment = attachment;\n      closestAttachmentDistance = attachmentDistance;\n    }\n  }\n\n  return closestAttachment;\n}\n/**\n * Gets the intersection between a circle and a line segment.\n *\n * @param {Point} s1 segment start\n * @param {Point} s2 segment end\n * @param {Point} cc circle center\n * @param {Number} cr circle radius\n *\n * @return {Array<Point>} intersections\n */\n\nfunction getCircleSegmentIntersections(s1, s2, cc, cr) {\n  var baX = s2.x - s1.x;\n  var baY = s2.y - s1.y;\n  var caX = cc.x - s1.x;\n  var caY = cc.y - s1.y;\n  var a = baX * baX + baY * baY;\n  var bBy2 = baX * caX + baY * caY;\n  var c = caX * caX + caY * caY - cr * cr;\n  var pBy2 = bBy2 / a;\n  var q = c / a;\n  var disc = pBy2 * pBy2 - q; // check against negative value to work around\n  // negative, very close to zero results (-4e-15)\n  // being produced in some environments\n\n  if (disc < 0 && disc > -0.000001) {\n    disc = 0;\n  }\n\n  if (disc < 0) {\n    return [];\n  } // if disc == 0 ... dealt with later\n\n\n  var tmpSqrt = sqrt(disc);\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\n  var i1 = {\n    x: s1.x - baX * abScalingFactor1,\n    y: s1.y - baY * abScalingFactor1\n  };\n\n  if (disc === 0) {\n    // abScalingFactor1 == abScalingFactor2\n    return [i1];\n  }\n\n  var i2 = {\n    x: s1.x - baX * abScalingFactor2,\n    y: s1.y - baY * abScalingFactor2\n  }; // return only points on line segment\n\n  return [i1, i2].filter(function (p) {\n    return isPointInSegment(p, s1, s2);\n  });\n}\n\nfunction isPointInSegment(p, segmentStart, segmentEnd) {\n  return fenced(p.x, segmentStart.x, segmentEnd.x) && fenced(p.y, segmentStart.y, segmentEnd.y);\n}\n\nfunction fenced(n, rangeStart, rangeEnd) {\n  // use matching threshold to work around\n  // precisison errors in intersection computation\n  return n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD;\n}\n/**\n * Calculate mid of two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Point}\n */\n\n\nfunction mid(p1, p2) {\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2\n  };\n}\n\nvar EQUAL_THRESHOLD = 0.1;\n\nfunction pointsEqual(p1, p2) {\n  return abs(p1.x - p2.x) <= EQUAL_THRESHOLD && abs(p1.y - p2.y) <= EQUAL_THRESHOLD;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/modeling/behavior/util/LineAttachmentUtil.js"],"names":["sqrt","Math","min","max","abs","sq","n","pow","getDistance","p1","p2","x","y","getAttachment","point","line","idx","segmentStart","segmentEnd","segmentStartDistance","segmentEndDistance","attachmentPosition","minDistance","intersections","attachment","attachmentDistance","closestAttachmentDistance","closestAttachment","length","pointsEqual","getCircleSegmentIntersections","Error","type","position","segmentIndex","bendpointIndex","mid","relativeLocation","s1","s2","cc","cr","baX","baY","caX","caY","a","bBy2","c","pBy2","q","disc","tmpSqrt","abScalingFactor1","abScalingFactor2","i1","i2","filter","p","isPointInSegment","fenced","rangeStart","rangeEnd","EQUAL_THRESHOLD"],"mappings":"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","sourcesContent":["var sqrt = Math.sqrt,\n    min = Math.min,\n    max = Math.max,\n    abs = Math.abs;\n\n/**\n * Calculate the square (power to two) of a number.\n *\n * @param {Number} n\n *\n * @return {Number}\n */\nfunction sq(n) {\n  return Math.pow(n, 2);\n}\n\n/**\n * Get distance between two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Number}\n */\nfunction getDistance(p1, p2) {\n  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));\n}\n\n/**\n * Return the attachment of the given point on the specified line.\n *\n * The attachment is either a bendpoint (attached to the given point)\n * or segment (attached to a location on a line segment) attachment:\n *\n * ```javascript\n * var pointAttachment = {\n *   type: 'bendpoint',\n *   bendpointIndex: 3,\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n *\n * var segmentAttachment = {\n *   type: 'segment',\n *   segmentIndex: 2,\n *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)\n *   position: { x: 10, y: 10 } // the attach point on the line\n * };\n * ```\n *\n * @param {Point} point\n * @param {Array<Point>} line\n *\n * @return {Object} attachment\n */\nexport function getAttachment(point, line) {\n\n  var idx = 0,\n      segmentStart,\n      segmentEnd,\n      segmentStartDistance,\n      segmentEndDistance,\n      attachmentPosition,\n      minDistance,\n      intersections,\n      attachment,\n      attachmentDistance,\n      closestAttachmentDistance,\n      closestAttachment;\n\n  for (idx = 0; idx < line.length - 1; idx++) {\n\n    segmentStart = line[idx];\n    segmentEnd = line[idx + 1];\n\n    if (pointsEqual(segmentStart, segmentEnd)) {\n      intersections = [ segmentStart ];\n    } else {\n      segmentStartDistance = getDistance(point, segmentStart);\n      segmentEndDistance = getDistance(point, segmentEnd);\n\n      minDistance = min(segmentStartDistance, segmentEndDistance);\n\n      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);\n    }\n\n    if (intersections.length < 1) {\n      throw new Error('expected between [1, 2] circle -> line intersections');\n    }\n\n    // one intersection -> bendpoint attachment\n    if (intersections.length === 1) {\n      attachment = {\n        type: 'bendpoint',\n        position: intersections[0],\n        segmentIndex: idx,\n        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1\n      };\n    }\n\n    // two intersections -> segment attachment\n    if (intersections.length === 2) {\n\n      attachmentPosition = mid(intersections[0], intersections[1]);\n\n      attachment = {\n        type: 'segment',\n        position: attachmentPosition,\n        segmentIndex: idx,\n        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)\n      };\n    }\n\n    attachmentDistance = getDistance(attachment.position, point);\n\n    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {\n      closestAttachment = attachment;\n      closestAttachmentDistance = attachmentDistance;\n    }\n  }\n\n  return closestAttachment;\n}\n\n/**\n * Gets the intersection between a circle and a line segment.\n *\n * @param {Point} s1 segment start\n * @param {Point} s2 segment end\n * @param {Point} cc circle center\n * @param {Number} cr circle radius\n *\n * @return {Array<Point>} intersections\n */\nfunction getCircleSegmentIntersections(s1, s2, cc, cr) {\n\n  var baX = s2.x - s1.x;\n  var baY = s2.y - s1.y;\n  var caX = cc.x - s1.x;\n  var caY = cc.y - s1.y;\n\n  var a = baX * baX + baY * baY;\n  var bBy2 = baX * caX + baY * caY;\n  var c = caX * caX + caY * caY - cr * cr;\n\n  var pBy2 = bBy2 / a;\n  var q = c / a;\n\n  var disc = pBy2 * pBy2 - q;\n\n  // check against negative value to work around\n  // negative, very close to zero results (-4e-15)\n  // being produced in some environments\n  if (disc < 0 && disc > -0.000001) {\n    disc = 0;\n  }\n\n  if (disc < 0) {\n    return [];\n  }\n\n  // if disc == 0 ... dealt with later\n  var tmpSqrt = sqrt(disc);\n  var abScalingFactor1 = -pBy2 + tmpSqrt;\n  var abScalingFactor2 = -pBy2 - tmpSqrt;\n\n  var i1 = {\n    x: s1.x - baX * abScalingFactor1,\n    y: s1.y - baY * abScalingFactor1\n  };\n\n  if (disc === 0) { // abScalingFactor1 == abScalingFactor2\n    return [ i1 ];\n  }\n\n  var i2 = {\n    x: s1.x - baX * abScalingFactor2,\n    y: s1.y - baY * abScalingFactor2\n  };\n\n  // return only points on line segment\n  return [ i1, i2 ].filter(function(p) {\n    return isPointInSegment(p, s1, s2);\n  });\n}\n\n\nfunction isPointInSegment(p, segmentStart, segmentEnd) {\n  return (\n    fenced(p.x, segmentStart.x, segmentEnd.x) &&\n    fenced(p.y, segmentStart.y, segmentEnd.y)\n  );\n}\n\nfunction fenced(n, rangeStart, rangeEnd) {\n\n  // use matching threshold to work around\n  // precisison errors in intersection computation\n\n  return (\n    n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&\n    n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD\n  );\n}\n\n/**\n * Calculate mid of two points.\n *\n * @param {Point} p1\n * @param {Point} p2\n *\n * @return {Point}\n */\nfunction mid(p1, p2) {\n\n  return {\n    x: (p1.x + p2.x) / 2,\n    y: (p1.y + p2.y) / 2\n  };\n}\n\nvar EQUAL_THRESHOLD = 0.1;\n\nfunction pointsEqual(p1, p2) {\n\n  return (\n    abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&\n    abs(p1.y - p2.y) <= EQUAL_THRESHOLD\n  );\n}\n"]},"metadata":{},"sourceType":"module"}