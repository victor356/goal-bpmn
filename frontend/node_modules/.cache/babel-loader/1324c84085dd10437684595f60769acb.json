{"ast":null,"code":"import { map, forEach, isString, filter, assign } from 'min-dash';\nimport { isSimple as isSimpleType } from 'moddle/lib/types';\nimport { parseName as parseNameNs } from 'moddle/lib/ns';\nimport { hasLowerCaseAlias, serializeAsType, serializeAsProperty, DEFAULT_NS_MAP, XSI_TYPE } from './common';\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\nexport function Namespaces(parent) {\n  var prefixMap = {};\n  var uriMap = {};\n  var used = {};\n  var wellknown = [];\n  var custom = []; // API\n\n  this.byUri = function (uri) {\n    return uriMap[uri] || parent && parent.byUri(uri);\n  };\n\n  this.add = function (ns, isWellknown) {\n    uriMap[ns.uri] = ns;\n\n    if (isWellknown) {\n      wellknown.push(ns);\n    } else {\n      custom.push(ns);\n    }\n\n    this.mapPrefix(ns.prefix, ns.uri);\n  };\n\n  this.uriByPrefix = function (prefix) {\n    return prefixMap[prefix || 'xmlns'];\n  };\n\n  this.mapPrefix = function (prefix, uri) {\n    prefixMap[prefix || 'xmlns'] = uri;\n  };\n\n  this.logUsed = function (ns) {\n    var uri = ns.uri;\n    used[uri] = this.byUri(uri);\n  };\n\n  this.getUsed = function (ns) {\n    function isUsed(ns) {\n      return used[ns.uri];\n    }\n\n    var allNs = [].concat(wellknown, custom);\n    return allNs.filter(isUsed);\n  };\n}\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n  return map(namespaces.getUsed(), function (ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return {\n      name: name,\n      value: ns.uri\n    };\n  });\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({\n      localName: descriptor.ns.localName\n    }, ns);\n  } else {\n    return assign({\n      localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)\n    }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return assign({\n    localName: descriptor.ns.localName\n  }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n  return filter(descriptor.properties, function (p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    } // do not serialize defaults\n\n\n    if (!element.hasOwnProperty(name)) {\n      return false;\n    }\n\n    var value = element[name]; // do not serialize default equals\n\n    if (value === p.default) {\n      return false;\n    } // do not serialize null properties\n\n\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\n\nfunction escape(str, charPattern, replaceMap) {\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n  return str.replace(charPattern, function (s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\n\n\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\n\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\n\nfunction filterAttributes(props) {\n  return filter(props, function (p) {\n    return p.isAttr;\n  });\n}\n\nfunction filterContained(props) {\n  return filter(props, function (p) {\n    return !p.isAttr;\n  });\n}\n\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\n\nReferenceSerializer.prototype.build = function (element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {\n  writer.append(this.escape ? escapeBody(this.value) : this.value);\n};\n\nBodySerializer.prototype.build = function (prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>');\n  this.serializeValue(writer);\n  writer.append('</' + this.tagName + '>').appendNewLine();\n};\n\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\n\nElementSerializer.prototype.build = function (element) {\n  this.element = element;\n  var elementDescriptor = element.$descriptor,\n      propertyDescriptor = this.propertyDescriptor;\n  var otherAttrs, properties;\n  var isGeneric = elementDescriptor.isGeneric;\n\n  if (isGeneric) {\n    otherAttrs = this.parseGeneric(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  } // compute tag name\n\n\n  this.tagName = this.addTagName(this.ns);\n\n  if (!isGeneric) {\n    properties = getSerializableProperties(element);\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n\n  this.parseGenericAttributes(element, otherAttrs);\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === this.ns.uri;\n};\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\n\n\nElementSerializer.prototype.nsAttributeName = function (element) {\n  var ns;\n\n  if (isString(element)) {\n    ns = parseNameNs(element);\n  } else {\n    ns = element.ns;\n  } // return just local name for inherited attributes\n\n\n  if (element.inherited) {\n    return {\n      localName: ns.localName\n    };\n  } // parse + log effective ns\n\n\n  var effectiveNs = this.logNamespaceUsed(ns); // LOG ACTUAL namespace use\n\n  this.getNamespaces().logUsed(effectiveNs); // strip prefix if same namespace like parent\n\n  if (this.isLocalNs(effectiveNs)) {\n    return {\n      localName: ns.localName\n    };\n  } else {\n    return assign({\n      localName: ns.localName\n    }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGeneric = function (element) {\n  var self = this,\n      body = this.body;\n  var attributes = [];\n  forEach(element, function (val, key) {\n    var nonNsAttr;\n\n    if (key === '$body') {\n      body.push(new BodySerializer().build({\n        type: 'String'\n      }, val));\n    } else if (key === '$children') {\n      forEach(val, function (child) {\n        body.push(new ElementSerializer(self).build(child));\n      });\n    } else if (key.indexOf('$') !== 0) {\n      nonNsAttr = self.parseNsAttribute(element, key, val);\n\n      if (nonNsAttr) {\n        attributes.push({\n          name: key,\n          value: val\n        });\n      }\n    }\n  });\n  return attributes;\n};\n\nElementSerializer.prototype.parseNsAttribute = function (element, name, value) {\n  var model = element.$model;\n  var nameNs = parseNameNs(name);\n  var ns; // parse xmlns:foo=\"http://foo.bar\"\n\n  if (nameNs.prefix === 'xmlns') {\n    ns = {\n      prefix: nameNs.localName,\n      uri: value\n    };\n  } // parse xmlns=\"http://foo.bar\"\n\n\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = {\n      uri: value\n    };\n  }\n\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  if (model && model.getPackage(value)) {\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\n\n\nElementSerializer.prototype.parseNsAttributes = function (element, attrs) {\n  var self = this;\n  var genericAttrs = element.$attrs;\n  var attributes = []; // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n\n  forEach(genericAttrs, function (value, name) {\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {\n  var self = this;\n  forEach(attributes, function (attr) {\n    // do not serialize xsi:type attribute\n    // it is set manually based on the actual implementation type\n    if (attr.name === XSI_TYPE) {\n      return;\n    }\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      console.warn('missing namespace information for ', attr.name, '=', attr.value, 'on', element, e);\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function (properties) {\n  var self = this,\n      body = this.body,\n      element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    if (!isMany) {\n      value = [value];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if (isSimpleType(p.type)) {\n      forEach(value, function (v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      forEach(value, function (v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n      // allow serialization via type\n      // rather than element name\n      var asType = serializeAsType(p),\n          asProperty = serializeAsProperty(p);\n      forEach(value, function (v) {\n        var serializer;\n\n        if (asType) {\n          serializer = new TypeSerializer(self, p);\n        } else if (asProperty) {\n          serializer = new ElementSerializer(self, p);\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function (local) {\n  var namespaces = this.namespaces,\n      parent = this.parent,\n      parentNamespaces;\n\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function (ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n  var nsUri = ns.uri,\n      nsPrefix = ns.prefix;\n  var existing = namespaces.byUri(nsUri);\n\n  if (!existing) {\n    namespaces.add(ns, wellknown);\n  }\n\n  namespaces.mapPrefix(nsPrefix, nsUri);\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function (ns, local) {\n  var element = this.element,\n      model = element.$model,\n      namespaces = this.getNamespaces(local); // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n      uri = ns.uri,\n      newPrefix,\n      idx,\n      wellknownUri; // handle anonymous namespaces (elementForm=unqualified), cf. #23\n\n  if (!prefix && !uri) {\n    return {\n      localName: ns.localName\n    };\n  }\n\n  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n\n  ns = namespaces.byUri(uri);\n\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1; // find a prefix that is not mapped yet\n\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n\n    ns = this.logNamespace({\n      prefix: newPrefix,\n      uri: uri\n    }, wellknownUri === uri);\n  }\n\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function (properties) {\n  var self = this,\n      element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        forEach(value, function (v) {\n          values.push(v.id);\n        }); // IDREFS is a whitespace-separated list of references.\n\n        value = values.join(' ');\n      }\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addTagName = function (nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n  this.getNamespaces().logUsed(actualNs);\n  return nsName(nsTagName);\n};\n\nElementSerializer.prototype.addAttribute = function (name, value) {\n  var attrs = this.attrs;\n\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  attrs.push({\n    name: name,\n    value: value\n  });\n};\n\nElementSerializer.prototype.serializeAttributes = function (writer) {\n  var attrs = this.attrs,\n      namespaces = this.namespaces;\n\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n\n  forEach(attrs, function (a) {\n    writer.append(' ').append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function (writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n  writer.appendIndent().append('<' + this.tagName);\n  this.serializeAttributes(writer);\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n    if (indent) {\n      writer.appendNewLine().indent();\n    }\n\n    forEach(this.body, function (b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer.unindent().appendIndent();\n    }\n\n    writer.append('</' + this.tagName + '>');\n  }\n\n  writer.appendNewLine();\n};\n/**\n * A serializer for types that handles serialization of data types\n */\n\n\nfunction TypeSerializer(parent, propertyDescriptor) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.parseNsAttributes = function (element) {\n  // extracted attributes\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);\n  var descriptor = element.$descriptor; // only serialize xsi:type if necessary\n\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs); // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = pkg.xml && pkg.xml.typePrefix || '';\n  this.addAttribute(this.nsAttributeName(XSI_TYPE), (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName);\n  return attributes;\n};\n\nTypeSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function (str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n  var indent = [''];\n\n  this.append = function (str) {\n    out.write(str);\n    return this;\n  };\n\n  this.appendNewLine = function () {\n    if (format) {\n      out.write('\\n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function () {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function () {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function () {\n    indent.pop();\n    return this;\n  };\n}\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\n\n\nexport function Writer(options) {\n  options = assign({\n    format: false,\n    preamble: true\n  }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/moddle-xml/lib/write.js"],"names":["map","forEach","isString","filter","assign","isSimple","isSimpleType","parseName","parseNameNs","hasLowerCaseAlias","serializeAsType","serializeAsProperty","DEFAULT_NS_MAP","XSI_TYPE","XML_PREAMBLE","ESCAPE_ATTR_CHARS","ESCAPE_CHARS","Namespaces","parent","prefixMap","uriMap","used","wellknown","custom","byUri","uri","add","ns","isWellknown","push","mapPrefix","prefix","uriByPrefix","logUsed","getUsed","isUsed","allNs","concat","lower","string","charAt","toLowerCase","slice","nameToAlias","name","pkg","inherits","ctor","superCtor","super_","prototype","Object","create","constructor","value","enumerable","writable","configurable","nsName","localName","getNsAttrs","namespaces","getElementNs","descriptor","isGeneric","$pkg","getPropertyNs","getSerializableProperties","element","$descriptor","properties","p","isVirtual","hasOwnProperty","default","isMany","length","ESCAPE_ATTR_MAP","ESCAPE_MAP","escape","str","charPattern","replaceMap","replace","s","escapeAttr","escapeBody","filterAttributes","props","isAttr","filterContained","ReferenceSerializer","tagName","build","serializeTo","writer","appendIndent","append","id","appendNewLine","BodySerializer","serializeValue","prop","type","search","ValueSerializer","ElementSerializer","propertyDescriptor","body","attrs","elementDescriptor","otherAttrs","parseGeneric","parseNsAttributes","nsPropertyTagName","nsTagName","addTagName","parseAttributes","parseContainments","parseGenericAttributes","effectiveNs","logNamespaceUsed","isLocalNs","nsAttributeName","inherited","getNamespaces","self","attributes","val","key","nonNsAttr","child","indexOf","parseNsAttribute","model","$model","nameNs","getPackage","logNamespace","actualNs","genericAttrs","$attrs","attr","addAttribute","e","console","warn","get","isReference","isBody","v","asType","asProperty","serializer","TypeSerializer","local","parentNamespaces","nsUri","nsPrefix","existing","newPrefix","idx","wellknownUri","Error","values","join","serializeAttributes","a","firstBody","indent","b","unindent","call","typeNs","typePrefix","xml","SavingWriter","write","FormatingWriter","out","format","pop","Writer","options","preamble","toXML","tree","internalWriter","formatingWriter"],"mappings":"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","sourcesContent":["import {\n  map,\n  forEach,\n  isString,\n  filter,\n  assign\n} from 'min-dash';\n\nimport {\n  isSimple as isSimpleType\n} from 'moddle/lib/types';\n\nimport {\n  parseName as parseNameNs\n} from 'moddle/lib/ns';\n\nimport {\n  hasLowerCaseAlias,\n  serializeAsType,\n  serializeAsProperty,\n  DEFAULT_NS_MAP,\n  XSI_TYPE\n} from './common';\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS =  /<|>|&/g;\n\n\nexport function Namespaces(parent) {\n\n  var prefixMap = {};\n  var uriMap = {};\n  var used = {};\n\n  var wellknown = [];\n  var custom = [];\n\n  // API\n\n  this.byUri = function(uri) {\n    return uriMap[uri] || (\n      parent && parent.byUri(uri)\n    );\n  };\n\n  this.add = function(ns, isWellknown) {\n\n    uriMap[ns.uri] = ns;\n\n    if (isWellknown) {\n      wellknown.push(ns);\n    } else {\n      custom.push(ns);\n    }\n\n    this.mapPrefix(ns.prefix, ns.uri);\n  };\n\n  this.uriByPrefix = function(prefix) {\n    return prefixMap[prefix || 'xmlns'];\n  };\n\n  this.mapPrefix = function(prefix, uri) {\n    prefixMap[prefix || 'xmlns'] = uri;\n  };\n\n  this.logUsed = function(ns) {\n    var uri = ns.uri;\n\n    used[uri] = this.byUri(uri);\n  };\n\n  this.getUsed = function(ns) {\n\n    function isUsed(ns) {\n      return used[ns.uri];\n    }\n\n    var allNs = [].concat(wellknown, custom);\n\n    return allNs.filter(isUsed);\n  };\n\n}\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n\n  return map(namespaces.getUsed(), function(ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return { name: name, value: ns.uri };\n  });\n\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({ localName: descriptor.ns.localName }, ns);\n  } else {\n    return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return assign({ localName: descriptor.ns.localName }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n\n  return filter(descriptor.properties, function(p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!element.hasOwnProperty(name)) {\n      return false;\n    }\n\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\n\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\n\nfunction escape(str, charPattern, replaceMap) {\n\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n\n  return str.replace(charPattern, function(s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\n\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\n\nfunction filterAttributes(props) {\n  return filter(props, function(p) { return p.isAttr; });\n}\n\nfunction filterContained(props) {\n  return filter(props, function(p) { return !p.isAttr; });\n}\n\n\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\n\nReferenceSerializer.prototype.build = function(element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function(writer) {\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue =\nBodySerializer.prototype.serializeTo = function(writer) {\n  writer.append(\n    this.escape\n      ? escapeBody(this.value)\n      : this.value\n  );\n};\n\nBodySerializer.prototype.build = function(prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function(writer) {\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>');\n\n  this.serializeValue(writer);\n\n  writer\n    .append('</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\n\nElementSerializer.prototype.build = function(element) {\n  this.element = element;\n\n  var elementDescriptor = element.$descriptor,\n      propertyDescriptor = this.propertyDescriptor;\n\n  var otherAttrs,\n      properties;\n\n  var isGeneric = elementDescriptor.isGeneric;\n\n  if (isGeneric) {\n    otherAttrs = this.parseGeneric(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n\n  if (!isGeneric) {\n    properties = getSerializableProperties(element);\n\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n\n  this.parseGenericAttributes(element, otherAttrs);\n\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function(element) {\n\n  var ns;\n\n  if (isString(element)) {\n    ns = parseNameNs(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return { localName: ns.localName };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return { localName: ns.localName };\n  } else {\n    return assign({ localName: ns.localName }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGeneric = function(element) {\n\n  var self = this,\n      body = this.body;\n\n  var attributes = [];\n\n  forEach(element, function(val, key) {\n\n    var nonNsAttr;\n\n    if (key === '$body') {\n      body.push(new BodySerializer().build({ type: 'String' }, val));\n    } else\n    if (key === '$children') {\n      forEach(val, function(child) {\n        body.push(new ElementSerializer(self).build(child));\n      });\n    } else\n    if (key.indexOf('$') !== 0) {\n      nonNsAttr = self.parseNsAttribute(element, key, val);\n\n      if (nonNsAttr) {\n        attributes.push({ name: key, value: val });\n      }\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\n  var model = element.$model;\n\n  var nameNs = parseNameNs(name);\n\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = { prefix: nameNs.localName, uri: value };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = { uri: value };\n  }\n\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  if (model && model.getPackage(value)) {\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function(element, attrs) {\n  var self = this;\n\n  var genericAttrs = element.$attrs;\n\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function(value, name) {\n\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n  var self = this;\n\n  forEach(attributes, function(attr) {\n\n    // do not serialize xsi:type attribute\n    // it is set manually based on the actual implementation type\n    if (attr.name === XSI_TYPE) {\n      return;\n    }\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      console.warn(\n        'missing namespace information for ',\n        attr.name, '=', attr.value, 'on', element,\n        e);\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function(properties) {\n\n  var self = this,\n      body = this.body,\n      element = this.element;\n\n  forEach(properties, function(p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    if (!isMany) {\n      value = [ value ];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else\n    if (isSimpleType(p.type)) {\n      forEach(value, function(v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else\n    if (isReference) {\n      forEach(value, function(v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n      // allow serialization via type\n      // rather than element name\n      var asType = serializeAsType(p),\n          asProperty = serializeAsProperty(p);\n\n      forEach(value, function(v) {\n        var serializer;\n\n        if (asType) {\n          serializer = new TypeSerializer(self, p);\n        } else\n        if (asProperty) {\n          serializer = new ElementSerializer(self, p);\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function(local) {\n\n  var namespaces = this.namespaces,\n      parent = this.parent,\n      parentNamespaces;\n\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n\n  var nsUri = ns.uri,\n      nsPrefix = ns.prefix;\n\n  var existing = namespaces.byUri(nsUri);\n\n  if (!existing) {\n    namespaces.add(ns, wellknown);\n  }\n\n  namespaces.mapPrefix(nsPrefix, nsUri);\n\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\n  var element = this.element,\n      model = element.$model,\n      namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n      uri = ns.uri,\n      newPrefix, idx,\n      wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return { localName: ns.localName };\n  }\n\n  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n\n  ns = namespaces.byUri(uri);\n\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n\n    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\n  }\n\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function(properties) {\n  var self = this,\n      element = this.element;\n\n  forEach(properties, function(p) {\n\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n\n      if (!p.isMany) {\n        value = value.id;\n      }\n      else {\n        var values = [];\n        forEach(value, function(v) {\n          values.push(v.id);\n        });\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addTagName = function(nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n\n  this.getNamespaces().logUsed(actualNs);\n\n  return nsName(nsTagName);\n};\n\nElementSerializer.prototype.addAttribute = function(name, value) {\n  var attrs = this.attrs;\n\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  attrs.push({ name: name, value: value });\n};\n\nElementSerializer.prototype.serializeAttributes = function(writer) {\n  var attrs = this.attrs,\n      namespaces = this.namespaces;\n\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n\n  forEach(attrs, function(a) {\n    writer\n      .append(' ')\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function(writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName);\n\n  this.serializeAttributes(writer);\n\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n\n    if (indent) {\n      writer\n        .appendNewLine()\n        .indent();\n    }\n\n    forEach(this.body, function(b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer\n        .unindent()\n        .appendIndent();\n    }\n\n    writer.append('</' + this.tagName + '>');\n  }\n\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, propertyDescriptor) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.parseNsAttributes = function(element) {\n\n  // extracted attributes\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);\n\n  var descriptor = element.$descriptor;\n\n  // only serialize xsi:type if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n  this.addAttribute(\n    this.nsAttributeName(XSI_TYPE),\n    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName\n  );\n\n  return attributes;\n};\n\nTypeSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function(str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n\n  var indent = [''];\n\n  this.append = function(str) {\n    out.write(str);\n\n    return this;\n  };\n\n  this.appendNewLine = function() {\n    if (format) {\n      out.write('\\n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function() {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function() {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function() {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nexport function Writer(options) {\n\n  options = assign({ format: false, preamble: true }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}"]},"metadata":{},"sourceType":"module"}