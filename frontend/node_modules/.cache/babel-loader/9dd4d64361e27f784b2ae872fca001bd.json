{"ast":null,"code":"import { isArray, find, without, assign } from 'min-dash';\nimport { getOrientation, getMid } from './LayoutUtil';\nimport { pointInRect, pointDistance, pointsAligned, pointsOnLine } from '../util/Geometry';\nvar MIN_SEGMENT_LENGTH = 20,\n    POINT_ORIENTATION_PADDING = 5;\nvar round = Math.round;\nvar INTERSECTION_THRESHOLD = 20,\n    ORIENTATION_THRESHOLD = {\n  'h:h': 20,\n  'v:v': 20,\n  'h:v': -10,\n  'v:h': -10\n};\n\nfunction needsTurn(orientation, startDirection) {\n  return !{\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /./,\n    v: /./\n  }[startDirection].test(orientation);\n}\n\nfunction canLayoutStraight(direction, targetOrientation) {\n  return {\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /left|right/,\n    v: /top|bottom/\n  }[direction].test(targetOrientation);\n}\n\nfunction getSegmentBendpoints(a, b, directions) {\n  var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);\n  var startDirection = directions.split(':')[0];\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y);\n  var segmentEnd, segmentDirections;\n  var layoutStraight = canLayoutStraight(startDirection, orientation),\n      layoutHorizontal = /h|r|l/.test(startDirection),\n      layoutTurn = false;\n  var turnNextDirections = false;\n\n  if (layoutStraight) {\n    segmentEnd = layoutHorizontal ? {\n      x: xmid,\n      y: a.y\n    } : {\n      x: a.x,\n      y: ymid\n    };\n    segmentDirections = layoutHorizontal ? 'h:h' : 'v:v';\n  } else {\n    layoutTurn = needsTurn(orientation, startDirection);\n    segmentDirections = layoutHorizontal ? 'h:v' : 'v:h';\n\n    if (layoutTurn) {\n      if (layoutHorizontal) {\n        turnNextDirections = ymid === a.y;\n        segmentEnd = {\n          x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),\n          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid\n        };\n      } else {\n        turnNextDirections = xmid === a.x;\n        segmentEnd = {\n          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,\n          y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)\n        };\n      }\n    } else {\n      segmentEnd = {\n        x: xmid,\n        y: ymid\n      };\n    }\n  }\n\n  return {\n    waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),\n    directions: segmentDirections,\n    turnNextDirections: turnNextDirections\n  };\n}\n\nfunction getStartSegment(a, b, directions) {\n  return getSegmentBendpoints(a, b, directions);\n}\n\nfunction getEndSegment(a, b, directions) {\n  var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions));\n  return {\n    waypoints: invertedSegment.waypoints.slice().reverse(),\n    directions: invertDirections(invertedSegment.directions),\n    turnNextDirections: invertedSegment.turnNextDirections\n  };\n}\n\nfunction getMidSegment(startSegment, endSegment) {\n  var startDirection = startSegment.directions.split(':')[1],\n      endDirection = endSegment.directions.split(':')[0];\n\n  if (startSegment.turnNextDirections) {\n    startDirection = startDirection == 'h' ? 'v' : 'h';\n  }\n\n  if (endSegment.turnNextDirections) {\n    endDirection = endDirection == 'h' ? 'v' : 'h';\n  }\n\n  var directions = startDirection + ':' + endDirection;\n  var bendpoints = getBendpoints(startSegment.waypoints[startSegment.waypoints.length - 1], endSegment.waypoints[0], directions);\n  return {\n    waypoints: bendpoints,\n    directions: directions\n  };\n}\n\nfunction invertDirections(directions) {\n  return directions.split(':').reverse().join(':');\n}\n/**\n * Handle simple layouts with maximum two bendpoints.\n */\n\n\nfunction getSimpleBendpoints(a, b, directions) {\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y); // one point, right or left from a\n\n  if (directions === 'h:v') {\n    return [{\n      x: b.x,\n      y: a.y\n    }];\n  } // one point, above or below a\n\n\n  if (directions === 'v:h') {\n    return [{\n      x: a.x,\n      y: b.y\n    }];\n  } // vertical segment between a and b\n\n\n  if (directions === 'h:h') {\n    return [{\n      x: xmid,\n      y: a.y\n    }, {\n      x: xmid,\n      y: b.y\n    }];\n  } // horizontal segment between a and b\n\n\n  if (directions === 'v:v') {\n    return [{\n      x: a.x,\n      y: ymid\n    }, {\n      x: b.x,\n      y: ymid\n    }];\n  }\n\n  throw new Error('invalid directions: can only handle varians of [hv]:[hv]');\n}\n/**\n * Returns the mid points for a manhattan connection between two points.\n *\n * @example h:h (horizontal:horizontal)\n *\n * [a]----[x]\n *         |\n *        [x]----[b]\n *\n * @example h:v (horizontal:vertical)\n *\n * [a]----[x]\n *         |\n *        [b]\n *\n * @example h:r (horizontal:right)\n *\n * [a]----[x]\n *         |\n *    [b]-[x]\n *\n * @param  {Point} a\n * @param  {Point} b\n * @param  {String} directions\n *\n * @return {Array<Point>}\n */\n\n\nfunction getBendpoints(a, b, directions) {\n  directions = directions || 'h:h';\n\n  if (!isValidDirections(directions)) {\n    throw new Error('unknown directions: <' + directions + '>: ' + 'must be specified as <start>:<end> ' + 'with start/end in { h,v,t,r,b,l }');\n  } // compute explicit directions, involving trbl dockings\n  // using a three segmented layouting algorithm\n\n\n  if (isExplicitDirections(directions)) {\n    var startSegment = getStartSegment(a, b, directions),\n        endSegment = getEndSegment(a, b, directions),\n        midSegment = getMidSegment(startSegment, endSegment);\n    return [].concat(startSegment.waypoints, midSegment.waypoints, endSegment.waypoints);\n  } // handle simple [hv]:[hv] cases that can be easily computed\n\n\n  return getSimpleBendpoints(a, b, directions);\n}\n/**\n * Create a connection between the two points according\n * to the manhattan layout (only horizontal and vertical) edges.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @param {String} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.\n                   A directionfor a point is either `h` (horizontal) or `v` (vertical)\n *\n * @return {Array<Point>}\n */\n\n\nexport function connectPoints(a, b, directions) {\n  var points = getBendpoints(a, b, directions);\n  points.unshift(a);\n  points.push(b);\n  return withoutRedundantPoints(points);\n}\n/**\n * Connect two rectangles using a manhattan layouted connection.\n *\n * @param {Bounds} source source rectangle\n * @param {Bounds} target target rectangle\n * @param {Point} [start] source docking\n * @param {Point} [end] target docking\n *\n * @param {Object} [hints]\n * @param {String} [hints.preserveDocking=source] preserve docking on selected side\n * @param {Array<String>} [hints.preferredLayouts]\n * @param {Point|Boolean} [hints.connectionStart] whether the start changed\n * @param {Point|Boolean} [hints.connectionEnd] whether the end changed\n *\n * @return {Array<Point>} connection points\n */\n\nexport function connectRectangles(source, target, start, end, hints) {\n  var preferredLayouts = hints && hints.preferredLayouts || [];\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\n  var orientation = getOrientation(source, target, threshold);\n  var directions = getDirections(orientation, preferredLayout);\n  start = start || getMid(source);\n  end = end || getMid(target);\n  var directionSplit = directions.split(':'); // compute actual docking points for start / end\n  // this ensures we properly layout only parts of the\n  // connection that lies in between the two rectangles\n\n  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)),\n      endDocking = getDockingPoint(end, target, directionSplit[1], orientation);\n  return connectPoints(startDocking, endDocking, directions);\n}\n/**\n * Repair the connection between two rectangles, of which one has been updated.\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} [start]\n * @param {Point} [end]\n * @param {Array<Point>} [waypoints]\n * @param {Object} [hints]\n * @param {Array<String>} [hints.preferredLayouts] list of preferred layouts\n * @param {Boolean} [hints.connectionStart]\n * @param {Boolean} [hints.connectionEnd]\n *\n * @return {Array<Point>} repaired waypoints\n */\n\nexport function repairConnection(source, target, start, end, waypoints, hints) {\n  if (isArray(start)) {\n    waypoints = start;\n    hints = end;\n    start = getMid(source);\n    end = getMid(target);\n  }\n\n  hints = assign({\n    preferredLayouts: []\n  }, hints);\n  waypoints = waypoints || [];\n  var preferredLayouts = hints.preferredLayouts,\n      preferStraight = preferredLayouts.indexOf('straight') !== -1,\n      repairedWaypoints; // just layout non-existing or simple connections\n  // attempt to render straight lines, if required\n  // attempt to layout a straight line\n\n  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  } // try to layout from end\n\n\n  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  } // try to layout from start\n\n\n  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  } // or whether nothing seems to have changed\n\n\n  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {\n    return waypoints;\n  } // simply reconnect if nothing else worked\n\n\n  return connectRectangles(source, target, start, end, hints);\n}\n\nfunction inRange(a, start, end) {\n  return a >= start && a <= end;\n}\n\nfunction isInRange(axis, a, b) {\n  var size = {\n    x: 'width',\n    y: 'height'\n  };\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\n}\n/**\n * Layout a straight connection\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} start\n * @param {Point} end\n * @param {Object} [hints]\n *\n * @return {Array<Point>|null} waypoints if straight layout worked\n */\n\n\nexport function tryLayoutStraight(source, target, start, end, hints) {\n  var axis = {},\n      primaryAxis,\n      orientation;\n  orientation = getOrientation(source, target); // only layout a straight connection if shapes are\n  // horizontally or vertically aligned\n\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\n    return null;\n  }\n\n  if (/top|bottom/.test(orientation)) {\n    primaryAxis = 'x';\n  }\n\n  if (/left|right/.test(orientation)) {\n    primaryAxis = 'y';\n  }\n\n  if (hints.preserveDocking === 'target') {\n    if (!isInRange(primaryAxis, end, source)) {\n      return null;\n    }\n\n    axis[primaryAxis] = end[primaryAxis];\n    return [{\n      x: axis.x !== undefined ? axis.x : start.x,\n      y: axis.y !== undefined ? axis.y : start.y,\n      original: {\n        x: axis.x !== undefined ? axis.x : start.x,\n        y: axis.y !== undefined ? axis.y : start.y\n      }\n    }, {\n      x: end.x,\n      y: end.y\n    }];\n  } else {\n    if (!isInRange(primaryAxis, start, target)) {\n      return null;\n    }\n\n    axis[primaryAxis] = start[primaryAxis];\n    return [{\n      x: start.x,\n      y: start.y\n    }, {\n      x: axis.x !== undefined ? axis.x : end.x,\n      y: axis.y !== undefined ? axis.y : end.y,\n      original: {\n        x: axis.x !== undefined ? axis.x : end.x,\n        y: axis.y !== undefined ? axis.y : end.y\n      }\n    }];\n  }\n}\n/**\n * Repair a connection from start.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\n\nfunction tryRepairConnectionStart(moved, other, newDocking, points) {\n  return _tryRepairConnectionSide(moved, other, newDocking, points);\n}\n/**\n * Repair a connection from end.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\n\n\nfunction tryRepairConnectionEnd(moved, other, newDocking, points) {\n  var waypoints = points.slice().reverse();\n  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);\n  return waypoints ? waypoints.reverse() : null;\n}\n/**\n * Repair a connection from one side that moved.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>} the repaired points between the two rectangles\n */\n\n\nfunction _tryRepairConnectionSide(moved, other, newDocking, points) {\n  function needsRelayout(moved, other, points) {\n    if (points.length < 3) {\n      return true;\n    }\n\n    if (points.length > 4) {\n      return false;\n    } // relayout if two points overlap\n    // this is most likely due to\n\n\n    return !!find(points, function (p, idx) {\n      var q = points[idx - 1];\n      return q && pointDistance(p, q) < 3;\n    });\n  }\n\n  function repairBendpoint(candidate, oldPeer, newPeer) {\n    var alignment = pointsAligned(oldPeer, candidate);\n\n    switch (alignment) {\n      case 'v':\n        // repair vertical alignment\n        return {\n          x: candidate.x,\n          y: newPeer.y\n        };\n\n      case 'h':\n        // repair horizontal alignment\n        return {\n          x: newPeer.x,\n          y: candidate.y\n        };\n    }\n\n    return {\n      x: candidate.x,\n      y: candidate.y\n    };\n  }\n\n  function removeOverlapping(points, a, b) {\n    var i;\n\n    for (i = points.length - 2; i !== 0; i--) {\n      // intersects (?) break, remove all bendpoints up to this one and relayout\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) || pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\n        // return sliced old connection\n        return points.slice(i);\n      }\n    }\n\n    return points;\n  } // (0) only repair what has layoutable bendpoints\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\n  //     (horizontally / vertically), relayout\n\n\n  if (needsRelayout(moved, other, points)) {\n    return null;\n  }\n\n  var oldDocking = points[0],\n      newPoints = points.slice(),\n      slicedPoints; // (2) repair only last line segment and only if it was layouted before\n\n  newPoints[0] = newDocking;\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking); // (3) if shape intersects with any bendpoint after repair,\n  //     remove all segments up to this bendpoint and repair from there\n\n  slicedPoints = removeOverlapping(newPoints, moved, other);\n\n  if (slicedPoints !== newPoints) {\n    return _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);\n  }\n\n  return newPoints;\n}\n/**\n * Returns the manhattan directions connecting two rectangles\n * with the given orientation.\n *\n * Will always return the default layout, if it is specific\n * regarding sides already (trbl).\n *\n * @example\n *\n * getDirections('top'); // -> 'v:v'\n * getDirections('intersect'); // -> 't:t'\n *\n * getDirections('top-right', 'v:h'); // -> 'v:h'\n * getDirections('top-right', 'h:h'); // -> 'h:h'\n *\n *\n * @param {String} orientation\n * @param {String} defaultLayout\n *\n * @return {String}\n */\n\n\nfunction getDirections(orientation, defaultLayout) {\n  // don't override specific trbl directions\n  if (isExplicitDirections(defaultLayout)) {\n    return defaultLayout;\n  }\n\n  switch (orientation) {\n    case 'intersect':\n      return 't:t';\n\n    case 'top':\n    case 'bottom':\n      return 'v:v';\n\n    case 'left':\n    case 'right':\n      return 'h:h';\n    // 'top-left'\n    // 'top-right'\n    // 'bottom-left'\n    // 'bottom-right'\n\n    default:\n      return defaultLayout;\n  }\n}\n\nfunction isValidDirections(directions) {\n  return directions && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions);\n}\n\nfunction isExplicitDirections(directions) {\n  return directions && /t|r|b|l/.test(directions);\n}\n\nfunction invertOrientation(orientation) {\n  return {\n    'top': 'bottom',\n    'bottom': 'top',\n    'left': 'right',\n    'right': 'left',\n    'top-left': 'bottom-right',\n    'bottom-right': 'top-left',\n    'top-right': 'bottom-left',\n    'bottom-left': 'top-right'\n  }[orientation];\n}\n\nfunction getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {\n  // ensure we end up with a specific docking direction\n  // based on the targetOrientation, if <h|v> is being passed\n  if (dockingDirection === 'h') {\n    dockingDirection = /left/.test(targetOrientation) ? 'l' : 'r';\n  }\n\n  if (dockingDirection === 'v') {\n    dockingDirection = /top/.test(targetOrientation) ? 't' : 'b';\n  }\n\n  if (dockingDirection === 't') {\n    return {\n      original: point,\n      x: point.x,\n      y: rectangle.y\n    };\n  }\n\n  if (dockingDirection === 'r') {\n    return {\n      original: point,\n      x: rectangle.x + rectangle.width,\n      y: point.y\n    };\n  }\n\n  if (dockingDirection === 'b') {\n    return {\n      original: point,\n      x: point.x,\n      y: rectangle.y + rectangle.height\n    };\n  }\n\n  if (dockingDirection === 'l') {\n    return {\n      original: point,\n      x: rectangle.x,\n      y: point.y\n    };\n  }\n\n  throw new Error('unexpected dockingDirection: <' + dockingDirection + '>');\n}\n/**\n * Return list of waypoints with redundant ones filtered out.\n *\n * @example\n *\n * Original points:\n *\n *   [x] ----- [x] ------ [x]\n *                         |\n *                        [x] ----- [x] - [x]\n *\n * Filtered:\n *\n *   [x] ---------------- [x]\n *                         |\n *                        [x] ----------- [x]\n *\n * @param  {Array<Point>} waypoints\n *\n * @return {Array<Point>}\n */\n\n\nexport function withoutRedundantPoints(waypoints) {\n  return waypoints.reduce(function (points, p, idx) {\n    var previous = points[points.length - 1],\n        next = waypoints[idx + 1];\n\n    if (!pointsOnLine(previous, next, p, 0)) {\n      points.push(p);\n    }\n\n    return points;\n  }, []);\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/layout/ManhattanLayout.js"],"names":["isArray","find","without","assign","getOrientation","getMid","pointInRect","pointDistance","pointsAligned","pointsOnLine","MIN_SEGMENT_LENGTH","POINT_ORIENTATION_PADDING","round","Math","INTERSECTION_THRESHOLD","ORIENTATION_THRESHOLD","needsTurn","orientation","startDirection","t","r","b","l","h","v","test","canLayoutStraight","direction","targetOrientation","getSegmentBendpoints","a","directions","split","xmid","x","ymid","y","segmentEnd","segmentDirections","layoutStraight","layoutHorizontal","layoutTurn","turnNextDirections","waypoints","getBendpoints","concat","getStartSegment","getEndSegment","invertedSegment","invertDirections","slice","reverse","getMidSegment","startSegment","endSegment","endDirection","bendpoints","length","join","getSimpleBendpoints","Error","isValidDirections","isExplicitDirections","midSegment","connectPoints","points","unshift","push","withoutRedundantPoints","connectRectangles","source","target","start","end","hints","preferredLayouts","preferredLayout","threshold","getDirections","directionSplit","startDocking","getDockingPoint","invertOrientation","endDocking","repairConnection","preferStraight","indexOf","repairedWaypoints","tryLayoutStraight","connectionEnd","tryRepairConnectionEnd","connectionStart","tryRepairConnectionStart","inRange","isInRange","axis","size","primaryAxis","preserveDocking","undefined","original","moved","other","newDocking","_tryRepairConnectionSide","needsRelayout","p","idx","q","repairBendpoint","candidate","oldPeer","newPeer","alignment","removeOverlapping","i","oldDocking","newPoints","slicedPoints","defaultLayout","point","rectangle","dockingDirection","width","height","reduce","previous","next"],"mappings":"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","sourcesContent":["import {\n  isArray,\n  find,\n  without,\n  assign\n} from 'min-dash';\n\nimport {\n  getOrientation,\n  getMid\n} from './LayoutUtil';\n\nimport {\n  pointInRect,\n  pointDistance,\n  pointsAligned,\n  pointsOnLine\n} from '../util/Geometry';\n\nvar MIN_SEGMENT_LENGTH = 20,\n    POINT_ORIENTATION_PADDING = 5;\n\nvar round = Math.round;\n\nvar INTERSECTION_THRESHOLD = 20,\n    ORIENTATION_THRESHOLD = {\n      'h:h': 20,\n      'v:v': 20,\n      'h:v': -10,\n      'v:h': -10\n    };\n\nfunction needsTurn(orientation, startDirection) {\n  return !{\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /./,\n    v: /./\n  }[startDirection].test(orientation);\n}\n\nfunction canLayoutStraight(direction, targetOrientation) {\n  return {\n    t: /top/,\n    r: /right/,\n    b: /bottom/,\n    l: /left/,\n    h: /left|right/,\n    v: /top|bottom/\n  }[direction].test(targetOrientation);\n}\n\nfunction getSegmentBendpoints(a, b, directions) {\n  var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);\n\n  var startDirection = directions.split(':')[0];\n\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y);\n\n  var segmentEnd, segmentDirections;\n\n  var layoutStraight = canLayoutStraight(startDirection, orientation),\n      layoutHorizontal = /h|r|l/.test(startDirection),\n      layoutTurn = false;\n\n  var turnNextDirections = false;\n\n  if (layoutStraight) {\n    segmentEnd = layoutHorizontal ? { x: xmid, y: a.y } : { x: a.x, y: ymid };\n\n    segmentDirections = layoutHorizontal ? 'h:h' : 'v:v';\n  } else {\n    layoutTurn = needsTurn(orientation, startDirection);\n\n    segmentDirections = layoutHorizontal ? 'h:v' : 'v:h';\n\n    if (layoutTurn) {\n\n      if (layoutHorizontal) {\n        turnNextDirections = ymid === a.y;\n\n        segmentEnd = {\n          x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),\n          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid\n        };\n      } else {\n        turnNextDirections = xmid === a.x;\n\n        segmentEnd = {\n          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,\n          y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)\n        };\n      }\n\n    } else {\n      segmentEnd = {\n        x: xmid,\n        y: ymid\n      };\n    }\n  }\n\n  return {\n    waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),\n    directions:  segmentDirections,\n    turnNextDirections: turnNextDirections\n  };\n}\n\nfunction getStartSegment(a, b, directions) {\n  return getSegmentBendpoints(a, b, directions);\n}\n\nfunction getEndSegment(a, b, directions) {\n  var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions));\n\n  return {\n    waypoints: invertedSegment.waypoints.slice().reverse(),\n    directions: invertDirections(invertedSegment.directions),\n    turnNextDirections: invertedSegment.turnNextDirections\n  };\n}\n\nfunction getMidSegment(startSegment, endSegment) {\n\n  var startDirection = startSegment.directions.split(':')[1],\n      endDirection = endSegment.directions.split(':')[0];\n\n  if (startSegment.turnNextDirections) {\n    startDirection = startDirection == 'h' ? 'v' : 'h';\n  }\n\n  if (endSegment.turnNextDirections) {\n    endDirection = endDirection == 'h' ? 'v' : 'h';\n  }\n\n  var directions = startDirection + ':' + endDirection;\n\n  var bendpoints = getBendpoints(\n    startSegment.waypoints[startSegment.waypoints.length - 1],\n    endSegment.waypoints[0],\n    directions\n  );\n\n  return {\n    waypoints: bendpoints,\n    directions: directions\n  };\n}\n\nfunction invertDirections(directions) {\n  return directions.split(':').reverse().join(':');\n}\n\n/**\n * Handle simple layouts with maximum two bendpoints.\n */\nfunction getSimpleBendpoints(a, b, directions) {\n\n  var xmid = round((b.x - a.x) / 2 + a.x),\n      ymid = round((b.y - a.y) / 2 + a.y);\n\n  // one point, right or left from a\n  if (directions === 'h:v') {\n    return [ { x: b.x, y: a.y } ];\n  }\n\n  // one point, above or below a\n  if (directions === 'v:h') {\n    return [ { x: a.x, y: b.y } ];\n  }\n\n  // vertical segment between a and b\n  if (directions === 'h:h') {\n    return [\n      { x: xmid, y: a.y },\n      { x: xmid, y: b.y }\n    ];\n  }\n\n  // horizontal segment between a and b\n  if (directions === 'v:v') {\n    return [\n      { x: a.x, y: ymid },\n      { x: b.x, y: ymid }\n    ];\n  }\n\n  throw new Error('invalid directions: can only handle varians of [hv]:[hv]');\n}\n\n\n/**\n * Returns the mid points for a manhattan connection between two points.\n *\n * @example h:h (horizontal:horizontal)\n *\n * [a]----[x]\n *         |\n *        [x]----[b]\n *\n * @example h:v (horizontal:vertical)\n *\n * [a]----[x]\n *         |\n *        [b]\n *\n * @example h:r (horizontal:right)\n *\n * [a]----[x]\n *         |\n *    [b]-[x]\n *\n * @param  {Point} a\n * @param  {Point} b\n * @param  {String} directions\n *\n * @return {Array<Point>}\n */\nfunction getBendpoints(a, b, directions) {\n  directions = directions || 'h:h';\n\n  if (!isValidDirections(directions)) {\n    throw new Error(\n      'unknown directions: <' + directions + '>: ' +\n      'must be specified as <start>:<end> ' +\n      'with start/end in { h,v,t,r,b,l }'\n    );\n  }\n\n  // compute explicit directions, involving trbl dockings\n  // using a three segmented layouting algorithm\n  if (isExplicitDirections(directions)) {\n    var startSegment = getStartSegment(a, b, directions),\n        endSegment = getEndSegment(a, b, directions),\n        midSegment = getMidSegment(startSegment, endSegment);\n\n    return [].concat(\n      startSegment.waypoints,\n      midSegment.waypoints,\n      endSegment.waypoints\n    );\n  }\n\n  // handle simple [hv]:[hv] cases that can be easily computed\n  return getSimpleBendpoints(a, b, directions);\n}\n\n/**\n * Create a connection between the two points according\n * to the manhattan layout (only horizontal and vertical) edges.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @param {String} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.\n                   A directionfor a point is either `h` (horizontal) or `v` (vertical)\n *\n * @return {Array<Point>}\n */\nexport function connectPoints(a, b, directions) {\n\n  var points = getBendpoints(a, b, directions);\n\n  points.unshift(a);\n  points.push(b);\n\n  return withoutRedundantPoints(points);\n}\n\n\n/**\n * Connect two rectangles using a manhattan layouted connection.\n *\n * @param {Bounds} source source rectangle\n * @param {Bounds} target target rectangle\n * @param {Point} [start] source docking\n * @param {Point} [end] target docking\n *\n * @param {Object} [hints]\n * @param {String} [hints.preserveDocking=source] preserve docking on selected side\n * @param {Array<String>} [hints.preferredLayouts]\n * @param {Point|Boolean} [hints.connectionStart] whether the start changed\n * @param {Point|Boolean} [hints.connectionEnd] whether the end changed\n *\n * @return {Array<Point>} connection points\n */\nexport function connectRectangles(source, target, start, end, hints) {\n\n  var preferredLayouts = hints && hints.preferredLayouts || [];\n\n  var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';\n\n  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;\n\n  var orientation = getOrientation(source, target, threshold);\n\n  var directions = getDirections(orientation, preferredLayout);\n\n  start = start || getMid(source);\n  end = end || getMid(target);\n\n  var directionSplit = directions.split(':');\n\n  // compute actual docking points for start / end\n  // this ensures we properly layout only parts of the\n  // connection that lies in between the two rectangles\n  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)),\n      endDocking = getDockingPoint(end, target, directionSplit[1], orientation);\n\n  return connectPoints(startDocking, endDocking, directions);\n}\n\n\n/**\n * Repair the connection between two rectangles, of which one has been updated.\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} [start]\n * @param {Point} [end]\n * @param {Array<Point>} [waypoints]\n * @param {Object} [hints]\n * @param {Array<String>} [hints.preferredLayouts] list of preferred layouts\n * @param {Boolean} [hints.connectionStart]\n * @param {Boolean} [hints.connectionEnd]\n *\n * @return {Array<Point>} repaired waypoints\n */\nexport function repairConnection(source, target, start, end, waypoints, hints) {\n\n  if (isArray(start)) {\n    waypoints = start;\n    hints = end;\n\n    start = getMid(source);\n    end = getMid(target);\n  }\n\n  hints = assign({ preferredLayouts: [] }, hints);\n  waypoints = waypoints || [];\n\n  var preferredLayouts = hints.preferredLayouts,\n      preferStraight = preferredLayouts.indexOf('straight') !== -1,\n      repairedWaypoints;\n\n  // just layout non-existing or simple connections\n  // attempt to render straight lines, if required\n\n  // attempt to layout a straight line\n  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from end\n  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // try to layout from start\n  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);\n\n  if (repairedWaypoints) {\n    return repairedWaypoints;\n  }\n\n  // or whether nothing seems to have changed\n  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {\n    return waypoints;\n  }\n\n  // simply reconnect if nothing else worked\n  return connectRectangles(source, target, start, end, hints);\n}\n\n\nfunction inRange(a, start, end) {\n  return a >= start && a <= end;\n}\n\nfunction isInRange(axis, a, b) {\n  var size = {\n    x: 'width',\n    y: 'height'\n  };\n\n  return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);\n}\n\n/**\n * Layout a straight connection\n *\n * @param {Bounds} source\n * @param {Bounds} target\n * @param {Point} start\n * @param {Point} end\n * @param {Object} [hints]\n *\n * @return {Array<Point>|null} waypoints if straight layout worked\n */\nexport function tryLayoutStraight(source, target, start, end, hints) {\n  var axis = {},\n      primaryAxis,\n      orientation;\n\n  orientation = getOrientation(source, target);\n\n  // only layout a straight connection if shapes are\n  // horizontally or vertically aligned\n  if (!/^(top|bottom|left|right)$/.test(orientation)) {\n    return null;\n  }\n\n  if (/top|bottom/.test(orientation)) {\n    primaryAxis = 'x';\n  }\n\n  if (/left|right/.test(orientation)) {\n    primaryAxis = 'y';\n  }\n\n  if (hints.preserveDocking === 'target') {\n\n    if (!isInRange(primaryAxis, end, source)) {\n      return null;\n    }\n\n    axis[primaryAxis] = end[primaryAxis];\n\n    return [\n      {\n        x: axis.x !== undefined ? axis.x : start.x,\n        y: axis.y !== undefined ? axis.y : start.y,\n        original: {\n          x: axis.x !== undefined ? axis.x : start.x,\n          y: axis.y !== undefined ? axis.y : start.y\n        }\n      },\n      {\n        x: end.x,\n        y: end.y\n      }\n    ];\n\n  } else {\n\n    if (!isInRange(primaryAxis, start, target)) {\n      return null;\n    }\n\n    axis[primaryAxis] = start[primaryAxis];\n\n    return [\n      {\n        x: start.x,\n        y: start.y\n      },\n      {\n        x: axis.x !== undefined ? axis.x : end.x,\n        y: axis.y !== undefined ? axis.y : end.y,\n        original: {\n          x: axis.x !== undefined ? axis.x : end.x,\n          y: axis.y !== undefined ? axis.y : end.y\n        }\n      }\n    ];\n  }\n\n}\n\n/**\n * Repair a connection from start.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\nfunction tryRepairConnectionStart(moved, other, newDocking, points) {\n  return _tryRepairConnectionSide(moved, other, newDocking, points);\n}\n\n/**\n * Repair a connection from end.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>|null} the repaired points between the two rectangles\n */\nfunction tryRepairConnectionEnd(moved, other, newDocking, points) {\n  var waypoints = points.slice().reverse();\n\n  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);\n\n  return waypoints ? waypoints.reverse() : null;\n}\n\n/**\n * Repair a connection from one side that moved.\n *\n * @param {Bounds} moved\n * @param {Bounds} other\n * @param {Point} newDocking\n * @param {Array<Point>} points originalPoints from moved to other\n *\n * @return {Array<Point>} the repaired points between the two rectangles\n */\nfunction _tryRepairConnectionSide(moved, other, newDocking, points) {\n\n  function needsRelayout(moved, other, points) {\n\n    if (points.length < 3) {\n      return true;\n    }\n\n    if (points.length > 4) {\n      return false;\n    }\n\n    // relayout if two points overlap\n    // this is most likely due to\n    return !!find(points, function(p, idx) {\n      var q = points[idx - 1];\n\n      return q && pointDistance(p, q) < 3;\n    });\n  }\n\n  function repairBendpoint(candidate, oldPeer, newPeer) {\n\n    var alignment = pointsAligned(oldPeer, candidate);\n\n    switch (alignment) {\n    case 'v':\n      // repair vertical alignment\n      return { x: candidate.x, y: newPeer.y };\n    case 'h':\n      // repair horizontal alignment\n      return { x: newPeer.x, y: candidate.y };\n    }\n\n    return { x: candidate.x, y: candidate. y };\n  }\n\n  function removeOverlapping(points, a, b) {\n    var i;\n\n    for (i = points.length - 2; i !== 0; i--) {\n\n      // intersects (?) break, remove all bendpoints up to this one and relayout\n      if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) ||\n          pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {\n\n        // return sliced old connection\n        return points.slice(i);\n      }\n    }\n\n    return points;\n  }\n\n\n  // (0) only repair what has layoutable bendpoints\n\n  // (1) if only one bendpoint and on shape moved onto other shapes axis\n  //     (horizontally / vertically), relayout\n\n  if (needsRelayout(moved, other, points)) {\n    return null;\n  }\n\n  var oldDocking = points[0],\n      newPoints = points.slice(),\n      slicedPoints;\n\n  // (2) repair only last line segment and only if it was layouted before\n\n  newPoints[0] = newDocking;\n  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);\n\n\n  // (3) if shape intersects with any bendpoint after repair,\n  //     remove all segments up to this bendpoint and repair from there\n\n  slicedPoints = removeOverlapping(newPoints, moved, other);\n\n  if (slicedPoints !== newPoints) {\n    return _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);\n  }\n\n  return newPoints;\n}\n\n\n/**\n * Returns the manhattan directions connecting two rectangles\n * with the given orientation.\n *\n * Will always return the default layout, if it is specific\n * regarding sides already (trbl).\n *\n * @example\n *\n * getDirections('top'); // -> 'v:v'\n * getDirections('intersect'); // -> 't:t'\n *\n * getDirections('top-right', 'v:h'); // -> 'v:h'\n * getDirections('top-right', 'h:h'); // -> 'h:h'\n *\n *\n * @param {String} orientation\n * @param {String} defaultLayout\n *\n * @return {String}\n */\nfunction getDirections(orientation, defaultLayout) {\n\n  // don't override specific trbl directions\n  if (isExplicitDirections(defaultLayout)) {\n    return defaultLayout;\n  }\n\n  switch (orientation) {\n  case 'intersect':\n    return 't:t';\n\n  case 'top':\n  case 'bottom':\n    return 'v:v';\n\n  case 'left':\n  case 'right':\n    return 'h:h';\n\n  // 'top-left'\n  // 'top-right'\n  // 'bottom-left'\n  // 'bottom-right'\n  default:\n    return defaultLayout;\n  }\n}\n\nfunction isValidDirections(directions) {\n  return directions && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions);\n}\n\nfunction isExplicitDirections(directions) {\n  return directions && /t|r|b|l/.test(directions);\n}\n\nfunction invertOrientation(orientation) {\n  return {\n    'top': 'bottom',\n    'bottom': 'top',\n    'left': 'right',\n    'right': 'left',\n    'top-left': 'bottom-right',\n    'bottom-right': 'top-left',\n    'top-right': 'bottom-left',\n    'bottom-left': 'top-right',\n  }[orientation];\n}\n\nfunction getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {\n\n  // ensure we end up with a specific docking direction\n  // based on the targetOrientation, if <h|v> is being passed\n\n  if (dockingDirection === 'h') {\n    dockingDirection = /left/.test(targetOrientation) ? 'l' : 'r';\n  }\n\n  if (dockingDirection === 'v') {\n    dockingDirection = /top/.test(targetOrientation) ? 't' : 'b';\n  }\n\n  if (dockingDirection === 't') {\n    return { original: point, x: point.x, y: rectangle.y };\n  }\n\n  if (dockingDirection === 'r') {\n    return { original: point, x: rectangle.x + rectangle.width, y: point.y };\n  }\n\n  if (dockingDirection === 'b') {\n    return { original: point, x: point.x, y: rectangle.y + rectangle.height };\n  }\n\n  if (dockingDirection === 'l') {\n    return { original: point, x: rectangle.x, y: point.y };\n  }\n\n  throw new Error('unexpected dockingDirection: <' + dockingDirection + '>');\n}\n\n\n/**\n * Return list of waypoints with redundant ones filtered out.\n *\n * @example\n *\n * Original points:\n *\n *   [x] ----- [x] ------ [x]\n *                         |\n *                        [x] ----- [x] - [x]\n *\n * Filtered:\n *\n *   [x] ---------------- [x]\n *                         |\n *                        [x] ----------- [x]\n *\n * @param  {Array<Point>} waypoints\n *\n * @return {Array<Point>}\n */\nexport function withoutRedundantPoints(waypoints) {\n  return waypoints.reduce(function(points, p, idx) {\n\n    var previous = points[points.length - 1],\n        next = waypoints[idx + 1];\n\n    if (!pointsOnLine(previous, next, p, 0)) {\n      points.push(p);\n    }\n\n    return points;\n  }, []);\n}"]},"metadata":{},"sourceType":"module"}