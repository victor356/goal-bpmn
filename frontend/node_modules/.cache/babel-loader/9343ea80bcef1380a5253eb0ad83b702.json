{"ast":null,"code":"/**\n * Computes the distance between two points\n *\n * @param  {Point}  p\n * @param  {Point}  q\n *\n * @return {Number}  distance\n */\nexport function pointDistance(a, b) {\n  if (!a || !b) {\n    return -1;\n  }\n\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\n/**\n * Returns true if the point r is on the line between p and q\n *\n * @param  {Point}  p\n * @param  {Point}  q\n * @param  {Point}  r\n * @param  {Number} [accuracy=5] accuracy for points on line check (lower is better)\n *\n * @return {Boolean}\n */\n\nexport function pointsOnLine(p, q, r, accuracy) {\n  if (typeof accuracy === 'undefined') {\n    accuracy = 5;\n  }\n\n  if (!p || !q || !r) {\n    return false;\n  }\n\n  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),\n      dist = pointDistance(p, q); // @see http://stackoverflow.com/a/907491/412190\n\n  return Math.abs(val / dist) <= accuracy;\n}\nvar ALIGNED_THRESHOLD = 2;\n/**\n * Returns whether two points are in a horizontal or vertical line.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @return {String|Boolean} returns false if the points are not\n *                          aligned or 'h|v' if they are aligned\n *                          horizontally / vertically.\n */\n\nexport function pointsAligned(a, b) {\n  if (Math.abs(a.x - b.x) <= ALIGNED_THRESHOLD) {\n    return 'h';\n  }\n\n  if (Math.abs(a.y - b.y) <= ALIGNED_THRESHOLD) {\n    return 'v';\n  }\n\n  return false;\n}\n/**\n * Returns true if the point p is inside the rectangle rect\n *\n * @param  {Point}  p\n * @param  {Rect}   rect\n * @param  {Number} tolerance\n *\n * @return {Boolean}\n */\n\nexport function pointInRect(p, rect, tolerance) {\n  tolerance = tolerance || 0;\n  return p.x > rect.x - tolerance && p.y > rect.y - tolerance && p.x < rect.x + rect.width + tolerance && p.y < rect.y + rect.height + tolerance;\n}\n/**\n * Returns a point in the middle of points p and q\n *\n * @param  {Point}  p\n * @param  {Point}  q\n *\n * @return {Point} middle point\n */\n\nexport function getMidPoint(p, q) {\n  return {\n    x: Math.round(p.x + (q.x - p.x) / 2.0),\n    y: Math.round(p.y + (q.y - p.y) / 2.0)\n  };\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/util/Geometry.js"],"names":["pointDistance","a","b","Math","sqrt","pow","x","y","pointsOnLine","p","q","r","accuracy","val","dist","abs","ALIGNED_THRESHOLD","pointsAligned","pointInRect","rect","tolerance","width","height","getMidPoint","round"],"mappings":"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","sourcesContent":["/**\n * Computes the distance between two points\n *\n * @param  {Point}  p\n * @param  {Point}  q\n *\n * @return {Number}  distance\n */\nexport function pointDistance(a, b) {\n  if (!a || !b) {\n    return -1;\n  }\n\n  return Math.sqrt(\n    Math.pow(a.x - b.x, 2) +\n    Math.pow(a.y - b.y, 2)\n  );\n}\n\n\n/**\n * Returns true if the point r is on the line between p and q\n *\n * @param  {Point}  p\n * @param  {Point}  q\n * @param  {Point}  r\n * @param  {Number} [accuracy=5] accuracy for points on line check (lower is better)\n *\n * @return {Boolean}\n */\nexport function pointsOnLine(p, q, r, accuracy) {\n\n  if (typeof accuracy === 'undefined') {\n    accuracy = 5;\n  }\n\n  if (!p || !q || !r) {\n    return false;\n  }\n\n  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),\n      dist = pointDistance(p, q);\n\n  // @see http://stackoverflow.com/a/907491/412190\n  return Math.abs(val / dist) <= accuracy;\n}\n\n\nvar ALIGNED_THRESHOLD = 2;\n\n/**\n * Returns whether two points are in a horizontal or vertical line.\n *\n * @param {Point} a\n * @param {Point} b\n *\n * @return {String|Boolean} returns false if the points are not\n *                          aligned or 'h|v' if they are aligned\n *                          horizontally / vertically.\n */\nexport function pointsAligned(a, b) {\n  if (Math.abs(a.x - b.x) <= ALIGNED_THRESHOLD) {\n    return 'h';\n  }\n\n  if (Math.abs(a.y - b.y) <= ALIGNED_THRESHOLD) {\n    return 'v';\n  }\n\n  return false;\n}\n\n\n/**\n * Returns true if the point p is inside the rectangle rect\n *\n * @param  {Point}  p\n * @param  {Rect}   rect\n * @param  {Number} tolerance\n *\n * @return {Boolean}\n */\nexport function pointInRect(p, rect, tolerance) {\n  tolerance = tolerance || 0;\n\n  return p.x > rect.x - tolerance &&\n         p.y > rect.y - tolerance &&\n         p.x < rect.x + rect.width + tolerance &&\n         p.y < rect.y + rect.height + tolerance;\n}\n\n/**\n * Returns a point in the middle of points p and q\n *\n * @param  {Point}  p\n * @param  {Point}  q\n *\n * @return {Point} middle point\n */\nexport function getMidPoint(p, q) {\n  return {\n    x: Math.round(p.x + ((q.x - p.x) / 2.0)),\n    y: Math.round(p.y + ((q.y - p.y) / 2.0))\n  };\n}\n"]},"metadata":{},"sourceType":"module"}