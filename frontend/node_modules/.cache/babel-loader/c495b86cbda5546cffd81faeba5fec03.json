{"ast":null,"code":"import { assign, forEach, pick } from 'min-dash';\nimport MoveHelper from './helper/MoveHelper';\nimport { add as collectionAdd, remove as collectionRemove } from '../../../util/Collections';\nimport { getMovedSourceAnchor, getMovedTargetAnchor } from './helper/AnchorsHelper';\n/**\n * A handler that implements reversible moving of shapes.\n */\n\nexport default function MoveShapeHandler(modeling) {\n  this._modeling = modeling;\n  this._helper = new MoveHelper(modeling);\n}\nMoveShapeHandler.$inject = ['modeling'];\n\nMoveShapeHandler.prototype.execute = function (context) {\n  var shape = context.shape,\n      delta = context.delta,\n      newParent = context.newParent || shape.parent,\n      newParentIndex = context.newParentIndex,\n      oldParent = shape.parent;\n  context.oldBounds = pick(shape, ['x', 'y', 'width', 'height']); // save old parent in context\n\n  context.oldParent = oldParent;\n  context.oldParentIndex = collectionRemove(oldParent.children, shape); // add to new parent at position\n\n  collectionAdd(newParent.children, shape, newParentIndex); // update shape parent + position\n\n  assign(shape, {\n    parent: newParent,\n    x: shape.x + delta.x,\n    y: shape.y + delta.y\n  });\n  return shape;\n};\n\nMoveShapeHandler.prototype.postExecute = function (context) {\n  var shape = context.shape,\n      delta = context.delta,\n      hints = context.hints;\n  var modeling = this._modeling;\n\n  if (hints.layout !== false) {\n    forEach(shape.incoming, function (c) {\n      modeling.layoutConnection(c, {\n        connectionEnd: getMovedTargetAnchor(c, shape, delta)\n      });\n    });\n    forEach(shape.outgoing, function (c) {\n      modeling.layoutConnection(c, {\n        connectionStart: getMovedSourceAnchor(c, shape, delta)\n      });\n    });\n  }\n\n  if (hints.recurse !== false) {\n    this.moveChildren(context);\n  }\n};\n\nMoveShapeHandler.prototype.revert = function (context) {\n  var shape = context.shape,\n      oldParent = context.oldParent,\n      oldParentIndex = context.oldParentIndex,\n      delta = context.delta; // restore previous location in old parent\n\n  collectionAdd(oldParent.children, shape, oldParentIndex); // revert to old position and parent\n\n  assign(shape, {\n    parent: oldParent,\n    x: shape.x - delta.x,\n    y: shape.y - delta.y\n  });\n  return shape;\n};\n\nMoveShapeHandler.prototype.moveChildren = function (context) {\n  var delta = context.delta,\n      shape = context.shape;\n\n  this._helper.moveRecursive(shape.children, delta, null);\n};\n\nMoveShapeHandler.prototype.getNewParent = function (context) {\n  return context.newParent || context.shape.parent;\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js"],"names":["assign","forEach","pick","MoveHelper","add","collectionAdd","remove","collectionRemove","getMovedSourceAnchor","getMovedTargetAnchor","MoveShapeHandler","modeling","_modeling","_helper","$inject","prototype","execute","context","shape","delta","newParent","parent","newParentIndex","oldParent","oldBounds","oldParentIndex","children","x","y","postExecute","hints","layout","incoming","c","layoutConnection","connectionEnd","outgoing","connectionStart","recurse","moveChildren","revert","moveRecursive","getNewParent"],"mappings":"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","sourcesContent":["import {\n  assign,\n  forEach,\n  pick\n} from 'min-dash';\n\nimport MoveHelper from './helper/MoveHelper';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from '../../../util/Collections';\n\nimport {\n  getMovedSourceAnchor,\n  getMovedTargetAnchor\n} from './helper/AnchorsHelper';\n\n\n/**\n * A handler that implements reversible moving of shapes.\n */\nexport default function MoveShapeHandler(modeling) {\n  this._modeling = modeling;\n\n  this._helper = new MoveHelper(modeling);\n}\n\nMoveShapeHandler.$inject = [ 'modeling' ];\n\n\nMoveShapeHandler.prototype.execute = function(context) {\n\n  var shape = context.shape,\n      delta = context.delta,\n      newParent = context.newParent || shape.parent,\n      newParentIndex = context.newParentIndex,\n      oldParent = shape.parent;\n\n  context.oldBounds = pick(shape, [ 'x', 'y', 'width', 'height']);\n\n  // save old parent in context\n  context.oldParent = oldParent;\n  context.oldParentIndex = collectionRemove(oldParent.children, shape);\n\n  // add to new parent at position\n  collectionAdd(newParent.children, shape, newParentIndex);\n\n  // update shape parent + position\n  assign(shape, {\n    parent: newParent,\n    x: shape.x + delta.x,\n    y: shape.y + delta.y\n  });\n\n  return shape;\n};\n\nMoveShapeHandler.prototype.postExecute = function(context) {\n\n  var shape = context.shape,\n      delta = context.delta,\n      hints = context.hints;\n\n  var modeling = this._modeling;\n\n  if (hints.layout !== false) {\n\n    forEach(shape.incoming, function(c) {\n      modeling.layoutConnection(c, {\n        connectionEnd: getMovedTargetAnchor(c, shape, delta)\n      });\n    });\n\n    forEach(shape.outgoing, function(c) {\n      modeling.layoutConnection(c, {\n        connectionStart: getMovedSourceAnchor(c, shape, delta)\n      });\n    });\n  }\n\n  if (hints.recurse !== false) {\n    this.moveChildren(context);\n  }\n};\n\nMoveShapeHandler.prototype.revert = function(context) {\n\n  var shape = context.shape,\n      oldParent = context.oldParent,\n      oldParentIndex = context.oldParentIndex,\n      delta = context.delta;\n\n  // restore previous location in old parent\n  collectionAdd(oldParent.children, shape, oldParentIndex);\n\n  // revert to old position and parent\n  assign(shape, {\n    parent: oldParent,\n    x: shape.x - delta.x,\n    y: shape.y - delta.y\n  });\n\n  return shape;\n};\n\nMoveShapeHandler.prototype.moveChildren = function(context) {\n\n  var delta = context.delta,\n      shape = context.shape;\n\n  this._helper.moveRecursive(shape.children, delta, null);\n};\n\nMoveShapeHandler.prototype.getNewParent = function(context) {\n  return context.newParent || context.shape.parent;\n};\n"]},"metadata":{},"sourceType":"module"}