{"ast":null,"code":"import { filter, forEach, sortBy } from 'min-dash';\n\nfunction last(arr) {\n  return arr && arr[arr.length - 1];\n}\n\nfunction sortTopOrMiddle(element) {\n  return element.y;\n}\n\nfunction sortLeftOrCenter(element) {\n  return element.x;\n}\n/**\n * Sorting functions for different types of alignment\n *\n * @type {Object}\n *\n * @return {Function}\n */\n\n\nvar ALIGNMENT_SORTING = {\n  left: sortLeftOrCenter,\n  center: sortLeftOrCenter,\n  right: function (element) {\n    return element.x + element.width;\n  },\n  top: sortTopOrMiddle,\n  middle: sortTopOrMiddle,\n  bottom: function (element) {\n    return element.y + element.height;\n  }\n};\nexport default function AlignElements(modeling) {\n  this._modeling = modeling;\n}\nAlignElements.$inject = ['modeling'];\n/**\n * Get the relevant \"axis\" and \"dimension\" related to the current type of alignment\n *\n * @param  {String} type left|right|center|top|bottom|middle\n *\n * @return {Object} { axis, dimension }\n */\n\nAlignElements.prototype._getOrientationDetails = function (type) {\n  var vertical = ['top', 'bottom', 'middle'],\n      axis = 'x',\n      dimension = 'width';\n\n  if (vertical.indexOf(type) !== -1) {\n    axis = 'y';\n    dimension = 'height';\n  }\n\n  return {\n    axis: axis,\n    dimension: dimension\n  };\n};\n\nAlignElements.prototype._isType = function (type, types) {\n  return types.indexOf(type) !== -1;\n};\n/**\n * Get a point on the relevant axis where elements should align to\n *\n * @param  {String} type left|right|center|top|bottom|middle\n * @param  {Array} sortedElements\n *\n * @return {Object}\n */\n\n\nAlignElements.prototype._alignmentPosition = function (type, sortedElements) {\n  var orientation = this._getOrientationDetails(type),\n      axis = orientation.axis,\n      dimension = orientation.dimension,\n      alignment = {},\n      centers = {},\n      hasSharedCenters = false,\n      centeredElements,\n      firstElement,\n      lastElement;\n\n  function getMiddleOrTop(first, last) {\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\n  }\n\n  if (this._isType(type, ['left', 'top'])) {\n    alignment[type] = sortedElements[0][axis];\n  } else if (this._isType(type, ['right', 'bottom'])) {\n    lastElement = last(sortedElements);\n    alignment[type] = lastElement[axis] + lastElement[dimension];\n  } else if (this._isType(type, ['center', 'middle'])) {\n    // check if there is a center shared by more than one shape\n    // if not, just take the middle of the range\n    forEach(sortedElements, function (element) {\n      var center = element[axis] + Math.round(element[dimension] / 2);\n\n      if (centers[center]) {\n        centers[center].elements.push(element);\n      } else {\n        centers[center] = {\n          elements: [element],\n          center: center\n        };\n      }\n    });\n    centeredElements = sortBy(centers, function (center) {\n      if (center.elements.length > 1) {\n        hasSharedCenters = true;\n      }\n\n      return center.elements.length;\n    });\n\n    if (hasSharedCenters) {\n      alignment[type] = last(centeredElements).center;\n      return alignment;\n    }\n\n    firstElement = sortedElements[0];\n    sortedElements = sortBy(sortedElements, function (element) {\n      return element[axis] + element[dimension];\n    });\n    lastElement = last(sortedElements);\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\n  }\n\n  return alignment;\n};\n/**\n * Executes the alignment of a selection of elements\n *\n * @param  {Array} elements [description]\n * @param  {String} type left|right|center|top|bottom|middle\n */\n\n\nAlignElements.prototype.trigger = function (elements, type) {\n  var modeling = this._modeling;\n  var filteredElements = filter(elements, function (element) {\n    return !(element.waypoints || element.host || element.labelTarget);\n  });\n  var sortFn = ALIGNMENT_SORTING[type];\n  var sortedElements = sortBy(filteredElements, sortFn);\n\n  var alignment = this._alignmentPosition(type, sortedElements);\n\n  modeling.alignElements(sortedElements, alignment);\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/features/align-elements/AlignElements.js"],"names":["filter","forEach","sortBy","last","arr","length","sortTopOrMiddle","element","y","sortLeftOrCenter","x","ALIGNMENT_SORTING","left","center","right","width","top","middle","bottom","height","AlignElements","modeling","_modeling","$inject","prototype","_getOrientationDetails","type","vertical","axis","dimension","indexOf","_isType","types","_alignmentPosition","sortedElements","orientation","alignment","centers","hasSharedCenters","centeredElements","firstElement","lastElement","getMiddleOrTop","first","Math","round","elements","push","trigger","filteredElements","waypoints","host","labelTarget","sortFn","alignElements"],"mappings":"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","sourcesContent":["import {\n  filter,\n  forEach,\n  sortBy\n} from 'min-dash';\n\nfunction last(arr) {\n  return arr && arr[arr.length - 1];\n}\n\nfunction sortTopOrMiddle(element) {\n  return element.y;\n}\n\nfunction sortLeftOrCenter(element) {\n  return element.x;\n}\n\n/**\n * Sorting functions for different types of alignment\n *\n * @type {Object}\n *\n * @return {Function}\n */\nvar ALIGNMENT_SORTING = {\n  left: sortLeftOrCenter,\n  center: sortLeftOrCenter,\n  right: function(element) {\n    return element.x + element.width;\n  },\n  top: sortTopOrMiddle,\n  middle: sortTopOrMiddle,\n  bottom: function(element) {\n    return element.y + element.height;\n  }\n};\n\n\nexport default function AlignElements(modeling) {\n  this._modeling = modeling;\n}\n\nAlignElements.$inject = [ 'modeling' ];\n\n\n/**\n * Get the relevant \"axis\" and \"dimension\" related to the current type of alignment\n *\n * @param  {String} type left|right|center|top|bottom|middle\n *\n * @return {Object} { axis, dimension }\n */\nAlignElements.prototype._getOrientationDetails = function(type) {\n  var vertical = [ 'top', 'bottom', 'middle' ],\n      axis = 'x',\n      dimension = 'width';\n\n  if (vertical.indexOf(type) !== -1) {\n    axis = 'y';\n    dimension = 'height';\n  }\n\n  return {\n    axis: axis,\n    dimension: dimension\n  };\n};\n\nAlignElements.prototype._isType = function(type, types) {\n  return types.indexOf(type) !== -1;\n};\n\n/**\n * Get a point on the relevant axis where elements should align to\n *\n * @param  {String} type left|right|center|top|bottom|middle\n * @param  {Array} sortedElements\n *\n * @return {Object}\n */\nAlignElements.prototype._alignmentPosition = function(type, sortedElements) {\n  var orientation = this._getOrientationDetails(type),\n      axis = orientation.axis,\n      dimension = orientation.dimension,\n      alignment = {},\n      centers = {},\n      hasSharedCenters = false,\n      centeredElements,\n      firstElement,\n      lastElement;\n\n  function getMiddleOrTop(first, last) {\n    return Math.round((first[axis] + last[axis] + last[dimension]) / 2);\n  }\n\n  if (this._isType(type, [ 'left', 'top' ])) {\n    alignment[type] = sortedElements[0][axis];\n\n  } else if (this._isType(type, [ 'right', 'bottom' ])) {\n    lastElement = last(sortedElements);\n\n    alignment[type] = lastElement[axis] + lastElement[dimension];\n\n  } else if (this._isType(type, [ 'center', 'middle' ])) {\n\n    // check if there is a center shared by more than one shape\n    // if not, just take the middle of the range\n    forEach(sortedElements, function(element) {\n      var center = element[axis] + Math.round(element[dimension] / 2);\n\n      if (centers[center]) {\n        centers[center].elements.push(element);\n      } else {\n        centers[center] = {\n          elements: [ element ],\n          center: center\n        };\n      }\n    });\n\n    centeredElements = sortBy(centers, function(center) {\n      if (center.elements.length > 1) {\n        hasSharedCenters = true;\n      }\n\n      return center.elements.length;\n    });\n\n    if (hasSharedCenters) {\n      alignment[type] = last(centeredElements).center;\n\n      return alignment;\n    }\n\n    firstElement = sortedElements[0];\n\n    sortedElements = sortBy(sortedElements, function(element) {\n      return element[axis] + element[dimension];\n    });\n\n    lastElement = last(sortedElements);\n\n    alignment[type] = getMiddleOrTop(firstElement, lastElement);\n  }\n\n  return alignment;\n};\n\n/**\n * Executes the alignment of a selection of elements\n *\n * @param  {Array} elements [description]\n * @param  {String} type left|right|center|top|bottom|middle\n */\nAlignElements.prototype.trigger = function(elements, type) {\n  var modeling = this._modeling;\n\n  var filteredElements = filter(elements, function(element) {\n    return !(element.waypoints || element.host || element.labelTarget);\n  });\n\n  var sortFn = ALIGNMENT_SORTING[type];\n\n  var sortedElements = sortBy(filteredElements, sortFn);\n\n  var alignment = this._alignmentPosition(type, sortedElements);\n\n  modeling.alignElements(sortedElements, alignment);\n};\n"]},"metadata":{},"sourceType":"module"}