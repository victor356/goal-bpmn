{"ast":null,"code":"import { pointDistance } from './Geometry';\nimport intersectPaths from 'path-intersection';\nvar round = Math.round,\n    max = Math.max;\n\nfunction circlePath(center, r) {\n  var x = center.x,\n      y = center.y;\n  return [['M', x, y], ['m', 0, -r], ['a', r, r, 0, 1, 1, 0, 2 * r], ['a', r, r, 0, 1, 1, 0, -2 * r], ['z']];\n}\n\nfunction linePath(points) {\n  var segments = [];\n  points.forEach(function (p, idx) {\n    segments.push([idx === 0 ? 'M' : 'L', p.x, p.y]);\n  });\n  return segments;\n}\n\nvar INTERSECTION_THRESHOLD = 10;\n\nfunction getBendpointIntersection(waypoints, reference) {\n  var i, w;\n\n  for (i = 0; w = waypoints[i]; i++) {\n    if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {\n      return {\n        point: waypoints[i],\n        bendpoint: true,\n        index: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getPathIntersection(waypoints, reference) {\n  var intersections = intersectPaths(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));\n  var a = intersections[0],\n      b = intersections[intersections.length - 1],\n      idx;\n\n  if (!a) {\n    // no intersection\n    return null;\n  }\n\n  if (a !== b) {\n    if (a.segment2 !== b.segment2) {\n      // we use the bendpoint in between both segments\n      // as the intersection point\n      idx = max(a.segment2, b.segment2) - 1;\n      return {\n        point: waypoints[idx],\n        bendpoint: true,\n        index: idx\n      };\n    }\n\n    return {\n      point: {\n        x: round(a.x + b.x) / 2,\n        y: round(a.y + b.y) / 2\n      },\n      index: a.segment2\n    };\n  }\n\n  return {\n    point: {\n      x: round(a.x),\n      y: round(a.y)\n    },\n    index: a.segment2\n  };\n}\n/**\n * Returns the closest point on the connection towards a given reference point.\n *\n * @param  {Array<Point>} waypoints\n * @param  {Point} reference\n *\n * @return {Object} intersection data (segment, point)\n */\n\n\nexport function getApproxIntersection(waypoints, reference) {\n  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/util/LineIntersection.js"],"names":["pointDistance","intersectPaths","round","Math","max","circlePath","center","r","x","y","linePath","points","segments","forEach","p","idx","push","INTERSECTION_THRESHOLD","getBendpointIntersection","waypoints","reference","i","w","point","bendpoint","index","getPathIntersection","intersections","a","b","length","segment2","getApproxIntersection"],"mappings":"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","sourcesContent":["import {\n  pointDistance\n} from './Geometry';\n\nimport intersectPaths from 'path-intersection';\n\nvar round = Math.round,\n    max = Math.max;\n\n\nfunction circlePath(center, r) {\n  var x = center.x,\n      y = center.y;\n\n  return [\n    ['M', x, y],\n    ['m', 0, -r],\n    ['a', r, r, 0, 1, 1, 0, 2 * r],\n    ['a', r, r, 0, 1, 1, 0, -2 * r],\n    ['z']\n  ];\n}\n\nfunction linePath(points) {\n  var segments = [];\n\n  points.forEach(function(p, idx) {\n    segments.push([ idx === 0 ? 'M' : 'L', p.x, p.y ]);\n  });\n\n  return segments;\n}\n\n\nvar INTERSECTION_THRESHOLD = 10;\n\nfunction getBendpointIntersection(waypoints, reference) {\n\n  var i, w;\n\n  for (i = 0; (w = waypoints[i]); i++) {\n\n    if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {\n      return {\n        point: waypoints[i],\n        bendpoint: true,\n        index: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getPathIntersection(waypoints, reference) {\n\n  var intersections = intersectPaths(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));\n\n  var a = intersections[0],\n      b = intersections[intersections.length - 1],\n      idx;\n\n  if (!a) {\n    // no intersection\n    return null;\n  }\n\n  if (a !== b) {\n\n    if (a.segment2 !== b.segment2) {\n      // we use the bendpoint in between both segments\n      // as the intersection point\n\n      idx = max(a.segment2, b.segment2) - 1;\n\n      return {\n        point: waypoints[idx],\n        bendpoint: true,\n        index: idx\n      };\n    }\n\n    return {\n      point: {\n        x: (round(a.x + b.x) / 2),\n        y: (round(a.y + b.y) / 2)\n      },\n      index: a.segment2\n    };\n  }\n\n  return {\n    point: {\n      x: round(a.x),\n      y: round(a.y)\n    },\n    index: a.segment2\n  };\n}\n\n/**\n * Returns the closest point on the connection towards a given reference point.\n *\n * @param  {Array<Point>} waypoints\n * @param  {Point} reference\n *\n * @return {Object} intersection data (segment, point)\n */\nexport function getApproxIntersection(waypoints, reference) {\n  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);\n}\n"]},"metadata":{},"sourceType":"module"}