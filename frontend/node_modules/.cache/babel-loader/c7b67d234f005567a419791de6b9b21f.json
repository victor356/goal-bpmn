{"ast":null,"code":"import { forEach } from 'min-dash';\n/**\n * A handler that implements reversible replacing of shapes.\n * Internally the old shape will be removed and the new shape will be added.\n *\n *\n * @class\n * @constructor\n *\n * @param {canvas} Canvas\n */\n\nexport default function ReplaceShapeHandler(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\nReplaceShapeHandler.$inject = ['modeling', 'rules']; // api //////////////////////\n\n/**\n * Replaces a shape with an replacement Element.\n *\n * The newData object should contain type, x, y.\n *\n * If possible also the incoming/outgoing connection\n * will be restored.\n *\n * @param {Object} context\n */\n\nReplaceShapeHandler.prototype.preExecute = function (context) {\n  var self = this,\n      modeling = this._modeling,\n      rules = this._rules;\n  var oldShape = context.oldShape,\n      newData = context.newData,\n      hints = context.hints,\n      newShape;\n\n  function canReconnect(type, source, target, connection) {\n    return rules.allowed(type, {\n      source: source,\n      target: target,\n      connection: connection\n    });\n  } // (1) place a new shape at the given position\n\n\n  var position = {\n    x: newData.x,\n    y: newData.y\n  };\n  newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent, hints); // (2) update the host\n\n  if (oldShape.host) {\n    modeling.updateAttachment(newShape, oldShape.host);\n  } // (3) adopt all children from the old shape\n\n\n  var children;\n\n  if (hints.moveChildren !== false) {\n    children = oldShape.children.slice();\n    modeling.moveElements(children, {\n      x: 0,\n      y: 0\n    }, newShape);\n  } // (4) reconnect connections to the new shape (where allowed)\n\n\n  var incoming = oldShape.incoming.slice(),\n      outgoing = oldShape.outgoing.slice();\n  forEach(incoming, function (connection) {\n    var waypoints = connection.waypoints,\n        docking = waypoints[waypoints.length - 1],\n        source = connection.source,\n        allowed = canReconnect('connection.reconnectEnd', source, newShape, connection);\n\n    if (allowed) {\n      self.reconnectEnd(connection, newShape, docking);\n    }\n  });\n  forEach(outgoing, function (connection) {\n    var waypoints = connection.waypoints,\n        docking = waypoints[0],\n        target = connection.target,\n        allowed = canReconnect('connection.reconnectStart', newShape, target, connection);\n\n    if (allowed) {\n      self.reconnectStart(connection, newShape, docking);\n    }\n  });\n};\n\nReplaceShapeHandler.prototype.postExecute = function (context) {\n  var modeling = this._modeling;\n  var oldShape = context.oldShape,\n      newShape = context.newShape; // if an element gets resized on replace, layout the connection again\n\n  forEach(newShape.incoming, function (c) {\n    modeling.layoutConnection(c, {\n      endChanged: true\n    });\n  });\n  forEach(newShape.outgoing, function (c) {\n    modeling.layoutConnection(c, {\n      startChanged: true\n    });\n  });\n  modeling.removeShape(oldShape);\n};\n\nReplaceShapeHandler.prototype.execute = function (context) {};\n\nReplaceShapeHandler.prototype.revert = function (context) {};\n\nReplaceShapeHandler.prototype.createShape = function (shape, position, target, hints) {\n  var modeling = this._modeling;\n  return modeling.createShape(shape, position, target, hints);\n};\n\nReplaceShapeHandler.prototype.reconnectStart = function (connection, newSource, dockingPoint) {\n  var modeling = this._modeling;\n  modeling.reconnectStart(connection, newSource, dockingPoint);\n};\n\nReplaceShapeHandler.prototype.reconnectEnd = function (connection, newTarget, dockingPoint) {\n  var modeling = this._modeling;\n  modeling.reconnectEnd(connection, newTarget, dockingPoint);\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js"],"names":["forEach","ReplaceShapeHandler","modeling","rules","_modeling","_rules","$inject","prototype","preExecute","context","self","oldShape","newData","hints","newShape","canReconnect","type","source","target","connection","allowed","position","x","y","createShape","parent","host","updateAttachment","children","moveChildren","slice","moveElements","incoming","outgoing","waypoints","docking","length","reconnectEnd","reconnectStart","postExecute","c","layoutConnection","endChanged","startChanged","removeShape","execute","revert","shape","newSource","dockingPoint","newTarget"],"mappings":"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","sourcesContent":["import { forEach } from 'min-dash';\n\n\n/**\n * A handler that implements reversible replacing of shapes.\n * Internally the old shape will be removed and the new shape will be added.\n *\n *\n * @class\n * @constructor\n *\n * @param {canvas} Canvas\n */\nexport default function ReplaceShapeHandler(modeling, rules) {\n  this._modeling = modeling;\n  this._rules = rules;\n}\n\nReplaceShapeHandler.$inject = [ 'modeling', 'rules' ];\n\n\n// api //////////////////////\n\n\n/**\n * Replaces a shape with an replacement Element.\n *\n * The newData object should contain type, x, y.\n *\n * If possible also the incoming/outgoing connection\n * will be restored.\n *\n * @param {Object} context\n */\nReplaceShapeHandler.prototype.preExecute = function(context) {\n\n  var self = this,\n      modeling = this._modeling,\n      rules = this._rules;\n\n  var oldShape = context.oldShape,\n      newData = context.newData,\n      hints = context.hints,\n      newShape;\n\n  function canReconnect(type, source, target, connection) {\n    return rules.allowed(type, {\n      source: source,\n      target: target,\n      connection: connection\n    });\n  }\n\n\n  // (1) place a new shape at the given position\n\n  var position = {\n    x: newData.x,\n    y: newData.y\n  };\n\n  newShape = context.newShape =\n    context.newShape ||\n    self.createShape(newData, position, oldShape.parent, hints);\n\n\n  // (2) update the host\n\n  if (oldShape.host) {\n    modeling.updateAttachment(newShape, oldShape.host);\n  }\n\n\n  // (3) adopt all children from the old shape\n\n  var children;\n\n  if (hints.moveChildren !== false) {\n    children = oldShape.children.slice();\n\n    modeling.moveElements(children, { x: 0, y: 0 }, newShape);\n  }\n\n  // (4) reconnect connections to the new shape (where allowed)\n\n  var incoming = oldShape.incoming.slice(),\n      outgoing = oldShape.outgoing.slice();\n\n  forEach(incoming, function(connection) {\n    var waypoints = connection.waypoints,\n        docking = waypoints[waypoints.length - 1],\n        source = connection.source,\n        allowed = canReconnect('connection.reconnectEnd', source, newShape, connection);\n\n    if (allowed) {\n      self.reconnectEnd(connection, newShape, docking);\n    }\n  });\n\n  forEach(outgoing, function(connection) {\n    var waypoints = connection.waypoints,\n        docking = waypoints[0],\n        target = connection.target,\n        allowed = canReconnect('connection.reconnectStart', newShape, target, connection);\n\n    if (allowed) {\n      self.reconnectStart(connection, newShape, docking);\n    }\n\n  });\n};\n\n\nReplaceShapeHandler.prototype.postExecute = function(context) {\n  var modeling = this._modeling;\n\n  var oldShape = context.oldShape,\n      newShape = context.newShape;\n\n  // if an element gets resized on replace, layout the connection again\n  forEach(newShape.incoming, function(c) {\n    modeling.layoutConnection(c, { endChanged: true });\n  });\n\n  forEach(newShape.outgoing, function(c) {\n    modeling.layoutConnection(c, { startChanged: true });\n  });\n\n  modeling.removeShape(oldShape);\n};\n\n\nReplaceShapeHandler.prototype.execute = function(context) {};\n\nReplaceShapeHandler.prototype.revert = function(context) {};\n\n\nReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {\n  var modeling = this._modeling;\n  return modeling.createShape(shape, position, target, hints);\n};\n\n\nReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint) {\n  var modeling = this._modeling;\n  modeling.reconnectStart(connection, newSource, dockingPoint);\n};\n\n\nReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint) {\n  var modeling = this._modeling;\n  modeling.reconnectEnd(connection, newTarget, dockingPoint);\n};\n"]},"metadata":{},"sourceType":"module"}