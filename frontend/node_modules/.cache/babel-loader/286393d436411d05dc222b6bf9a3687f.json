{"ast":null,"code":"import { assign } from 'min-dash';\nimport inherits from 'inherits';\nimport Refs from 'object-refs';\nvar parentRefs = new Refs({\n  name: 'children',\n  enumerable: true,\n  collection: true\n}, {\n  name: 'parent'\n}),\n    labelRefs = new Refs({\n  name: 'labels',\n  enumerable: true,\n  collection: true\n}, {\n  name: 'labelTarget'\n}),\n    attacherRefs = new Refs({\n  name: 'attachers',\n  collection: true\n}, {\n  name: 'host'\n}),\n    outgoingRefs = new Refs({\n  name: 'outgoing',\n  collection: true\n}, {\n  name: 'source'\n}),\n    incomingRefs = new Refs({\n  name: 'incoming',\n  collection: true\n}, {\n  name: 'target'\n});\n/**\n * @namespace djs.model\n */\n\n/**\n * @memberOf djs.model\n */\n\n/**\n * The basic graphical representation\n *\n * @class\n *\n * @abstract\n */\n\nexport function Base() {\n  /**\n   * The object that backs up the shape\n   *\n   * @name Base#businessObject\n   * @type Object\n   */\n  Object.defineProperty(this, 'businessObject', {\n    writable: true\n  });\n  /**\n   * Single label support, will mapped to multi label array\n   *\n   * @name Base#label\n   * @type Object\n   */\n\n  Object.defineProperty(this, 'label', {\n    get: function () {\n      return this.labels[0];\n    },\n    set: function (newLabel) {\n      var label = this.label,\n          labels = this.labels;\n\n      if (!newLabel && label) {\n        labels.remove(label);\n      } else {\n        labels.add(newLabel, 0);\n      }\n    }\n  });\n  /**\n   * The parent shape\n   *\n   * @name Base#parent\n   * @type Shape\n   */\n\n  parentRefs.bind(this, 'parent');\n  /**\n   * The list of labels\n   *\n   * @name Base#labels\n   * @type Label\n   */\n\n  labelRefs.bind(this, 'labels');\n  /**\n   * The list of outgoing connections\n   *\n   * @name Base#outgoing\n   * @type Array<Connection>\n   */\n\n  outgoingRefs.bind(this, 'outgoing');\n  /**\n   * The list of incoming connections\n   *\n   * @name Base#incoming\n   * @type Array<Connection>\n   */\n\n  incomingRefs.bind(this, 'incoming');\n}\n/**\n * A graphical object\n *\n * @class\n * @constructor\n *\n * @extends Base\n */\n\nexport function Shape() {\n  Base.call(this);\n  /**\n   * The list of children\n   *\n   * @name Shape#children\n   * @type Array<Base>\n   */\n\n  parentRefs.bind(this, 'children');\n  /**\n   * @name Shape#host\n   * @type Shape\n   */\n\n  attacherRefs.bind(this, 'host');\n  /**\n   * @name Shape#attachers\n   * @type Shape\n   */\n\n  attacherRefs.bind(this, 'attachers');\n}\ninherits(Shape, Base);\n/**\n * A root graphical object\n *\n * @class\n * @constructor\n *\n * @extends Shape\n */\n\nexport function Root() {\n  Shape.call(this);\n}\ninherits(Root, Shape);\n/**\n * A label for an element\n *\n * @class\n * @constructor\n *\n * @extends Shape\n */\n\nexport function Label() {\n  Shape.call(this);\n  /**\n   * The labeled element\n   *\n   * @name Label#labelTarget\n   * @type Base\n   */\n\n  labelRefs.bind(this, 'labelTarget');\n}\ninherits(Label, Shape);\n/**\n * A connection between two elements\n *\n * @class\n * @constructor\n *\n * @extends Base\n */\n\nexport function Connection() {\n  Base.call(this);\n  /**\n   * The element this connection originates from\n   *\n   * @name Connection#source\n   * @type Base\n   */\n\n  outgoingRefs.bind(this, 'source');\n  /**\n   * The element this connection points to\n   *\n   * @name Connection#target\n   * @type Base\n   */\n\n  incomingRefs.bind(this, 'target');\n}\ninherits(Connection, Base);\nvar types = {\n  connection: Connection,\n  shape: Shape,\n  label: Label,\n  root: Root\n};\n/**\n * Creates a new model element of the specified type\n *\n * @method create\n *\n * @example\n *\n * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });\n * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });\n *\n * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });\n *\n * @param  {String} type lower-cased model name\n * @param  {Object} attrs attributes to initialize the new model instance with\n *\n * @return {Base} the new model instance\n */\n\nexport function create(type, attrs) {\n  var Type = types[type];\n\n  if (!Type) {\n    throw new Error('unknown type: <' + type + '>');\n  }\n\n  return assign(new Type(), attrs);\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/model/index.js"],"names":["assign","inherits","Refs","parentRefs","name","enumerable","collection","labelRefs","attacherRefs","outgoingRefs","incomingRefs","Base","Object","defineProperty","writable","get","labels","set","newLabel","label","remove","add","bind","Shape","call","Root","Label","Connection","types","connection","shape","root","create","type","attrs","Type","Error"],"mappings":"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","sourcesContent":["import { assign } from 'min-dash';\nimport inherits from 'inherits';\n\nimport Refs from 'object-refs';\n\nvar parentRefs = new Refs({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),\n    labelRefs = new Refs({ name: 'labels', enumerable: true, collection: true }, { name: 'labelTarget' }),\n    attacherRefs = new Refs({ name: 'attachers', collection: true }, { name: 'host' }),\n    outgoingRefs = new Refs({ name: 'outgoing', collection: true }, { name: 'source' }),\n    incomingRefs = new Refs({ name: 'incoming', collection: true }, { name: 'target' });\n\n/**\n * @namespace djs.model\n */\n\n/**\n * @memberOf djs.model\n */\n\n/**\n * The basic graphical representation\n *\n * @class\n *\n * @abstract\n */\nexport function Base() {\n\n  /**\n   * The object that backs up the shape\n   *\n   * @name Base#businessObject\n   * @type Object\n   */\n  Object.defineProperty(this, 'businessObject', {\n    writable: true\n  });\n\n\n  /**\n   * Single label support, will mapped to multi label array\n   *\n   * @name Base#label\n   * @type Object\n   */\n  Object.defineProperty(this, 'label', {\n    get: function() {\n      return this.labels[0];\n    },\n    set: function(newLabel) {\n\n      var label = this.label,\n          labels = this.labels;\n\n      if (!newLabel && label) {\n        labels.remove(label);\n      } else {\n        labels.add(newLabel, 0);\n      }\n    }\n  });\n\n  /**\n   * The parent shape\n   *\n   * @name Base#parent\n   * @type Shape\n   */\n  parentRefs.bind(this, 'parent');\n\n  /**\n   * The list of labels\n   *\n   * @name Base#labels\n   * @type Label\n   */\n  labelRefs.bind(this, 'labels');\n\n  /**\n   * The list of outgoing connections\n   *\n   * @name Base#outgoing\n   * @type Array<Connection>\n   */\n  outgoingRefs.bind(this, 'outgoing');\n\n  /**\n   * The list of incoming connections\n   *\n   * @name Base#incoming\n   * @type Array<Connection>\n   */\n  incomingRefs.bind(this, 'incoming');\n}\n\n\n/**\n * A graphical object\n *\n * @class\n * @constructor\n *\n * @extends Base\n */\nexport function Shape() {\n  Base.call(this);\n\n  /**\n   * The list of children\n   *\n   * @name Shape#children\n   * @type Array<Base>\n   */\n  parentRefs.bind(this, 'children');\n\n  /**\n   * @name Shape#host\n   * @type Shape\n   */\n  attacherRefs.bind(this, 'host');\n\n  /**\n   * @name Shape#attachers\n   * @type Shape\n   */\n  attacherRefs.bind(this, 'attachers');\n}\n\ninherits(Shape, Base);\n\n\n/**\n * A root graphical object\n *\n * @class\n * @constructor\n *\n * @extends Shape\n */\nexport function Root() {\n  Shape.call(this);\n}\n\ninherits(Root, Shape);\n\n\n/**\n * A label for an element\n *\n * @class\n * @constructor\n *\n * @extends Shape\n */\nexport function Label() {\n  Shape.call(this);\n\n  /**\n   * The labeled element\n   *\n   * @name Label#labelTarget\n   * @type Base\n   */\n  labelRefs.bind(this, 'labelTarget');\n}\n\ninherits(Label, Shape);\n\n\n/**\n * A connection between two elements\n *\n * @class\n * @constructor\n *\n * @extends Base\n */\nexport function Connection() {\n  Base.call(this);\n\n  /**\n   * The element this connection originates from\n   *\n   * @name Connection#source\n   * @type Base\n   */\n  outgoingRefs.bind(this, 'source');\n\n  /**\n   * The element this connection points to\n   *\n   * @name Connection#target\n   * @type Base\n   */\n  incomingRefs.bind(this, 'target');\n}\n\ninherits(Connection, Base);\n\n\nvar types = {\n  connection: Connection,\n  shape: Shape,\n  label: Label,\n  root: Root\n};\n\n/**\n * Creates a new model element of the specified type\n *\n * @method create\n *\n * @example\n *\n * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });\n * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });\n *\n * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });\n *\n * @param  {String} type lower-cased model name\n * @param  {Object} attrs attributes to initialize the new model instance with\n *\n * @return {Base} the new model instance\n */\nexport function create(type, attrs) {\n  var Type = types[type];\n  if (!Type) {\n    throw new Error('unknown type: <' + type + '>');\n  }\n  return assign(new Type(), attrs);\n}"]},"metadata":{},"sourceType":"module"}