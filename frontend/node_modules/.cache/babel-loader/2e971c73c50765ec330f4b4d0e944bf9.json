{"ast":null,"code":"import { assign, forEach, isArray } from 'min-dash';\nvar abs = Math.abs,\n    round = Math.round;\nvar TOLERANCE = 10;\nexport default function BendpointSnapping(eventBus) {\n  function snapTo(values, value) {\n    if (isArray(values)) {\n      var i = values.length;\n\n      while (i--) if (abs(values[i] - value) <= TOLERANCE) {\n        return values[i];\n      }\n    } else {\n      values = +values;\n      var rem = value % values;\n\n      if (rem < TOLERANCE) {\n        return value - rem;\n      }\n\n      if (rem > values - TOLERANCE) {\n        return value - rem + values;\n      }\n    }\n\n    return value;\n  }\n\n  function mid(element) {\n    if (element.width) {\n      return {\n        x: round(element.width / 2 + element.x),\n        y: round(element.height / 2 + element.y)\n      };\n    }\n  } // connection segment snapping //////////////////////\n\n\n  function getConnectionSegmentSnaps(context) {\n    var snapPoints = context.snapPoints,\n        connection = context.connection,\n        waypoints = connection.waypoints,\n        segmentStart = context.segmentStart,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEnd = context.segmentEnd,\n        segmentEndIndex = context.segmentEndIndex,\n        axis = context.axis;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [waypoints[segmentStartIndex - 1], segmentStart, segmentEnd, waypoints[segmentEndIndex + 1]];\n\n    if (segmentStartIndex < 2) {\n      referenceWaypoints.unshift(mid(connection.source));\n    }\n\n    if (segmentEndIndex > waypoints.length - 3) {\n      referenceWaypoints.unshift(mid(connection.target));\n    }\n\n    context.snapPoints = snapPoints = {\n      horizontal: [],\n      vertical: []\n    };\n    forEach(referenceWaypoints, function (p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        if (axis === 'y') {\n          snapPoints.horizontal.push(p.y);\n        }\n\n        if (axis === 'x') {\n          snapPoints.vertical.push(p.x);\n        }\n      }\n    });\n    return snapPoints;\n  }\n\n  eventBus.on('connectionSegment.move.move', 1500, function (event) {\n    var context = event.context,\n        snapPoints = getConnectionSegmentSnaps(context),\n        x = event.x,\n        y = event.y,\n        sx,\n        sy;\n\n    if (!snapPoints) {\n      return;\n    } // snap\n\n\n    sx = snapTo(snapPoints.vertical, x);\n    sy = snapTo(snapPoints.horizontal, y); // correction x/y\n\n    var cx = x - sx,\n        cy = y - sy; // update delta\n\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: sx,\n      y: sy\n    });\n  }); // bendpoint snapping //////////////////////\n\n  function getBendpointSnaps(context) {\n    var snapPoints = context.snapPoints,\n        waypoints = context.connection.waypoints,\n        bendpointIndex = context.bendpointIndex;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];\n    context.snapPoints = snapPoints = {\n      horizontal: [],\n      vertical: []\n    };\n    forEach(referenceWaypoints, function (p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n        snapPoints.horizontal.push(p.y);\n        snapPoints.vertical.push(p.x);\n      }\n    });\n    return snapPoints;\n  }\n\n  eventBus.on('bendpoint.move.move', 1500, function (event) {\n    var context = event.context,\n        snapPoints = getBendpointSnaps(context),\n        target = context.target,\n        targetMid = target && mid(target),\n        x = event.x,\n        y = event.y,\n        sx,\n        sy;\n\n    if (!snapPoints) {\n      return;\n    } // snap\n\n\n    sx = snapTo(targetMid ? snapPoints.vertical.concat([targetMid.x]) : snapPoints.vertical, x);\n    sy = snapTo(targetMid ? snapPoints.horizontal.concat([targetMid.y]) : snapPoints.horizontal, y); // correction x/y\n\n    var cx = x - sx,\n        cy = y - sy; // update delta\n\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: event.x - cx,\n      y: event.y - cy\n    });\n  });\n}\nBendpointSnapping.$inject = ['eventBus'];","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js"],"names":["assign","forEach","isArray","abs","Math","round","TOLERANCE","BendpointSnapping","eventBus","snapTo","values","value","i","length","rem","mid","element","width","x","y","height","getConnectionSegmentSnaps","context","snapPoints","connection","waypoints","segmentStart","segmentStartIndex","segmentEnd","segmentEndIndex","axis","referenceWaypoints","unshift","source","target","horizontal","vertical","p","original","push","on","event","sx","sy","cx","cy","dx","dy","getBendpointSnaps","bendpointIndex","targetMid","concat","$inject"],"mappings":"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","sourcesContent":["import {\n  assign,\n  forEach,\n  isArray\n} from 'min-dash';\n\nvar abs= Math.abs,\n    round = Math.round;\n\nvar TOLERANCE = 10;\n\n\nexport default function BendpointSnapping(eventBus) {\n\n  function snapTo(values, value) {\n\n    if (isArray(values)) {\n      var i = values.length;\n\n      while (i--) if (abs(values[i] - value) <= TOLERANCE) {\n        return values[i];\n      }\n    } else {\n      values = +values;\n      var rem = value % values;\n\n      if (rem < TOLERANCE) {\n        return value - rem;\n      }\n\n      if (rem > values - TOLERANCE) {\n        return value - rem + values;\n      }\n    }\n\n    return value;\n  }\n\n  function mid(element) {\n    if (element.width) {\n      return {\n        x: round(element.width / 2 + element.x),\n        y: round(element.height / 2 + element.y)\n      };\n    }\n  }\n\n  // connection segment snapping //////////////////////\n\n  function getConnectionSegmentSnaps(context) {\n\n    var snapPoints = context.snapPoints,\n        connection = context.connection,\n        waypoints = connection.waypoints,\n        segmentStart = context.segmentStart,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEnd = context.segmentEnd,\n        segmentEndIndex = context.segmentEndIndex,\n        axis = context.axis;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [\n      waypoints[segmentStartIndex - 1],\n      segmentStart,\n      segmentEnd,\n      waypoints[segmentEndIndex + 1]\n    ];\n\n    if (segmentStartIndex < 2) {\n      referenceWaypoints.unshift(mid(connection.source));\n    }\n\n    if (segmentEndIndex > waypoints.length - 3) {\n      referenceWaypoints.unshift(mid(connection.target));\n    }\n\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\n\n    forEach(referenceWaypoints, function(p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        if (axis === 'y') {\n          snapPoints.horizontal.push(p.y);\n        }\n\n        if (axis === 'x') {\n          snapPoints.vertical.push(p.x);\n        }\n      }\n    });\n\n    return snapPoints;\n  }\n\n  eventBus.on('connectionSegment.move.move', 1500, function(event) {\n    var context = event.context,\n        snapPoints = getConnectionSegmentSnaps(context),\n        x = event.x,\n        y = event.y,\n        sx, sy;\n\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap\n    sx = snapTo(snapPoints.vertical, x);\n    sy = snapTo(snapPoints.horizontal, y);\n\n\n    // correction x/y\n    var cx = (x - sx),\n        cy = (y - sy);\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: sx,\n      y: sy\n    });\n  });\n\n\n  // bendpoint snapping //////////////////////\n\n  function getBendpointSnaps(context) {\n\n    var snapPoints = context.snapPoints,\n        waypoints = context.connection.waypoints,\n        bendpointIndex = context.bendpointIndex;\n\n    if (snapPoints) {\n      return snapPoints;\n    }\n\n    var referenceWaypoints = [ waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1] ];\n\n    context.snapPoints = snapPoints = { horizontal: [] , vertical: [] };\n\n    forEach(referenceWaypoints, function(p) {\n      // we snap on existing bendpoints only,\n      // not placeholders that are inserted during add\n      if (p) {\n        p = p.original || p;\n\n        snapPoints.horizontal.push(p.y);\n        snapPoints.vertical.push(p.x);\n      }\n    });\n\n    return snapPoints;\n  }\n\n\n  eventBus.on('bendpoint.move.move', 1500, function(event) {\n\n    var context = event.context,\n        snapPoints = getBendpointSnaps(context),\n        target = context.target,\n        targetMid = target && mid(target),\n        x = event.x,\n        y = event.y,\n        sx, sy;\n\n    if (!snapPoints) {\n      return;\n    }\n\n    // snap\n    sx = snapTo(targetMid ? snapPoints.vertical.concat([ targetMid.x ]) : snapPoints.vertical, x);\n    sy = snapTo(targetMid ? snapPoints.horizontal.concat([ targetMid.y ]) : snapPoints.horizontal, y);\n\n\n    // correction x/y\n    var cx = (x - sx),\n        cy = (y - sy);\n\n    // update delta\n    assign(event, {\n      dx: event.dx - cx,\n      dy: event.dy - cy,\n      x: event.x - cx,\n      y: event.y - cy\n    });\n  });\n}\n\n\nBendpointSnapping.$inject = [ 'eventBus' ];"]},"metadata":{},"sourceType":"module"}