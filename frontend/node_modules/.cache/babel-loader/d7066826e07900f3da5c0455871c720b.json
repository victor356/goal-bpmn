{"ast":null,"code":"import { pointsAligned, pointsOnLine } from '../../util/Geometry';\nimport { addSegmentDragger } from './BendpointUtil';\nimport { getMid, getOrientation } from '../../layout/LayoutUtil';\nvar MARKER_CONNECT_HOVER = 'connect-hover',\n    MARKER_CONNECT_UPDATING = 'djs-updating';\nimport { classes as svgClasses, remove as svgRemove } from 'tiny-svg';\nimport { translate } from '../../util/SvgTransformUtil';\n\nfunction axisAdd(point, axis, delta) {\n  return axisSet(point, axis, point[axis] + delta);\n}\n\nfunction axisSet(point, axis, value) {\n  return {\n    x: axis === 'x' ? value : point.x,\n    y: axis === 'y' ? value : point.y\n  };\n}\n\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\n      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\n  var padding = 20;\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\n  return axisSet(segmentStart, axis, fencedValue);\n}\n\nfunction flipAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n/**\n * Get the docking point on the given element.\n *\n * Compute a reasonable docking, if non exists.\n *\n * @param  {Point} point\n * @param  {djs.model.Shape} referenceElement\n * @param  {String} moveAxis (x|y)\n *\n * @return {Point}\n */\n\n\nfunction getDocking(point, referenceElement, moveAxis) {\n  var referenceMid, inverseAxis;\n\n  if (point.original) {\n    return point.original;\n  } else {\n    referenceMid = getMid(referenceElement);\n    inverseAxis = flipAxis(moveAxis);\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\n  }\n}\n/**\n * A component that implements moving of bendpoints\n */\n\n\nexport default function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false); // API\n\n  this.start = function (event, connection, idx) {\n    var context,\n        gfx = canvas.getGraphics(connection),\n        segmentStartIndex = idx - 1,\n        segmentEndIndex = idx,\n        waypoints = connection.waypoints,\n        segmentStart = waypoints[segmentStartIndex],\n        segmentEnd = waypoints[segmentEndIndex],\n        direction,\n        axis;\n    direction = pointsAligned(segmentStart, segmentEnd); // do not move diagonal connection\n\n    if (!direction) {\n      return;\n    } // the axis where we are going to move things\n\n\n    axis = direction === 'v' ? 'y' : 'x';\n\n    if (segmentStartIndex === 0) {\n      segmentStart = getDocking(segmentStart, connection.source, axis);\n    }\n\n    if (segmentEndIndex === waypoints.length - 1) {\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\n    }\n\n    context = {\n      connection: connection,\n      segmentStartIndex: segmentStartIndex,\n      segmentEndIndex: segmentEndIndex,\n      segmentStart: segmentStart,\n      segmentEnd: segmentEnd,\n      axis: axis\n    };\n    dragging.init(event, {\n      x: (segmentStart.x + segmentEnd.x) / 2,\n      y: (segmentStart.y + segmentEnd.y) / 2\n    }, 'connectionSegment.move', {\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n  /**\n   * Crop connection if connection cropping is provided.\n   *\n   * @param {Connection} connection\n   * @param {Array<Point>} newWaypoints\n   *\n   * @return {Array<Point>} cropped connection waypoints\n   */\n\n\n  function cropConnection(connection, newWaypoints) {\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n\n    var oldWaypoints = connection.waypoints,\n        croppedWaypoints; // temporary set new waypoints\n\n    connection.waypoints = newWaypoints;\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection); // restore old waypoints\n\n    connection.waypoints = oldWaypoints;\n    return croppedWaypoints;\n  } // DRAGGING IMPLEMENTATION\n\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n\n  function updateDragger(context, segmentOffset, event) {\n    var newWaypoints = context.newWaypoints,\n        segmentStartIndex = context.segmentStartIndex + segmentOffset,\n        segmentStart = newWaypoints[segmentStartIndex],\n        segmentEndIndex = context.segmentEndIndex + segmentOffset,\n        segmentEnd = newWaypoints[segmentEndIndex],\n        axis = flipAxis(context.axis); // make sure the dragger does not move\n    // outside the connection\n\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis); // update dragger\n\n    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);\n  }\n  /**\n   * Filter waypoints for redundant ones (i.e. on the same axis).\n   * Returns the filtered waypoints and the offset related to the segment move.\n   *\n   * @param {Array<Point>} waypoints\n   * @param {Integer} segmentStartIndex of moved segment start\n   *\n   * @return {Object} { filteredWaypoints, segmentOffset }\n   */\n\n\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\n    var segmentOffset = 0;\n    var filteredWaypoints = waypoints.filter(function (r, idx) {\n      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\n        // remove point and increment offset\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\n        return false;\n      } // dont remove point\n\n\n      return true;\n    });\n    return {\n      waypoints: filteredWaypoints,\n      segmentOffset: segmentOffset\n    };\n  }\n\n  eventBus.on('connectionSegment.move.start', function (e) {\n    var context = e.context,\n        connection = e.connection,\n        layer = canvas.getLayer('overlays');\n    context.originalWaypoints = connection.waypoints.slice(); // add dragger gfx\n\n    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\n    svgClasses(context.draggerGfx).add('djs-dragging');\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on('connectionSegment.move.move', function (e) {\n    var context = e.context,\n        connection = context.connection,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEndIndex = context.segmentEndIndex,\n        segmentStart = context.segmentStart,\n        segmentEnd = context.segmentEnd,\n        axis = context.axis;\n    var newWaypoints = context.originalWaypoints.slice(),\n        newSegmentStart = axisAdd(segmentStart, axis, e['d' + axis]),\n        newSegmentEnd = axisAdd(segmentEnd, axis, e['d' + axis]); // original waypoint count and added / removed\n    // from start waypoint delta. We use the later\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\n\n    var waypointCount = newWaypoints.length,\n        segmentOffset = 0; // move segment start / end by axis delta\n\n    newWaypoints[segmentStartIndex] = newSegmentStart;\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\n    var sourceToSegmentOrientation, targetToSegmentOrientation; // handle first segment\n\n    if (segmentStartIndex < 2) {\n      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart); // first bendpoint, remove first segment if intersecting\n\n      if (segmentStartIndex === 1) {\n        if (sourceToSegmentOrientation === 'intersect') {\n          newWaypoints.shift();\n          newWaypoints[0] = newSegmentStart;\n          segmentOffset--;\n        }\n      } // docking point, add segment if not intersecting anymore\n      else {\n          if (sourceToSegmentOrientation !== 'intersect') {\n            newWaypoints.unshift(segmentStart);\n            segmentOffset++;\n          }\n        }\n    } // handle last segment\n\n\n    if (segmentEndIndex > waypointCount - 3) {\n      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd); // last bendpoint, remove last segment if intersecting\n\n      if (segmentEndIndex === waypointCount - 2) {\n        if (targetToSegmentOrientation === 'intersect') {\n          newWaypoints.pop();\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\n        }\n      } // last bendpoint, remove last segment if intersecting\n      else {\n          if (targetToSegmentOrientation !== 'intersect') {\n            newWaypoints.push(segmentEnd);\n          }\n        }\n    } // update connection waypoints\n\n\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints); // update dragger position\n\n    updateDragger(context, segmentOffset, e); // save segmentOffset in context\n\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset; // redraw connection\n\n    redrawConnection(e);\n  });\n  eventBus.on('connectionSegment.move.hover', function (e) {\n    e.context.hover = e.hover;\n    canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);\n  });\n  eventBus.on(['connectionSegment.move.out', 'connectionSegment.move.cleanup'], function (e) {\n    // remove connect marker\n    // if it was added\n    var hover = e.context.hover;\n\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n    }\n  });\n  eventBus.on('connectionSegment.move.cleanup', function (e) {\n    var context = e.context,\n        connection = context.connection; // remove dragger gfx\n\n    if (context.draggerGfx) {\n      svgRemove(context.draggerGfx);\n    }\n\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n  eventBus.on(['connectionSegment.move.cancel', 'connectionSegment.move.end'], function (e) {\n    var context = e.context,\n        connection = context.connection;\n    connection.waypoints = context.originalWaypoints;\n    redrawConnection(e);\n  });\n  eventBus.on('connectionSegment.move.end', function (e) {\n    var context = e.context,\n        connection = context.connection,\n        newWaypoints = context.newWaypoints,\n        newSegmentStartIndex = context.newSegmentStartIndex; // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n\n    newWaypoints = newWaypoints.map(function (p) {\n      return {\n        original: p.original,\n        x: Math.round(p.x),\n        y: Math.round(p.y)\n      };\n    }); // apply filter redunant waypoints\n\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex); // get filtered waypoints\n\n    var filteredWaypoints = filtered.waypoints,\n        croppedWaypoints = cropConnection(connection, filteredWaypoints),\n        segmentOffset = filtered.segmentOffset;\n    var hints = {\n      segmentMove: {\n        segmentStartIndex: context.segmentStartIndex,\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\n      }\n    };\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\n  });\n}\nConnectionSegmentMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'rules', 'modeling'];","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js"],"names":["pointsAligned","pointsOnLine","addSegmentDragger","getMid","getOrientation","MARKER_CONNECT_HOVER","MARKER_CONNECT_UPDATING","classes","svgClasses","remove","svgRemove","translate","axisAdd","point","axis","delta","axisSet","value","x","y","axisFenced","position","segmentStart","segmentEnd","maxValue","Math","max","minValue","min","padding","fencedValue","flipAxis","getDocking","referenceElement","moveAxis","referenceMid","inverseAxis","original","ConnectionSegmentMove","injector","eventBus","canvas","dragging","graphicsFactory","rules","modeling","connectionDocking","get","start","event","connection","idx","context","gfx","getGraphics","segmentStartIndex","segmentEndIndex","waypoints","direction","source","length","target","init","cursor","data","connectionGfx","cropConnection","newWaypoints","oldWaypoints","croppedWaypoints","getCroppedWaypoints","redrawConnection","update","updateDragger","segmentOffset","draggerPosition","draggerGfx","filterRedundantWaypoints","filteredWaypoints","filter","r","on","e","layer","getLayer","originalWaypoints","slice","add","addMarker","newSegmentStart","newSegmentEnd","waypointCount","sourceToSegmentOrientation","targetToSegmentOrientation","shift","unshift","pop","push","newSegmentStartIndex","hover","removeMarker","map","p","round","filtered","hints","segmentMove","updateWaypoints","$inject"],"mappings":"AAAA,SACEA,aADF,EAEEC,YAFF,QAGO,qBAHP;AAKA,SACEC,iBADF,QAEO,iBAFP;AAIA,SACEC,MADF,EAEEC,cAFF,QAGO,yBAHP;AAKA,IAAIC,oBAAoB,GAAG,eAA3B;AAAA,IACIC,uBAAuB,GAAG,cAD9B;AAGA,SACEC,OAAO,IAAIC,UADb,EAEEC,MAAM,IAAIC,SAFZ,QAGO,UAHP;AAKA,SACEC,SADF,QAEO,6BAFP;;AAKA,SAASC,OAAT,CAAiBC,KAAjB,EAAwBC,IAAxB,EAA8BC,KAA9B,EAAqC;AACnC,SAAOC,OAAO,CAACH,KAAD,EAAQC,IAAR,EAAcD,KAAK,CAACC,IAAD,CAAL,GAAcC,KAA5B,CAAd;AACD;;AAED,SAASC,OAAT,CAAiBH,KAAjB,EAAwBC,IAAxB,EAA8BG,KAA9B,EAAqC;AACnC,SAAO;AACLC,IAAAA,CAAC,EAAGJ,IAAI,KAAK,GAAT,GAAeG,KAAf,GAAuBJ,KAAK,CAACK,CAD5B;AAELC,IAAAA,CAAC,EAAGL,IAAI,KAAK,GAAT,GAAeG,KAAf,GAAuBJ,KAAK,CAACM;AAF5B,GAAP;AAID;;AAED,SAASC,UAAT,CAAoBC,QAApB,EAA8BC,YAA9B,EAA4CC,UAA5C,EAAwDT,IAAxD,EAA8D;AAE5D,MAAIU,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAASJ,YAAY,CAACR,IAAD,CAArB,EAA6BS,UAAU,CAACT,IAAD,CAAvC,CAAf;AAAA,MACIa,QAAQ,GAAGF,IAAI,CAACG,GAAL,CAASN,YAAY,CAACR,IAAD,CAArB,EAA6BS,UAAU,CAACT,IAAD,CAAvC,CADf;AAGA,MAAIe,OAAO,GAAG,EAAd;AAEA,MAAIC,WAAW,GAAGL,IAAI,CAACG,GAAL,CAASH,IAAI,CAACC,GAAL,CAASC,QAAQ,GAAGE,OAApB,EAA6BR,QAAQ,CAACP,IAAD,CAArC,CAAT,EAAuDU,QAAQ,GAAGK,OAAlE,CAAlB;AAEA,SAAOb,OAAO,CAACM,YAAD,EAAeR,IAAf,EAAqBgB,WAArB,CAAd;AACD;;AAED,SAASC,QAAT,CAAkBjB,IAAlB,EAAwB;AACtB,SAAOA,IAAI,KAAK,GAAT,GAAe,GAAf,GAAqB,GAA5B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkB,UAAT,CAAoBnB,KAApB,EAA2BoB,gBAA3B,EAA6CC,QAA7C,EAAuD;AAErD,MAAIC,YAAJ,EACIC,WADJ;;AAGA,MAAIvB,KAAK,CAACwB,QAAV,EAAoB;AAClB,WAAOxB,KAAK,CAACwB,QAAb;AACD,GAFD,MAEO;AACLF,IAAAA,YAAY,GAAGhC,MAAM,CAAC8B,gBAAD,CAArB;AACAG,IAAAA,WAAW,GAAGL,QAAQ,CAACG,QAAD,CAAtB;AAEA,WAAOlB,OAAO,CAACH,KAAD,EAAQuB,WAAR,EAAqBD,YAAY,CAACC,WAAD,CAAjC,CAAd;AACD;AACF;AAED;AACA;AACA;;;AACA,eAAe,SAASE,qBAAT,CACXC,QADW,EACDC,QADC,EACSC,MADT,EAEXC,QAFW,EAEDC,eAFC,EAEgBC,KAFhB,EAGXC,QAHW,EAGD;AAEZ;AACA,MAAIC,iBAAiB,GAAGP,QAAQ,CAACQ,GAAT,CAAa,mBAAb,EAAkC,KAAlC,CAAxB,CAHY,CAMZ;;AAEA,OAAKC,KAAL,GAAa,UAASC,KAAT,EAAgBC,UAAhB,EAA4BC,GAA5B,EAAiC;AAE5C,QAAIC,OAAJ;AAAA,QACIC,GAAG,GAAGZ,MAAM,CAACa,WAAP,CAAmBJ,UAAnB,CADV;AAAA,QAEIK,iBAAiB,GAAGJ,GAAG,GAAG,CAF9B;AAAA,QAGIK,eAAe,GAAGL,GAHtB;AAAA,QAIIM,SAAS,GAAGP,UAAU,CAACO,SAJ3B;AAAA,QAKInC,YAAY,GAAGmC,SAAS,CAACF,iBAAD,CAL5B;AAAA,QAMIhC,UAAU,GAAGkC,SAAS,CAACD,eAAD,CAN1B;AAAA,QAOIE,SAPJ;AAAA,QAQI5C,IARJ;AAUA4C,IAAAA,SAAS,GAAG1D,aAAa,CAACsB,YAAD,EAAeC,UAAf,CAAzB,CAZ4C,CAc5C;;AACA,QAAI,CAACmC,SAAL,EAAgB;AACd;AACD,KAjB2C,CAmB5C;;;AACA5C,IAAAA,IAAI,GAAG4C,SAAS,KAAK,GAAd,GAAoB,GAApB,GAA0B,GAAjC;;AAEA,QAAIH,iBAAiB,KAAK,CAA1B,EAA6B;AAC3BjC,MAAAA,YAAY,GAAGU,UAAU,CAACV,YAAD,EAAe4B,UAAU,CAACS,MAA1B,EAAkC7C,IAAlC,CAAzB;AACD;;AAED,QAAI0C,eAAe,KAAKC,SAAS,CAACG,MAAV,GAAmB,CAA3C,EAA8C;AAC5CrC,MAAAA,UAAU,GAAGS,UAAU,CAACT,UAAD,EAAa2B,UAAU,CAACW,MAAxB,EAAgC/C,IAAhC,CAAvB;AACD;;AAEDsC,IAAAA,OAAO,GAAG;AACRF,MAAAA,UAAU,EAAEA,UADJ;AAERK,MAAAA,iBAAiB,EAAEA,iBAFX;AAGRC,MAAAA,eAAe,EAAEA,eAHT;AAIRlC,MAAAA,YAAY,EAAEA,YAJN;AAKRC,MAAAA,UAAU,EAAEA,UALJ;AAMRT,MAAAA,IAAI,EAAEA;AANE,KAAV;AASA4B,IAAAA,QAAQ,CAACoB,IAAT,CAAcb,KAAd,EAAqB;AACnB/B,MAAAA,CAAC,EAAE,CAACI,YAAY,CAACJ,CAAb,GAAiBK,UAAU,CAACL,CAA7B,IAAgC,CADhB;AAEnBC,MAAAA,CAAC,EAAE,CAACG,YAAY,CAACH,CAAb,GAAiBI,UAAU,CAACJ,CAA7B,IAAgC;AAFhB,KAArB,EAGG,wBAHH,EAG6B;AAC3B4C,MAAAA,MAAM,EAAEjD,IAAI,KAAK,GAAT,GAAe,WAAf,GAA6B,WADV;AAE3BkD,MAAAA,IAAI,EAAE;AACJd,QAAAA,UAAU,EAAEA,UADR;AAEJe,QAAAA,aAAa,EAAEZ,GAFX;AAGJD,QAAAA,OAAO,EAAEA;AAHL;AAFqB,KAH7B;AAWD,GAlDD;AAoDA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASc,cAAT,CAAwBhB,UAAxB,EAAoCiB,YAApC,EAAkD;AAEhD;AACA,QAAI,CAACrB,iBAAL,EAAwB;AACtB,aAAOqB,YAAP;AACD;;AAED,QAAIC,YAAY,GAAGlB,UAAU,CAACO,SAA9B;AAAA,QACIY,gBADJ,CAPgD,CAUhD;;AACAnB,IAAAA,UAAU,CAACO,SAAX,GAAuBU,YAAvB;AAEAE,IAAAA,gBAAgB,GAAGvB,iBAAiB,CAACwB,mBAAlB,CAAsCpB,UAAtC,CAAnB,CAbgD,CAehD;;AACAA,IAAAA,UAAU,CAACO,SAAX,GAAuBW,YAAvB;AAEA,WAAOC,gBAAP;AACD,GAvFW,CAyFZ;;;AAEA,WAASE,gBAAT,CAA0BP,IAA1B,EAAgC;AAC9BrB,IAAAA,eAAe,CAAC6B,MAAhB,CAAuB,YAAvB,EAAqCR,IAAI,CAACd,UAA1C,EAAsDc,IAAI,CAACC,aAA3D;AACD;;AAED,WAASQ,aAAT,CAAuBrB,OAAvB,EAAgCsB,aAAhC,EAA+CzB,KAA/C,EAAsD;AAEpD,QAAIkB,YAAY,GAAGf,OAAO,CAACe,YAA3B;AAAA,QACIZ,iBAAiB,GAAGH,OAAO,CAACG,iBAAR,GAA4BmB,aADpD;AAAA,QAEIpD,YAAY,GAAG6C,YAAY,CAACZ,iBAAD,CAF/B;AAAA,QAGIC,eAAe,GAAGJ,OAAO,CAACI,eAAR,GAA0BkB,aAHhD;AAAA,QAIInD,UAAU,GAAG4C,YAAY,CAACX,eAAD,CAJ7B;AAAA,QAKI1C,IAAI,GAAGiB,QAAQ,CAACqB,OAAO,CAACtC,IAAT,CALnB,CAFoD,CASpD;AACA;;AACA,QAAI6D,eAAe,GAAGvD,UAAU,CAAC6B,KAAD,EAAQ3B,YAAR,EAAsBC,UAAtB,EAAkCT,IAAlC,CAAhC,CAXoD,CAapD;;AACAH,IAAAA,SAAS,CAACyC,OAAO,CAACwB,UAAT,EAAqBD,eAAe,CAACzD,CAArC,EAAwCyD,eAAe,CAACxD,CAAxD,CAAT;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAAS0D,wBAAT,CAAkCpB,SAAlC,EAA6CF,iBAA7C,EAAgE;AAE9D,QAAImB,aAAa,GAAG,CAApB;AAEA,QAAII,iBAAiB,GAAGrB,SAAS,CAACsB,MAAV,CAAiB,UAASC,CAAT,EAAY7B,GAAZ,EAAiB;AACxD,UAAIlD,YAAY,CAACwD,SAAS,CAACN,GAAG,GAAG,CAAP,CAAV,EAAqBM,SAAS,CAACN,GAAG,GAAG,CAAP,CAA9B,EAAyC6B,CAAzC,CAAhB,EAA6D;AAE3D;AACAN,QAAAA,aAAa,GAAGvB,GAAG,IAAII,iBAAP,GAA2BmB,aAAa,GAAG,CAA3C,GAA+CA,aAA/D;AACA,eAAO,KAAP;AACD,OANuD,CAQxD;;;AACA,aAAO,IAAP;AACD,KAVuB,CAAxB;AAYA,WAAO;AACLjB,MAAAA,SAAS,EAAEqB,iBADN;AAELJ,MAAAA,aAAa,EAAEA;AAFV,KAAP;AAID;;AAEDlC,EAAAA,QAAQ,CAACyC,EAAT,CAAY,8BAAZ,EAA4C,UAASC,CAAT,EAAY;AAEtD,QAAI9B,OAAO,GAAG8B,CAAC,CAAC9B,OAAhB;AAAA,QACIF,UAAU,GAAGgC,CAAC,CAAChC,UADnB;AAAA,QAEIiC,KAAK,GAAG1C,MAAM,CAAC2C,QAAP,CAAgB,UAAhB,CAFZ;AAIAhC,IAAAA,OAAO,CAACiC,iBAAR,GAA4BnC,UAAU,CAACO,SAAX,CAAqB6B,KAArB,EAA5B,CANsD,CAQtD;;AACAlC,IAAAA,OAAO,CAACwB,UAAR,GAAqB1E,iBAAiB,CAACiF,KAAD,EAAQ/B,OAAO,CAAC9B,YAAhB,EAA8B8B,OAAO,CAAC7B,UAAtC,CAAtC;AACAf,IAAAA,UAAU,CAAC4C,OAAO,CAACwB,UAAT,CAAV,CAA+BW,GAA/B,CAAmC,cAAnC;AAEA9C,IAAAA,MAAM,CAAC+C,SAAP,CAAiBtC,UAAjB,EAA6B5C,uBAA7B;AACD,GAbD;AAeAkC,EAAAA,QAAQ,CAACyC,EAAT,CAAY,6BAAZ,EAA2C,UAASC,CAAT,EAAY;AAErD,QAAI9B,OAAO,GAAG8B,CAAC,CAAC9B,OAAhB;AAAA,QACIF,UAAU,GAAGE,OAAO,CAACF,UADzB;AAAA,QAEIK,iBAAiB,GAAGH,OAAO,CAACG,iBAFhC;AAAA,QAGIC,eAAe,GAAGJ,OAAO,CAACI,eAH9B;AAAA,QAIIlC,YAAY,GAAG8B,OAAO,CAAC9B,YAJ3B;AAAA,QAKIC,UAAU,GAAG6B,OAAO,CAAC7B,UALzB;AAAA,QAMIT,IAAI,GAAGsC,OAAO,CAACtC,IANnB;AAQA,QAAIqD,YAAY,GAAGf,OAAO,CAACiC,iBAAR,CAA0BC,KAA1B,EAAnB;AAAA,QACIG,eAAe,GAAG7E,OAAO,CAACU,YAAD,EAAeR,IAAf,EAAqBoE,CAAC,CAAC,MAAMpE,IAAP,CAAtB,CAD7B;AAAA,QAEI4E,aAAa,GAAG9E,OAAO,CAACW,UAAD,EAAaT,IAAb,EAAmBoE,CAAC,CAAC,MAAMpE,IAAP,CAApB,CAF3B,CAVqD,CAcrD;AACA;AACA;;AACA,QAAI6E,aAAa,GAAGxB,YAAY,CAACP,MAAjC;AAAA,QACIc,aAAa,GAAG,CADpB,CAjBqD,CAoBrD;;AACAP,IAAAA,YAAY,CAACZ,iBAAD,CAAZ,GAAkCkC,eAAlC;AACAtB,IAAAA,YAAY,CAACX,eAAD,CAAZ,GAAgCkC,aAAhC;AAEA,QAAIE,0BAAJ,EACIC,0BADJ,CAxBqD,CA2BrD;;AACA,QAAItC,iBAAiB,GAAG,CAAxB,EAA2B;AACzBqC,MAAAA,0BAA0B,GAAGxF,cAAc,CAAC8C,UAAU,CAACS,MAAZ,EAAoB8B,eAApB,CAA3C,CADyB,CAGzB;;AACA,UAAIlC,iBAAiB,KAAK,CAA1B,EAA6B;AAE3B,YAAIqC,0BAA0B,KAAK,WAAnC,EAAgD;AAC9CzB,UAAAA,YAAY,CAAC2B,KAAb;AACA3B,UAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBsB,eAAlB;AACAf,UAAAA,aAAa;AACd;AACF,OAPD,CASA;AATA,WAUK;AACH,cAAIkB,0BAA0B,KAAK,WAAnC,EAAgD;AAC9CzB,YAAAA,YAAY,CAAC4B,OAAb,CAAqBzE,YAArB;AACAoD,YAAAA,aAAa;AACd;AACF;AACF,KAhDoD,CAkDrD;;;AACA,QAAIlB,eAAe,GAAGmC,aAAa,GAAG,CAAtC,EAAyC;AACvCE,MAAAA,0BAA0B,GAAGzF,cAAc,CAAC8C,UAAU,CAACW,MAAZ,EAAoB6B,aAApB,CAA3C,CADuC,CAGvC;;AACA,UAAIlC,eAAe,KAAKmC,aAAa,GAAG,CAAxC,EAA2C;AAEzC,YAAIE,0BAA0B,KAAK,WAAnC,EAAgD;AAC9C1B,UAAAA,YAAY,CAAC6B,GAAb;AACA7B,UAAAA,YAAY,CAACA,YAAY,CAACP,MAAb,GAAsB,CAAvB,CAAZ,GAAwC8B,aAAxC;AACD;AACF,OAND,CAQA;AARA,WASK;AACH,cAAIG,0BAA0B,KAAK,WAAnC,EAAgD;AAC9C1B,YAAAA,YAAY,CAAC8B,IAAb,CAAkB1E,UAAlB;AACD;AACF;AACF,KArEoD,CAuErD;;;AACA6B,IAAAA,OAAO,CAACe,YAAR,GAAuBjB,UAAU,CAACO,SAAX,GAAuBS,cAAc,CAAChB,UAAD,EAAaiB,YAAb,CAA5D,CAxEqD,CA0ErD;;AACAM,IAAAA,aAAa,CAACrB,OAAD,EAAUsB,aAAV,EAAyBQ,CAAzB,CAAb,CA3EqD,CA6ErD;;AACA9B,IAAAA,OAAO,CAAC8C,oBAAR,GAA+B3C,iBAAiB,GAAGmB,aAAnD,CA9EqD,CAgFrD;;AACAH,IAAAA,gBAAgB,CAACW,CAAD,CAAhB;AACD,GAlFD;AAoFA1C,EAAAA,QAAQ,CAACyC,EAAT,CAAY,8BAAZ,EAA4C,UAASC,CAAT,EAAY;AAEtDA,IAAAA,CAAC,CAAC9B,OAAF,CAAU+C,KAAV,GAAkBjB,CAAC,CAACiB,KAApB;AACA1D,IAAAA,MAAM,CAAC+C,SAAP,CAAiBN,CAAC,CAACiB,KAAnB,EAA0B9F,oBAA1B;AACD,GAJD;AAMAmC,EAAAA,QAAQ,CAACyC,EAAT,CAAY,CACV,4BADU,EAEV,gCAFU,CAAZ,EAGG,UAASC,CAAT,EAAY;AAEb;AACA;AACA,QAAIiB,KAAK,GAAGjB,CAAC,CAAC9B,OAAF,CAAU+C,KAAtB;;AAEA,QAAIA,KAAJ,EAAW;AACT1D,MAAAA,MAAM,CAAC2D,YAAP,CAAoBD,KAApB,EAA2B9F,oBAA3B;AACD;AACF,GAZD;AAcAmC,EAAAA,QAAQ,CAACyC,EAAT,CAAY,gCAAZ,EAA8C,UAASC,CAAT,EAAY;AAExD,QAAI9B,OAAO,GAAG8B,CAAC,CAAC9B,OAAhB;AAAA,QACIF,UAAU,GAAGE,OAAO,CAACF,UADzB,CAFwD,CAKxD;;AACA,QAAIE,OAAO,CAACwB,UAAZ,EAAwB;AACtBlE,MAAAA,SAAS,CAAC0C,OAAO,CAACwB,UAAT,CAAT;AACD;;AAEDnC,IAAAA,MAAM,CAAC2D,YAAP,CAAoBlD,UAApB,EAAgC5C,uBAAhC;AACD,GAXD;AAaAkC,EAAAA,QAAQ,CAACyC,EAAT,CAAY,CACV,+BADU,EAEV,4BAFU,CAAZ,EAGG,UAASC,CAAT,EAAY;AACb,QAAI9B,OAAO,GAAG8B,CAAC,CAAC9B,OAAhB;AAAA,QACIF,UAAU,GAAGE,OAAO,CAACF,UADzB;AAGAA,IAAAA,UAAU,CAACO,SAAX,GAAuBL,OAAO,CAACiC,iBAA/B;AAEAd,IAAAA,gBAAgB,CAACW,CAAD,CAAhB;AACD,GAVD;AAYA1C,EAAAA,QAAQ,CAACyC,EAAT,CAAY,4BAAZ,EAA0C,UAASC,CAAT,EAAY;AAEpD,QAAI9B,OAAO,GAAG8B,CAAC,CAAC9B,OAAhB;AAAA,QACIF,UAAU,GAAGE,OAAO,CAACF,UADzB;AAAA,QAEIiB,YAAY,GAAGf,OAAO,CAACe,YAF3B;AAAA,QAGI+B,oBAAoB,GAAG9C,OAAO,CAAC8C,oBAHnC,CAFoD,CAOpD;AACA;;AACA/B,IAAAA,YAAY,GAAGA,YAAY,CAACkC,GAAb,CAAiB,UAASC,CAAT,EAAY;AAC1C,aAAO;AACLjE,QAAAA,QAAQ,EAAEiE,CAAC,CAACjE,QADP;AAELnB,QAAAA,CAAC,EAAEO,IAAI,CAAC8E,KAAL,CAAWD,CAAC,CAACpF,CAAb,CAFE;AAGLC,QAAAA,CAAC,EAAEM,IAAI,CAAC8E,KAAL,CAAWD,CAAC,CAACnF,CAAb;AAHE,OAAP;AAKD,KANc,CAAf,CAToD,CAiBpD;;AACA,QAAIqF,QAAQ,GAAG3B,wBAAwB,CAACV,YAAD,EAAe+B,oBAAf,CAAvC,CAlBoD,CAoBpD;;AACA,QAAIpB,iBAAiB,GAAG0B,QAAQ,CAAC/C,SAAjC;AAAA,QACIY,gBAAgB,GAAGH,cAAc,CAAChB,UAAD,EAAa4B,iBAAb,CADrC;AAAA,QAEIJ,aAAa,GAAG8B,QAAQ,CAAC9B,aAF7B;AAIA,QAAI+B,KAAK,GAAG;AACVC,MAAAA,WAAW,EAAE;AACXnD,QAAAA,iBAAiB,EAAEH,OAAO,CAACG,iBADhB;AAEX2C,QAAAA,oBAAoB,EAAEA,oBAAoB,GAAGxB;AAFlC;AADH,KAAZ;AAOA7B,IAAAA,QAAQ,CAAC8D,eAAT,CAAyBzD,UAAzB,EAAqCmB,gBAArC,EAAuDoC,KAAvD;AACD,GAjCD;AAkCD;AAEDnE,qBAAqB,CAACsE,OAAtB,GAAgC,CAC9B,UAD8B,EAE9B,UAF8B,EAG9B,QAH8B,EAI9B,UAJ8B,EAK9B,iBAL8B,EAM9B,OAN8B,EAO9B,UAP8B,CAAhC","sourcesContent":["import {\n  pointsAligned,\n  pointsOnLine\n} from '../../util/Geometry';\n\nimport {\n  addSegmentDragger\n} from './BendpointUtil';\n\nimport {\n  getMid,\n  getOrientation\n} from '../../layout/LayoutUtil';\n\nvar MARKER_CONNECT_HOVER = 'connect-hover',\n    MARKER_CONNECT_UPDATING = 'djs-updating';\n\nimport {\n  classes as svgClasses,\n  remove as svgRemove\n} from 'tiny-svg';\n\nimport {\n  translate\n} from '../../util/SvgTransformUtil';\n\n\nfunction axisAdd(point, axis, delta) {\n  return axisSet(point, axis, point[axis] + delta);\n}\n\nfunction axisSet(point, axis, value) {\n  return {\n    x: (axis === 'x' ? value : point.x),\n    y: (axis === 'y' ? value : point.y)\n  };\n}\n\nfunction axisFenced(position, segmentStart, segmentEnd, axis) {\n\n  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),\n      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);\n\n  var padding = 20;\n\n  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);\n\n  return axisSet(segmentStart, axis, fencedValue);\n}\n\nfunction flipAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Get the docking point on the given element.\n *\n * Compute a reasonable docking, if non exists.\n *\n * @param  {Point} point\n * @param  {djs.model.Shape} referenceElement\n * @param  {String} moveAxis (x|y)\n *\n * @return {Point}\n */\nfunction getDocking(point, referenceElement, moveAxis) {\n\n  var referenceMid,\n      inverseAxis;\n\n  if (point.original) {\n    return point.original;\n  } else {\n    referenceMid = getMid(referenceElement);\n    inverseAxis = flipAxis(moveAxis);\n\n    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);\n  }\n}\n\n/**\n * A component that implements moving of bendpoints\n */\nexport default function ConnectionSegmentMove(\n    injector, eventBus, canvas,\n    dragging, graphicsFactory, rules,\n    modeling) {\n\n  // optional connection docking integration\n  var connectionDocking = injector.get('connectionDocking', false);\n\n\n  // API\n\n  this.start = function(event, connection, idx) {\n\n    var context,\n        gfx = canvas.getGraphics(connection),\n        segmentStartIndex = idx - 1,\n        segmentEndIndex = idx,\n        waypoints = connection.waypoints,\n        segmentStart = waypoints[segmentStartIndex],\n        segmentEnd = waypoints[segmentEndIndex],\n        direction,\n        axis;\n\n    direction = pointsAligned(segmentStart, segmentEnd);\n\n    // do not move diagonal connection\n    if (!direction) {\n      return;\n    }\n\n    // the axis where we are going to move things\n    axis = direction === 'v' ? 'y' : 'x';\n\n    if (segmentStartIndex === 0) {\n      segmentStart = getDocking(segmentStart, connection.source, axis);\n    }\n\n    if (segmentEndIndex === waypoints.length - 1) {\n      segmentEnd = getDocking(segmentEnd, connection.target, axis);\n    }\n\n    context = {\n      connection: connection,\n      segmentStartIndex: segmentStartIndex,\n      segmentEndIndex: segmentEndIndex,\n      segmentStart: segmentStart,\n      segmentEnd: segmentEnd,\n      axis: axis\n    };\n\n    dragging.init(event, {\n      x: (segmentStart.x + segmentEnd.x)/2,\n      y: (segmentStart.y + segmentEnd.y)/2\n    }, 'connectionSegment.move', {\n      cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',\n      data: {\n        connection: connection,\n        connectionGfx: gfx,\n        context: context\n      }\n    });\n  };\n\n  /**\n   * Crop connection if connection cropping is provided.\n   *\n   * @param {Connection} connection\n   * @param {Array<Point>} newWaypoints\n   *\n   * @return {Array<Point>} cropped connection waypoints\n   */\n  function cropConnection(connection, newWaypoints) {\n\n    // crop connection, if docking service is provided only\n    if (!connectionDocking) {\n      return newWaypoints;\n    }\n\n    var oldWaypoints = connection.waypoints,\n        croppedWaypoints;\n\n    // temporary set new waypoints\n    connection.waypoints = newWaypoints;\n\n    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);\n\n    // restore old waypoints\n    connection.waypoints = oldWaypoints;\n\n    return croppedWaypoints;\n  }\n\n  // DRAGGING IMPLEMENTATION\n\n  function redrawConnection(data) {\n    graphicsFactory.update('connection', data.connection, data.connectionGfx);\n  }\n\n  function updateDragger(context, segmentOffset, event) {\n\n    var newWaypoints = context.newWaypoints,\n        segmentStartIndex = context.segmentStartIndex + segmentOffset,\n        segmentStart = newWaypoints[segmentStartIndex],\n        segmentEndIndex = context.segmentEndIndex + segmentOffset,\n        segmentEnd = newWaypoints[segmentEndIndex],\n        axis = flipAxis(context.axis);\n\n    // make sure the dragger does not move\n    // outside the connection\n    var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);\n\n    // update dragger\n    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);\n  }\n\n  /**\n   * Filter waypoints for redundant ones (i.e. on the same axis).\n   * Returns the filtered waypoints and the offset related to the segment move.\n   *\n   * @param {Array<Point>} waypoints\n   * @param {Integer} segmentStartIndex of moved segment start\n   *\n   * @return {Object} { filteredWaypoints, segmentOffset }\n   */\n  function filterRedundantWaypoints(waypoints, segmentStartIndex) {\n\n    var segmentOffset = 0;\n\n    var filteredWaypoints = waypoints.filter(function(r, idx) {\n      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {\n\n        // remove point and increment offset\n        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;\n        return false;\n      }\n\n      // dont remove point\n      return true;\n    });\n\n    return {\n      waypoints: filteredWaypoints,\n      segmentOffset: segmentOffset\n    };\n  }\n\n  eventBus.on('connectionSegment.move.start', function(e) {\n\n    var context = e.context,\n        connection = e.connection,\n        layer = canvas.getLayer('overlays');\n\n    context.originalWaypoints = connection.waypoints.slice();\n\n    // add dragger gfx\n    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);\n    svgClasses(context.draggerGfx).add('djs-dragging');\n\n    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on('connectionSegment.move.move', function(e) {\n\n    var context = e.context,\n        connection = context.connection,\n        segmentStartIndex = context.segmentStartIndex,\n        segmentEndIndex = context.segmentEndIndex,\n        segmentStart = context.segmentStart,\n        segmentEnd = context.segmentEnd,\n        axis = context.axis;\n\n    var newWaypoints = context.originalWaypoints.slice(),\n        newSegmentStart = axisAdd(segmentStart, axis, e['d' + axis]),\n        newSegmentEnd = axisAdd(segmentEnd, axis, e['d' + axis]);\n\n    // original waypoint count and added / removed\n    // from start waypoint delta. We use the later\n    // to retrieve the updated segmentStartIndex / segmentEndIndex\n    var waypointCount = newWaypoints.length,\n        segmentOffset = 0;\n\n    // move segment start / end by axis delta\n    newWaypoints[segmentStartIndex] = newSegmentStart;\n    newWaypoints[segmentEndIndex] = newSegmentEnd;\n\n    var sourceToSegmentOrientation,\n        targetToSegmentOrientation;\n\n    // handle first segment\n    if (segmentStartIndex < 2) {\n      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);\n\n      // first bendpoint, remove first segment if intersecting\n      if (segmentStartIndex === 1) {\n\n        if (sourceToSegmentOrientation === 'intersect') {\n          newWaypoints.shift();\n          newWaypoints[0] = newSegmentStart;\n          segmentOffset--;\n        }\n      }\n\n      // docking point, add segment if not intersecting anymore\n      else {\n        if (sourceToSegmentOrientation !== 'intersect') {\n          newWaypoints.unshift(segmentStart);\n          segmentOffset++;\n        }\n      }\n    }\n\n    // handle last segment\n    if (segmentEndIndex > waypointCount - 3) {\n      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);\n\n      // last bendpoint, remove last segment if intersecting\n      if (segmentEndIndex === waypointCount - 2) {\n\n        if (targetToSegmentOrientation === 'intersect') {\n          newWaypoints.pop();\n          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;\n        }\n      }\n\n      // last bendpoint, remove last segment if intersecting\n      else {\n        if (targetToSegmentOrientation !== 'intersect') {\n          newWaypoints.push(segmentEnd);\n        }\n      }\n    }\n\n    // update connection waypoints\n    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);\n\n    // update dragger position\n    updateDragger(context, segmentOffset, e);\n\n    // save segmentOffset in context\n    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;\n\n    // redraw connection\n    redrawConnection(e);\n  });\n\n  eventBus.on('connectionSegment.move.hover', function(e) {\n\n    e.context.hover = e.hover;\n    canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);\n  });\n\n  eventBus.on([\n    'connectionSegment.move.out',\n    'connectionSegment.move.cleanup'\n  ], function(e) {\n\n    // remove connect marker\n    // if it was added\n    var hover = e.context.hover;\n\n    if (hover) {\n      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);\n    }\n  });\n\n  eventBus.on('connectionSegment.move.cleanup', function(e) {\n\n    var context = e.context,\n        connection = context.connection;\n\n    // remove dragger gfx\n    if (context.draggerGfx) {\n      svgRemove(context.draggerGfx);\n    }\n\n    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);\n  });\n\n  eventBus.on([\n    'connectionSegment.move.cancel',\n    'connectionSegment.move.end'\n  ], function(e) {\n    var context = e.context,\n        connection = context.connection;\n\n    connection.waypoints = context.originalWaypoints;\n\n    redrawConnection(e);\n  });\n\n  eventBus.on('connectionSegment.move.end', function(e) {\n\n    var context = e.context,\n        connection = context.connection,\n        newWaypoints = context.newWaypoints,\n        newSegmentStartIndex = context.newSegmentStartIndex;\n\n    // ensure we have actual pixel values bendpoint\n    // coordinates (important when zoom level was > 1 during move)\n    newWaypoints = newWaypoints.map(function(p) {\n      return {\n        original: p.original,\n        x: Math.round(p.x),\n        y: Math.round(p.y)\n      };\n    });\n\n    // apply filter redunant waypoints\n    var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);\n\n    // get filtered waypoints\n    var filteredWaypoints = filtered.waypoints,\n        croppedWaypoints = cropConnection(connection, filteredWaypoints),\n        segmentOffset = filtered.segmentOffset;\n\n    var hints = {\n      segmentMove: {\n        segmentStartIndex: context.segmentStartIndex,\n        newSegmentStartIndex: newSegmentStartIndex + segmentOffset\n      }\n    };\n\n    modeling.updateWaypoints(connection, croppedWaypoints, hints);\n  });\n}\n\nConnectionSegmentMove.$inject = [\n  'injector',\n  'eventBus',\n  'canvas',\n  'dragging',\n  'graphicsFactory',\n  'rules',\n  'modeling'\n];\n"]},"metadata":{},"sourceType":"module"}