{"ast":null,"code":"import { assign, isArray, isNumber, isObject, isUndefined, groupBy, forEach } from 'min-dash';\n/**\n * Adds an element to a collection and returns true if the\n * element was added.\n *\n * @param {Array<Object>} elements\n * @param {Object} e\n * @param {Boolean} unique\n */\n\nexport function add(elements, e, unique) {\n  var canAdd = !unique || elements.indexOf(e) === -1;\n\n  if (canAdd) {\n    elements.push(e);\n  }\n\n  return canAdd;\n}\n/**\n * Iterate over each element in a collection, calling the iterator function `fn`\n * with (element, index, recursionDepth).\n *\n * Recurse into all elements that are returned by `fn`.\n *\n * @param  {Object|Array<Object>} elements\n * @param  {Function} fn iterator function called with (element, index, recursionDepth)\n * @param  {Number} [depth] maximum recursion depth\n */\n\nexport function eachElement(elements, fn, depth) {\n  depth = depth || 0;\n\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n\n  forEach(elements, function (s, i) {\n    var filter = fn(s, i, depth);\n\n    if (isArray(filter) && filter.length) {\n      eachElement(filter, fn, depth + 1);\n    }\n  });\n}\n/**\n * Collects self + child elements up to a given depth from a list of elements.\n *\n * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from\n * @param  {Boolean} unique whether to return a unique result set (no duplicates)\n * @param  {Number} maxDepth the depth to search through or -1 for infinite\n *\n * @return {Array<djs.model.Base>} found elements\n */\n\nexport function selfAndChildren(elements, unique, maxDepth) {\n  var result = [],\n      processedChildren = [];\n  eachElement(elements, function (element, i, depth) {\n    add(result, element, unique);\n    var children = element.children; // max traversal depth not reached yet\n\n    if (maxDepth === -1 || depth < maxDepth) {\n      // children exist && children not yet processed\n      if (children && add(processedChildren, children, unique)) {\n        return children;\n      }\n    }\n  });\n  return result;\n}\n/**\n * Return self + direct children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {Boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\n\nexport function selfAndDirectChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, 1);\n}\n/**\n * Return self + ALL children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {Boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\n\nexport function selfAndAllChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, -1);\n}\n/**\n * Gets the the closure for all selected elements,\n * their enclosed children and connections.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {Boolean} [isTopLevel=true]\n * @param {Object} [existingClosure]\n *\n * @return {Object} newClosure\n */\n\nexport function getClosure(elements, isTopLevel, closure) {\n  if (isUndefined(isTopLevel)) {\n    isTopLevel = true;\n  }\n\n  if (isObject(isTopLevel)) {\n    closure = isTopLevel;\n    isTopLevel = true;\n  }\n\n  closure = closure || {};\n  var allShapes = copyObject(closure.allShapes),\n      allConnections = copyObject(closure.allConnections),\n      enclosedElements = copyObject(closure.enclosedElements),\n      enclosedConnections = copyObject(closure.enclosedConnections);\n  var topLevel = copyObject(closure.topLevel, isTopLevel && groupBy(elements, function (e) {\n    return e.id;\n  }));\n\n  function handleConnection(c) {\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\n      topLevel[c.id] = [c];\n    } // not enclosed as a child, but maybe logically\n    // (connecting two moved elements?)\n\n\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\n    }\n\n    allConnections[c.id] = c;\n  }\n\n  function handleElement(element) {\n    enclosedElements[element.id] = element;\n\n    if (element.waypoints) {\n      // remember connection\n      enclosedConnections[element.id] = allConnections[element.id] = element;\n    } else {\n      // remember shape\n      allShapes[element.id] = element; // remember all connections\n\n      forEach(element.incoming, handleConnection);\n      forEach(element.outgoing, handleConnection); // recurse into children\n\n      return element.children;\n    }\n  }\n\n  eachElement(elements, handleElement);\n  return {\n    allShapes: allShapes,\n    allConnections: allConnections,\n    topLevel: topLevel,\n    enclosedConnections: enclosedConnections,\n    enclosedElements: enclosedElements\n  };\n}\n/**\n * Returns the surrounding bbox for all elements in\n * the array or the element primitive.\n *\n * @param {Array<djs.model.Shape>|djs.model.Shape} elements\n * @param {Boolean} stopRecursion\n */\n\nexport function getBBox(elements, stopRecursion) {\n  stopRecursion = !!stopRecursion;\n\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n\n  var minX, minY, maxX, maxY;\n  forEach(elements, function (element) {\n    // If element is a connection the bbox must be computed first\n    var bbox = element;\n\n    if (element.waypoints && !stopRecursion) {\n      bbox = getBBox(element.waypoints, true);\n    }\n\n    var x = bbox.x,\n        y = bbox.y,\n        height = bbox.height || 0,\n        width = bbox.width || 0;\n\n    if (x < minX || minX === undefined) {\n      minX = x;\n    }\n\n    if (y < minY || minY === undefined) {\n      minY = y;\n    }\n\n    if (x + width > maxX || maxX === undefined) {\n      maxX = x + width;\n    }\n\n    if (y + height > maxY || maxY === undefined) {\n      maxY = y + height;\n    }\n  });\n  return {\n    x: minX,\n    y: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n}\n/**\n * Returns all elements that are enclosed from the bounding box.\n *\n *   * If bbox.(width|height) is not specified the method returns\n *     all elements with element.x/y > bbox.x/y\n *   * If only bbox.x or bbox.y is specified, method return all elements with\n *     e.x > bbox.x or e.y > bbox.y\n *\n * @param {Array<djs.model.Shape>} elements List of Elements to search through\n * @param {djs.model.Shape} bbox the enclosing bbox.\n *\n * @return {Array<djs.model.Shape>} enclosed elements\n */\n\nexport function getEnclosedElements(elements, bbox) {\n  var filteredElements = {};\n  forEach(elements, function (element) {\n    var e = element;\n\n    if (e.waypoints) {\n      e = getBBox(e);\n    }\n\n    if (!isNumber(bbox.y) && e.x > bbox.x) {\n      filteredElements[element.id] = element;\n    }\n\n    if (!isNumber(bbox.x) && e.y > bbox.y) {\n      filteredElements[element.id] = element;\n    }\n\n    if (e.x > bbox.x && e.y > bbox.y) {\n      if (isNumber(bbox.width) && isNumber(bbox.height) && e.width + e.x < bbox.width + bbox.x && e.height + e.y < bbox.height + bbox.y) {\n        filteredElements[element.id] = element;\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\n        filteredElements[element.id] = element;\n      }\n    }\n  });\n  return filteredElements;\n}\nexport function getType(element) {\n  if ('waypoints' in element) {\n    return 'connection';\n  }\n\n  if ('x' in element) {\n    return 'shape';\n  }\n\n  return 'root';\n} // helpers ///////////////////////////////\n\nfunction copyObject(src1, src2) {\n  return assign({}, src1 || {}, src2 || {});\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/util/Elements.js"],"names":["assign","isArray","isNumber","isObject","isUndefined","groupBy","forEach","add","elements","e","unique","canAdd","indexOf","push","eachElement","fn","depth","s","i","filter","length","selfAndChildren","maxDepth","result","processedChildren","element","children","selfAndDirectChildren","allowDuplicates","selfAndAllChildren","getClosure","isTopLevel","closure","allShapes","copyObject","allConnections","enclosedElements","enclosedConnections","topLevel","id","handleConnection","c","source","target","handleElement","waypoints","incoming","outgoing","getBBox","stopRecursion","minX","minY","maxX","maxY","bbox","x","y","height","width","undefined","getEnclosedElements","filteredElements","getType","src1","src2"],"mappings":"AAAA,SACEA,MADF,EAEEC,OAFF,EAGEC,QAHF,EAIEC,QAJF,EAKEC,WALF,EAMEC,OANF,EAOEC,OAPF,QAQO,UARP;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,GAAT,CAAaC,QAAb,EAAuBC,CAAvB,EAA0BC,MAA1B,EAAkC;AACvC,MAAIC,MAAM,GAAG,CAACD,MAAD,IAAWF,QAAQ,CAACI,OAAT,CAAiBH,CAAjB,MAAwB,CAAC,CAAjD;;AAEA,MAAIE,MAAJ,EAAY;AACVH,IAAAA,QAAQ,CAACK,IAAT,CAAcJ,CAAd;AACD;;AAED,SAAOE,MAAP;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,WAAT,CAAqBN,QAArB,EAA+BO,EAA/B,EAAmCC,KAAnC,EAA0C;AAE/CA,EAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;;AAEA,MAAI,CAACf,OAAO,CAACO,QAAD,CAAZ,EAAwB;AACtBA,IAAAA,QAAQ,GAAG,CAAEA,QAAF,CAAX;AACD;;AAEDF,EAAAA,OAAO,CAACE,QAAD,EAAW,UAASS,CAAT,EAAYC,CAAZ,EAAe;AAC/B,QAAIC,MAAM,GAAGJ,EAAE,CAACE,CAAD,EAAIC,CAAJ,EAAOF,KAAP,CAAf;;AAEA,QAAIf,OAAO,CAACkB,MAAD,CAAP,IAAmBA,MAAM,CAACC,MAA9B,EAAsC;AACpCN,MAAAA,WAAW,CAACK,MAAD,EAASJ,EAAT,EAAaC,KAAK,GAAG,CAArB,CAAX;AACD;AACF,GANM,CAAP;AAOD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,eAAT,CAAyBb,QAAzB,EAAmCE,MAAnC,EAA2CY,QAA3C,EAAqD;AAC1D,MAAIC,MAAM,GAAG,EAAb;AAAA,MACIC,iBAAiB,GAAG,EADxB;AAGAV,EAAAA,WAAW,CAACN,QAAD,EAAW,UAASiB,OAAT,EAAkBP,CAAlB,EAAqBF,KAArB,EAA4B;AAChDT,IAAAA,GAAG,CAACgB,MAAD,EAASE,OAAT,EAAkBf,MAAlB,CAAH;AAEA,QAAIgB,QAAQ,GAAGD,OAAO,CAACC,QAAvB,CAHgD,CAKhD;;AACA,QAAIJ,QAAQ,KAAK,CAAC,CAAd,IAAmBN,KAAK,GAAGM,QAA/B,EAAyC;AAEvC;AACA,UAAII,QAAQ,IAAInB,GAAG,CAACiB,iBAAD,EAAoBE,QAApB,EAA8BhB,MAA9B,CAAnB,EAA0D;AACxD,eAAOgB,QAAP;AACD;AACF;AACF,GAbU,CAAX;AAeA,SAAOH,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,qBAAT,CAA+BnB,QAA/B,EAAyCoB,eAAzC,EAA0D;AAC/D,SAAOP,eAAe,CAACb,QAAD,EAAW,CAACoB,eAAZ,EAA6B,CAA7B,CAAtB;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,kBAAT,CAA4BrB,QAA5B,EAAsCoB,eAAtC,EAAuD;AAC5D,SAAOP,eAAe,CAACb,QAAD,EAAW,CAACoB,eAAZ,EAA6B,CAAC,CAA9B,CAAtB;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,UAAT,CAAoBtB,QAApB,EAA8BuB,UAA9B,EAA0CC,OAA1C,EAAmD;AAExD,MAAI5B,WAAW,CAAC2B,UAAD,CAAf,EAA6B;AAC3BA,IAAAA,UAAU,GAAG,IAAb;AACD;;AAED,MAAI5B,QAAQ,CAAC4B,UAAD,CAAZ,EAA0B;AACxBC,IAAAA,OAAO,GAAGD,UAAV;AACAA,IAAAA,UAAU,GAAG,IAAb;AACD;;AAGDC,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,MAAIC,SAAS,GAAGC,UAAU,CAACF,OAAO,CAACC,SAAT,CAA1B;AAAA,MACIE,cAAc,GAAGD,UAAU,CAACF,OAAO,CAACG,cAAT,CAD/B;AAAA,MAEIC,gBAAgB,GAAGF,UAAU,CAACF,OAAO,CAACI,gBAAT,CAFjC;AAAA,MAGIC,mBAAmB,GAAGH,UAAU,CAACF,OAAO,CAACK,mBAAT,CAHpC;AAKA,MAAIC,QAAQ,GAAGJ,UAAU,CACvBF,OAAO,CAACM,QADe,EAEvBP,UAAU,IAAI1B,OAAO,CAACG,QAAD,EAAW,UAASC,CAAT,EAAY;AAAE,WAAOA,CAAC,CAAC8B,EAAT;AAAc,GAAvC,CAFE,CAAzB;;AAMA,WAASC,gBAAT,CAA0BC,CAA1B,EAA6B;AAC3B,QAAIH,QAAQ,CAACG,CAAC,CAACC,MAAF,CAASH,EAAV,CAAR,IAAyBD,QAAQ,CAACG,CAAC,CAACE,MAAF,CAASJ,EAAV,CAArC,EAAoD;AAClDD,MAAAA,QAAQ,CAACG,CAAC,CAACF,EAAH,CAAR,GAAiB,CAAEE,CAAF,CAAjB;AACD,KAH0B,CAK3B;AACA;;;AACA,QAAIR,SAAS,CAACQ,CAAC,CAACC,MAAF,CAASH,EAAV,CAAT,IAA0BN,SAAS,CAACQ,CAAC,CAACE,MAAF,CAASJ,EAAV,CAAvC,EAAsD;AACpDF,MAAAA,mBAAmB,CAACI,CAAC,CAACF,EAAH,CAAnB,GAA4BH,gBAAgB,CAACK,CAAC,CAACF,EAAH,CAAhB,GAAyBE,CAArD;AACD;;AAEDN,IAAAA,cAAc,CAACM,CAAC,CAACF,EAAH,CAAd,GAAuBE,CAAvB;AACD;;AAED,WAASG,aAAT,CAAuBnB,OAAvB,EAAgC;AAE9BW,IAAAA,gBAAgB,CAACX,OAAO,CAACc,EAAT,CAAhB,GAA+Bd,OAA/B;;AAEA,QAAIA,OAAO,CAACoB,SAAZ,EAAuB;AACrB;AACAR,MAAAA,mBAAmB,CAACZ,OAAO,CAACc,EAAT,CAAnB,GAAkCJ,cAAc,CAACV,OAAO,CAACc,EAAT,CAAd,GAA6Bd,OAA/D;AACD,KAHD,MAGO;AACL;AACAQ,MAAAA,SAAS,CAACR,OAAO,CAACc,EAAT,CAAT,GAAwBd,OAAxB,CAFK,CAIL;;AACAnB,MAAAA,OAAO,CAACmB,OAAO,CAACqB,QAAT,EAAmBN,gBAAnB,CAAP;AAEAlC,MAAAA,OAAO,CAACmB,OAAO,CAACsB,QAAT,EAAmBP,gBAAnB,CAAP,CAPK,CASL;;AACA,aAAOf,OAAO,CAACC,QAAf;AACD;AACF;;AAEDZ,EAAAA,WAAW,CAACN,QAAD,EAAWoC,aAAX,CAAX;AAEA,SAAO;AACLX,IAAAA,SAAS,EAAEA,SADN;AAELE,IAAAA,cAAc,EAAEA,cAFX;AAGLG,IAAAA,QAAQ,EAAEA,QAHL;AAILD,IAAAA,mBAAmB,EAAEA,mBAJhB;AAKLD,IAAAA,gBAAgB,EAAEA;AALb,GAAP;AAOD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASY,OAAT,CAAiBxC,QAAjB,EAA2ByC,aAA3B,EAA0C;AAE/CA,EAAAA,aAAa,GAAG,CAAC,CAACA,aAAlB;;AACA,MAAI,CAAChD,OAAO,CAACO,QAAD,CAAZ,EAAwB;AACtBA,IAAAA,QAAQ,GAAG,CAACA,QAAD,CAAX;AACD;;AAED,MAAI0C,IAAJ,EACIC,IADJ,EAEIC,IAFJ,EAGIC,IAHJ;AAKA/C,EAAAA,OAAO,CAACE,QAAD,EAAW,UAASiB,OAAT,EAAkB;AAElC;AACA,QAAI6B,IAAI,GAAG7B,OAAX;;AACA,QAAIA,OAAO,CAACoB,SAAR,IAAqB,CAACI,aAA1B,EAAyC;AACvCK,MAAAA,IAAI,GAAGN,OAAO,CAACvB,OAAO,CAACoB,SAAT,EAAoB,IAApB,CAAd;AACD;;AAED,QAAIU,CAAC,GAAGD,IAAI,CAACC,CAAb;AAAA,QACIC,CAAC,GAAGF,IAAI,CAACE,CADb;AAAA,QAEIC,MAAM,GAAGH,IAAI,CAACG,MAAL,IAAe,CAF5B;AAAA,QAGIC,KAAK,GAAGJ,IAAI,CAACI,KAAL,IAAc,CAH1B;;AAKA,QAAIH,CAAC,GAAGL,IAAJ,IAAYA,IAAI,KAAKS,SAAzB,EAAoC;AAClCT,MAAAA,IAAI,GAAGK,CAAP;AACD;;AACD,QAAIC,CAAC,GAAGL,IAAJ,IAAYA,IAAI,KAAKQ,SAAzB,EAAoC;AAClCR,MAAAA,IAAI,GAAGK,CAAP;AACD;;AAED,QAAKD,CAAC,GAAGG,KAAL,GAAcN,IAAd,IAAsBA,IAAI,KAAKO,SAAnC,EAA8C;AAC5CP,MAAAA,IAAI,GAAGG,CAAC,GAAGG,KAAX;AACD;;AACD,QAAKF,CAAC,GAAGC,MAAL,GAAeJ,IAAf,IAAuBA,IAAI,KAAKM,SAApC,EAA+C;AAC7CN,MAAAA,IAAI,GAAGG,CAAC,GAAGC,MAAX;AACD;AACF,GA1BM,CAAP;AA4BA,SAAO;AACLF,IAAAA,CAAC,EAAEL,IADE;AAELM,IAAAA,CAAC,EAAEL,IAFE;AAGLM,IAAAA,MAAM,EAAEJ,IAAI,GAAGF,IAHV;AAILO,IAAAA,KAAK,EAAEN,IAAI,GAAGF;AAJT,GAAP;AAMD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASU,mBAAT,CAA6BpD,QAA7B,EAAuC8C,IAAvC,EAA6C;AAElD,MAAIO,gBAAgB,GAAG,EAAvB;AAEAvD,EAAAA,OAAO,CAACE,QAAD,EAAW,UAASiB,OAAT,EAAkB;AAElC,QAAIhB,CAAC,GAAGgB,OAAR;;AAEA,QAAIhB,CAAC,CAACoC,SAAN,EAAiB;AACfpC,MAAAA,CAAC,GAAGuC,OAAO,CAACvC,CAAD,CAAX;AACD;;AAED,QAAI,CAACP,QAAQ,CAACoD,IAAI,CAACE,CAAN,CAAT,IAAsB/C,CAAC,CAAC8C,CAAF,GAAMD,IAAI,CAACC,CAArC,EAAyC;AACvCM,MAAAA,gBAAgB,CAACpC,OAAO,CAACc,EAAT,CAAhB,GAA+Bd,OAA/B;AACD;;AACD,QAAI,CAACvB,QAAQ,CAACoD,IAAI,CAACC,CAAN,CAAT,IAAsB9C,CAAC,CAAC+C,CAAF,GAAMF,IAAI,CAACE,CAArC,EAAyC;AACvCK,MAAAA,gBAAgB,CAACpC,OAAO,CAACc,EAAT,CAAhB,GAA+Bd,OAA/B;AACD;;AACD,QAAIhB,CAAC,CAAC8C,CAAF,GAAMD,IAAI,CAACC,CAAX,IAAgB9C,CAAC,CAAC+C,CAAF,GAAMF,IAAI,CAACE,CAA/B,EAAkC;AAChC,UAAItD,QAAQ,CAACoD,IAAI,CAACI,KAAN,CAAR,IAAwBxD,QAAQ,CAACoD,IAAI,CAACG,MAAN,CAAhC,IACAhD,CAAC,CAACiD,KAAF,GAAUjD,CAAC,CAAC8C,CAAZ,GAAgBD,IAAI,CAACI,KAAL,GAAaJ,IAAI,CAACC,CADlC,IAEA9C,CAAC,CAACgD,MAAF,GAAWhD,CAAC,CAAC+C,CAAb,GAAiBF,IAAI,CAACG,MAAL,GAAcH,IAAI,CAACE,CAFxC,EAE2C;AAEzCK,QAAAA,gBAAgB,CAACpC,OAAO,CAACc,EAAT,CAAhB,GAA+Bd,OAA/B;AACD,OALD,MAKO,IAAI,CAACvB,QAAQ,CAACoD,IAAI,CAACI,KAAN,CAAT,IAAyB,CAACxD,QAAQ,CAACoD,IAAI,CAACG,MAAN,CAAtC,EAAqD;AAC1DI,QAAAA,gBAAgB,CAACpC,OAAO,CAACc,EAAT,CAAhB,GAA+Bd,OAA/B;AACD;AACF;AACF,GAxBM,CAAP;AA0BA,SAAOoC,gBAAP;AACD;AAGD,OAAO,SAASC,OAAT,CAAiBrC,OAAjB,EAA0B;AAE/B,MAAI,eAAeA,OAAnB,EAA4B;AAC1B,WAAO,YAAP;AACD;;AAED,MAAI,OAAOA,OAAX,EAAoB;AAClB,WAAO,OAAP;AACD;;AAED,SAAO,MAAP;AACD,C,CAGD;;AAEA,SAASS,UAAT,CAAoB6B,IAApB,EAA0BC,IAA1B,EAAgC;AAC9B,SAAOhE,MAAM,CAAC,EAAD,EAAK+D,IAAI,IAAI,EAAb,EAAiBC,IAAI,IAAI,EAAzB,CAAb;AACD","sourcesContent":["import {\n  assign,\n  isArray,\n  isNumber,\n  isObject,\n  isUndefined,\n  groupBy,\n  forEach\n} from 'min-dash';\n\n\n/**\n * Adds an element to a collection and returns true if the\n * element was added.\n *\n * @param {Array<Object>} elements\n * @param {Object} e\n * @param {Boolean} unique\n */\nexport function add(elements, e, unique) {\n  var canAdd = !unique || elements.indexOf(e) === -1;\n\n  if (canAdd) {\n    elements.push(e);\n  }\n\n  return canAdd;\n}\n\n\n/**\n * Iterate over each element in a collection, calling the iterator function `fn`\n * with (element, index, recursionDepth).\n *\n * Recurse into all elements that are returned by `fn`.\n *\n * @param  {Object|Array<Object>} elements\n * @param  {Function} fn iterator function called with (element, index, recursionDepth)\n * @param  {Number} [depth] maximum recursion depth\n */\nexport function eachElement(elements, fn, depth) {\n\n  depth = depth || 0;\n\n  if (!isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  forEach(elements, function(s, i) {\n    var filter = fn(s, i, depth);\n\n    if (isArray(filter) && filter.length) {\n      eachElement(filter, fn, depth + 1);\n    }\n  });\n}\n\n\n/**\n * Collects self + child elements up to a given depth from a list of elements.\n *\n * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from\n * @param  {Boolean} unique whether to return a unique result set (no duplicates)\n * @param  {Number} maxDepth the depth to search through or -1 for infinite\n *\n * @return {Array<djs.model.Base>} found elements\n */\nexport function selfAndChildren(elements, unique, maxDepth) {\n  var result = [],\n      processedChildren = [];\n\n  eachElement(elements, function(element, i, depth) {\n    add(result, element, unique);\n\n    var children = element.children;\n\n    // max traversal depth not reached yet\n    if (maxDepth === -1 || depth < maxDepth) {\n\n      // children exist && children not yet processed\n      if (children && add(processedChildren, children, unique)) {\n        return children;\n      }\n    }\n  });\n\n  return result;\n}\n\n/**\n * Return self + direct children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {Boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nexport function selfAndDirectChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, 1);\n}\n\n\n/**\n * Return self + ALL children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {Boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nexport function selfAndAllChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, -1);\n}\n\n\n/**\n * Gets the the closure for all selected elements,\n * their enclosed children and connections.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {Boolean} [isTopLevel=true]\n * @param {Object} [existingClosure]\n *\n * @return {Object} newClosure\n */\nexport function getClosure(elements, isTopLevel, closure) {\n\n  if (isUndefined(isTopLevel)) {\n    isTopLevel = true;\n  }\n\n  if (isObject(isTopLevel)) {\n    closure = isTopLevel;\n    isTopLevel = true;\n  }\n\n\n  closure = closure || {};\n\n  var allShapes = copyObject(closure.allShapes),\n      allConnections = copyObject(closure.allConnections),\n      enclosedElements = copyObject(closure.enclosedElements),\n      enclosedConnections = copyObject(closure.enclosedConnections);\n\n  var topLevel = copyObject(\n    closure.topLevel,\n    isTopLevel && groupBy(elements, function(e) { return e.id; })\n  );\n\n\n  function handleConnection(c) {\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\n      topLevel[c.id] = [ c ];\n    }\n\n    // not enclosed as a child, but maybe logically\n    // (connecting two moved elements?)\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\n    }\n\n    allConnections[c.id] = c;\n  }\n\n  function handleElement(element) {\n\n    enclosedElements[element.id] = element;\n\n    if (element.waypoints) {\n      // remember connection\n      enclosedConnections[element.id] = allConnections[element.id] = element;\n    } else {\n      // remember shape\n      allShapes[element.id] = element;\n\n      // remember all connections\n      forEach(element.incoming, handleConnection);\n\n      forEach(element.outgoing, handleConnection);\n\n      // recurse into children\n      return element.children;\n    }\n  }\n\n  eachElement(elements, handleElement);\n\n  return {\n    allShapes: allShapes,\n    allConnections: allConnections,\n    topLevel: topLevel,\n    enclosedConnections: enclosedConnections,\n    enclosedElements: enclosedElements\n  };\n}\n\n/**\n * Returns the surrounding bbox for all elements in\n * the array or the element primitive.\n *\n * @param {Array<djs.model.Shape>|djs.model.Shape} elements\n * @param {Boolean} stopRecursion\n */\nexport function getBBox(elements, stopRecursion) {\n\n  stopRecursion = !!stopRecursion;\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n\n  var minX,\n      minY,\n      maxX,\n      maxY;\n\n  forEach(elements, function(element) {\n\n    // If element is a connection the bbox must be computed first\n    var bbox = element;\n    if (element.waypoints && !stopRecursion) {\n      bbox = getBBox(element.waypoints, true);\n    }\n\n    var x = bbox.x,\n        y = bbox.y,\n        height = bbox.height || 0,\n        width = bbox.width || 0;\n\n    if (x < minX || minX === undefined) {\n      minX = x;\n    }\n    if (y < minY || minY === undefined) {\n      minY = y;\n    }\n\n    if ((x + width) > maxX || maxX === undefined) {\n      maxX = x + width;\n    }\n    if ((y + height) > maxY || maxY === undefined) {\n      maxY = y + height;\n    }\n  });\n\n  return {\n    x: minX,\n    y: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n}\n\n\n/**\n * Returns all elements that are enclosed from the bounding box.\n *\n *   * If bbox.(width|height) is not specified the method returns\n *     all elements with element.x/y > bbox.x/y\n *   * If only bbox.x or bbox.y is specified, method return all elements with\n *     e.x > bbox.x or e.y > bbox.y\n *\n * @param {Array<djs.model.Shape>} elements List of Elements to search through\n * @param {djs.model.Shape} bbox the enclosing bbox.\n *\n * @return {Array<djs.model.Shape>} enclosed elements\n */\nexport function getEnclosedElements(elements, bbox) {\n\n  var filteredElements = {};\n\n  forEach(elements, function(element) {\n\n    var e = element;\n\n    if (e.waypoints) {\n      e = getBBox(e);\n    }\n\n    if (!isNumber(bbox.y) && (e.x > bbox.x)) {\n      filteredElements[element.id] = element;\n    }\n    if (!isNumber(bbox.x) && (e.y > bbox.y)) {\n      filteredElements[element.id] = element;\n    }\n    if (e.x > bbox.x && e.y > bbox.y) {\n      if (isNumber(bbox.width) && isNumber(bbox.height) &&\n          e.width + e.x < bbox.width + bbox.x &&\n          e.height + e.y < bbox.height + bbox.y) {\n\n        filteredElements[element.id] = element;\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\n        filteredElements[element.id] = element;\n      }\n    }\n  });\n\n  return filteredElements;\n}\n\n\nexport function getType(element) {\n\n  if ('waypoints' in element) {\n    return 'connection';\n  }\n\n  if ('x' in element) {\n    return 'shape';\n  }\n\n  return 'root';\n}\n\n\n// helpers ///////////////////////////////\n\nfunction copyObject(src1, src2) {\n  return assign({}, src1 || {}, src2 || {});\n}"]},"metadata":{},"sourceType":"module"}