{"ast":null,"code":"import inherits from 'inherits';\nimport { assign } from 'min-dash';\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\nimport { repairConnection, withoutRedundantPoints } from 'diagram-js/lib/layout/ManhattanLayout';\nimport { getMid, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport { is } from '../../util/ModelUtil';\nexport default function BpmnLayouter() {}\ninherits(BpmnLayouter, BaseLayouter);\n\nBpmnLayouter.prototype.layoutConnection = function (connection, hints) {\n  hints = hints || {};\n  var source = connection.source,\n      target = connection.target,\n      waypoints = connection.waypoints,\n      start = hints.connectionStart,\n      end = hints.connectionEnd;\n  var manhattanOptions, updatedWaypoints;\n\n  if (!start) {\n    start = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n\n  if (!end) {\n    end = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  } // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n\n  if (is(connection, 'bpmn:Association') || is(connection, 'bpmn:DataAssociation')) {\n    if (waypoints && !isCompensationAssociation(connection)) {\n      return [].concat([start], waypoints.slice(1, -1), [end]);\n    }\n  } // manhattan layout sequence / message flows\n\n\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target);\n  } else // layout all connection between flow elements h:h,\n    //\n    // except for\n    //\n    // (1) outgoing of BoundaryEvents -> layout based on attach orientation and target orientation\n    // (2) incoming / outgoing of Gateway -> v:h (outgoing), h:v (incoming)\n    // (3) loops from / to the same element\n    //\n    if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(connection)) {\n      if (source === target) {\n        manhattanOptions = {\n          preferredLayouts: ['b:l']\n        };\n      } else if (is(source, 'bpmn:BoundaryEvent')) {\n        manhattanOptions = {\n          preferredLayouts: getBoundaryEventPreferredLayouts(source, target)\n        };\n      } else if (is(source, 'bpmn:Gateway')) {\n        manhattanOptions = {\n          preferredLayouts: ['v:h']\n        };\n      } else if (is(target, 'bpmn:Gateway')) {\n        manhattanOptions = {\n          preferredLayouts: ['h:v']\n        };\n      } else {\n        manhattanOptions = {\n          preferredLayouts: ['h:h']\n        };\n      }\n    }\n\n  if (manhattanOptions) {\n    manhattanOptions = assign(manhattanOptions, hints);\n    updatedWaypoints = withoutRedundantPoints(repairConnection(source, target, start, end, waypoints, manhattanOptions));\n  }\n\n  return updatedWaypoints || [start, end];\n};\n\nfunction getAttachOrientation(attachedElement) {\n  var hostElement = attachedElement.host,\n      padding = -10;\n  return getOrientation(getMid(attachedElement), hostElement, padding);\n}\n\nfunction getMessageFlowManhattanOptions(source, target) {\n  return {\n    preferredLayouts: ['straight', 'v:v'],\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\n\nfunction getMessageFlowPreserveDocking(source, target) {\n  // (1) docking element connected to participant has precedence\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  } // (2) docking element connected to expanded sub-process has precedence\n\n\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  } // (3) docking event has precedence\n\n\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n\n  return null;\n}\n\nfunction getConnectionDocking(point, shape) {\n  return point ? point.original || point : getMid(shape);\n}\n\nfunction isCompensationAssociation(connection) {\n  var source = connection.source,\n      target = connection.target;\n  return is(target, 'bpmn:Activity') && is(source, 'bpmn:BoundaryEvent') && target.businessObject.isForCompensation;\n}\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\n\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\n\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n  return matches && matches[0];\n}\n\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n  return matches && matches[0];\n}\n\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\n\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\n\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\n\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\n\nfunction getBoundaryEventPreferredLayouts(source, target) {\n  var sourceMid = getMid(source),\n      targetMid = getMid(target),\n      attachOrientation = getAttachOrientation(source),\n      sourceLayout,\n      targetLayout;\n  var isLoop = isSame(source.host, target);\n  var attachedToSide = isAnyOrientation(attachOrientation, ['top', 'right', 'bottom', 'left']);\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  }); // source layout\n\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isLoop); // target layout\n\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isLoop);\n  return [sourceLayout + ':' + targetLayout];\n}\n\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isLoop) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[attachOrientation];\n  } // attached to either top-right, top-left, bottom-right or bottom-left corner\n  // loop, same vertical or opposite horizontal orientation\n\n\n  if (isLoop || isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) || isOppositeOrientation(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {\n    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];\n  } // fallback\n\n\n  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];\n}\n\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isLoop) {\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      // orientation is 'right' or 'left'\n      // loop or opposite horizontal orientation or same orientation\n      if (isLoop || isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'h';\n      } // fallback\n\n\n      return 'v';\n    } else {\n      // orientation is 'top' or 'bottom'\n      // loop or opposite vertical orientation or same orientation\n      if (isLoop || isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {\n        return 'v';\n      } // fallback\n\n\n      return 'h';\n    }\n  } // attached to either top-right, top-left, bottom-right or bottom-left corner\n  // orientation is 'right', 'left'\n  // or same vertical orientation but also 'right' or 'left'\n\n\n  if (isHorizontalOrientation(targetOrientation) || isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) && getHorizontalOrientation(targetOrientation)) {\n    return 'h';\n  } else {\n    return 'v';\n  }\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js"],"names":["inherits","assign","BaseLayouter","repairConnection","withoutRedundantPoints","getMid","getOrientation","isExpanded","is","BpmnLayouter","prototype","layoutConnection","connection","hints","source","target","waypoints","start","connectionStart","end","connectionEnd","manhattanOptions","updatedWaypoints","getConnectionDocking","length","isCompensationAssociation","concat","slice","getMessageFlowManhattanOptions","preferredLayouts","getBoundaryEventPreferredLayouts","getAttachOrientation","attachedElement","hostElement","host","padding","preserveDocking","getMessageFlowPreserveDocking","isExpandedSubProcess","point","shape","original","businessObject","isForCompensation","element","isSame","a","b","isAnyOrientation","orientation","orientations","indexOf","oppositeOrientationMapping","orientationDirectionMapping","top","right","bottom","left","getHorizontalOrientation","matches","exec","getVerticalOrientation","isOppositeOrientation","isOppositeHorizontalOrientation","horizontalOrientation","oppositeHorizontalOrientation","isOppositeVerticalOrientation","verticalOrientation","oppositeVerticalOrientation","isHorizontalOrientation","sourceMid","targetMid","attachOrientation","sourceLayout","targetLayout","isLoop","attachedToSide","targetOrientation","x","width","y","height","getBoundaryEventSourceLayout","getBoundaryEventTargetLayout"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport {\n  assign\n} from 'min-dash';\n\nimport BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';\n\nimport {\n  repairConnection,\n  withoutRedundantPoints\n} from 'diagram-js/lib/layout/ManhattanLayout';\n\nimport {\n  getMid,\n  getOrientation\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  isExpanded\n} from '../../util/DiUtil';\n\nimport { is } from '../../util/ModelUtil';\n\n\nexport default function BpmnLayouter() {}\n\ninherits(BpmnLayouter, BaseLayouter);\n\n\nBpmnLayouter.prototype.layoutConnection = function(connection, hints) {\n  hints = hints || {};\n\n  var source = connection.source,\n      target = connection.target,\n      waypoints = connection.waypoints,\n      start = hints.connectionStart,\n      end = hints.connectionEnd;\n\n  var manhattanOptions,\n      updatedWaypoints;\n\n  if (!start) {\n    start = getConnectionDocking(waypoints && waypoints[0], source);\n  }\n\n  if (!end) {\n    end = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);\n  }\n\n  // TODO(nikku): support vertical modeling\n  // and invert preferredLayouts accordingly\n\n  if (is(connection, 'bpmn:Association') ||\n      is(connection, 'bpmn:DataAssociation')) {\n\n    if (waypoints && !isCompensationAssociation(connection)) {\n      return [].concat([ start ], waypoints.slice(1, -1), [ end ]);\n    }\n  }\n\n  // manhattan layout sequence / message flows\n  if (is(connection, 'bpmn:MessageFlow')) {\n    manhattanOptions = getMessageFlowManhattanOptions(source, target);\n\n  } else\n\n\n  // layout all connection between flow elements h:h,\n  //\n  // except for\n  //\n  // (1) outgoing of BoundaryEvents -> layout based on attach orientation and target orientation\n  // (2) incoming / outgoing of Gateway -> v:h (outgoing), h:v (incoming)\n  // (3) loops from / to the same element\n  //\n  if (is(connection, 'bpmn:SequenceFlow') ||\n      isCompensationAssociation(connection)) {\n\n    if (source === target) {\n      manhattanOptions = {\n        preferredLayouts: [ 'b:l' ]\n      };\n    } else\n\n    if (is(source, 'bpmn:BoundaryEvent')) {\n\n      manhattanOptions = {\n        preferredLayouts: getBoundaryEventPreferredLayouts(source, target)\n      };\n\n    } else\n\n    if (is(source, 'bpmn:Gateway')) {\n\n      manhattanOptions = {\n        preferredLayouts: [ 'v:h' ]\n      };\n    } else\n\n    if (is(target, 'bpmn:Gateway')) {\n\n      manhattanOptions = {\n        preferredLayouts: [ 'h:v' ]\n      };\n    }\n\n    else {\n      manhattanOptions = {\n        preferredLayouts: [ 'h:h' ]\n      };\n    }\n\n  }\n\n  if (manhattanOptions) {\n\n    manhattanOptions = assign(manhattanOptions, hints);\n\n    updatedWaypoints =\n      withoutRedundantPoints(\n        repairConnection(\n          source, target,\n          start, end,\n          waypoints,\n          manhattanOptions\n        )\n      );\n  }\n\n  return updatedWaypoints || [ start, end ];\n};\n\n\nfunction getAttachOrientation(attachedElement) {\n\n  var hostElement = attachedElement.host,\n      padding = -10;\n\n  return getOrientation(getMid(attachedElement), hostElement, padding);\n}\n\n\nfunction getMessageFlowManhattanOptions(source, target) {\n  return {\n    preferredLayouts: [ 'straight', 'v:v' ],\n    preserveDocking: getMessageFlowPreserveDocking(source, target)\n  };\n}\n\n\nfunction getMessageFlowPreserveDocking(source, target) {\n\n  // (1) docking element connected to participant has precedence\n\n  if (is(target, 'bpmn:Participant')) {\n    return 'source';\n  }\n\n  if (is(source, 'bpmn:Participant')) {\n    return 'target';\n  }\n\n  // (2) docking element connected to expanded sub-process has precedence\n\n  if (isExpandedSubProcess(target)) {\n    return 'source';\n  }\n\n  if (isExpandedSubProcess(source)) {\n    return 'target';\n  }\n\n  // (3) docking event has precedence\n\n  if (is(target, 'bpmn:Event')) {\n    return 'target';\n  }\n\n  if (is(source, 'bpmn:Event')) {\n    return 'source';\n  }\n\n  return null;\n}\n\n\nfunction getConnectionDocking(point, shape) {\n  return point ? (point.original || point) : getMid(shape);\n}\n\nfunction isCompensationAssociation(connection) {\n\n  var source = connection.source,\n      target = connection.target;\n\n  return is(target, 'bpmn:Activity') &&\n         is(source, 'bpmn:BoundaryEvent') &&\n         target.businessObject.isForCompensation;\n}\n\n\nfunction isExpandedSubProcess(element) {\n  return is(element, 'bpmn:SubProcess') && isExpanded(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction isAnyOrientation(orientation, orientations) {\n  return orientations.indexOf(orientation) !== -1;\n}\n\nvar oppositeOrientationMapping = {\n  'top': 'bottom',\n  'top-right': 'bottom-left',\n  'top-left': 'bottom-right',\n  'right': 'left',\n  'bottom': 'top',\n  'bottom-right': 'top-left',\n  'bottom-left': 'top-right',\n  'left': 'right'\n};\n\nvar orientationDirectionMapping = {\n  top: 't',\n  right: 'r',\n  bottom: 'b',\n  left: 'l'\n};\n\nfunction getHorizontalOrientation(orientation) {\n  var matches = /right|left/.exec(orientation);\n\n  return matches && matches[0];\n}\n\nfunction getVerticalOrientation(orientation) {\n  var matches = /top|bottom/.exec(orientation);\n\n  return matches && matches[0];\n}\n\nfunction isOppositeOrientation(a, b) {\n  return oppositeOrientationMapping[a] === b;\n}\n\nfunction isOppositeHorizontalOrientation(a, b) {\n  var horizontalOrientation = getHorizontalOrientation(a);\n\n  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];\n\n  return b.indexOf(oppositeHorizontalOrientation) !== -1;\n}\n\nfunction isOppositeVerticalOrientation(a, b) {\n  var verticalOrientation = getVerticalOrientation(a);\n\n  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];\n\n  return b.indexOf(oppositeVerticalOrientation) !== -1;\n}\n\nfunction isHorizontalOrientation(orientation) {\n  return orientation === 'right' || orientation === 'left';\n}\n\nfunction getBoundaryEventPreferredLayouts(source, target) {\n  var sourceMid = getMid(source),\n      targetMid = getMid(target),\n      attachOrientation = getAttachOrientation(source),\n      sourceLayout,\n      targetLayout;\n\n  var isLoop = isSame(source.host, target);\n\n  var attachedToSide = isAnyOrientation(attachOrientation, [ 'top', 'right', 'bottom', 'left' ]);\n\n  var targetOrientation = getOrientation(targetMid, sourceMid, {\n    x: source.width / 2 + target.width / 2,\n    y: source.height / 2 + target.height / 2\n  });\n\n  // source layout\n  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isLoop);\n\n  // target layout\n  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isLoop);\n\n  return [ sourceLayout + ':' + targetLayout ];\n}\n\nfunction getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isLoop) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    return orientationDirectionMapping[attachOrientation];\n  }\n\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // loop, same vertical or opposite horizontal orientation\n  if (isLoop ||\n    isSame(\n      getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)\n    ) ||\n    isOppositeOrientation(\n      getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation)\n    )) {\n    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];\n  }\n\n  // fallback\n  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];\n}\n\nfunction getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isLoop) {\n\n  // attached to either top, right, bottom or left side\n  if (attachedToSide) {\n    if (isHorizontalOrientation(attachOrientation)) {\n      // orientation is 'right' or 'left'\n\n      // loop or opposite horizontal orientation or same orientation\n      if (\n        isLoop ||\n        isOppositeHorizontalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'h';\n      }\n\n      // fallback\n      return 'v';\n    } else {\n      // orientation is 'top' or 'bottom'\n\n      // loop or opposite vertical orientation or same orientation\n      if (\n        isLoop ||\n        isOppositeVerticalOrientation(attachOrientation, targetOrientation) ||\n        isSame(attachOrientation, targetOrientation)\n      ) {\n        return 'v';\n      }\n\n      // fallback\n      return 'h';\n    }\n  }\n  // attached to either top-right, top-left, bottom-right or bottom-left corner\n\n  // orientation is 'right', 'left'\n  // or same vertical orientation but also 'right' or 'left'\n  if (isHorizontalOrientation(targetOrientation) ||\n    (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) &&\n      getHorizontalOrientation(targetOrientation))) {\n    return 'h';\n  } else {\n    return 'v';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}