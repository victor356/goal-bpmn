{"ast":null,"code":"'use strict';\n/**\n * An empty collection stub. Use {@link RefsCollection.extend} to extend a\n * collection with ref semantics.\n *\n * @class RefsCollection\n */\n\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @memberof RefsCollection\n * @static\n *\n * @param  {Array<Object>} collection\n * @param  {Refs} refs instance\n * @param  {Object} property represented by the collection\n * @param  {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\n\nfunction extend(collection, refs, property, target) {\n  var inverseProperty = property.inverse;\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n\n  Object.defineProperty(collection, 'remove', {\n    value: function (element) {\n      var idx = this.indexOf(element);\n\n      if (idx !== -1) {\n        this.splice(idx, 1); // unset inverse\n\n        refs.unset(element, inverseProperty, target);\n      }\n\n      return element;\n    }\n  });\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n\n  Object.defineProperty(collection, 'contains', {\n    value: function (element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n\n  Object.defineProperty(collection, 'add', {\n    value: function (element, idx) {\n      var currentIdx = this.indexOf(element);\n\n      if (typeof idx === 'undefined') {\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        } // add to end of array, as no idx is specified\n\n\n        idx = this.length;\n      } // handle already in collection\n\n\n      if (currentIdx !== -1) {\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      } // add element at idx\n\n\n      this.splice(idx, 0, element);\n\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  }); // a simple marker, identifying this element\n  // as being a refs collection\n\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n  return collection;\n}\n\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nmodule.exports.extend = extend;\nmodule.exports.isExtended = isExtended;","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/object-refs/lib/collection.js"],"names":["extend","collection","refs","property","target","inverseProperty","inverse","Object","defineProperty","value","element","idx","indexOf","splice","unset","currentIdx","length","set","isExtended","__refs_collection","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,MAAT,CAAgBC,UAAhB,EAA4BC,IAA5B,EAAkCC,QAAlC,EAA4CC,MAA5C,EAAoD;AAElD,MAAIC,eAAe,GAAGF,QAAQ,CAACG,OAA/B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACEC,EAAAA,MAAM,CAACC,cAAP,CAAsBP,UAAtB,EAAkC,QAAlC,EAA4C;AAC1CQ,IAAAA,KAAK,EAAE,UAASC,OAAT,EAAkB;AACvB,UAAIC,GAAG,GAAG,KAAKC,OAAL,CAAaF,OAAb,CAAV;;AACA,UAAIC,GAAG,KAAK,CAAC,CAAb,EAAgB;AACd,aAAKE,MAAL,CAAYF,GAAZ,EAAiB,CAAjB,EADc,CAGd;;AACAT,QAAAA,IAAI,CAACY,KAAL,CAAWJ,OAAX,EAAoBL,eAApB,EAAqCD,MAArC;AACD;;AAED,aAAOM,OAAP;AACD;AAXyC,GAA5C;AAcA;AACF;AACA;AACA;AACA;AACA;AACA;;AACEH,EAAAA,MAAM,CAACC,cAAP,CAAsBP,UAAtB,EAAkC,UAAlC,EAA8C;AAC5CQ,IAAAA,KAAK,EAAE,UAASC,OAAT,EAAkB;AACvB,aAAO,KAAKE,OAAL,CAAaF,OAAb,MAA0B,CAAC,CAAlC;AACD;AAH2C,GAA9C;AAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACEH,EAAAA,MAAM,CAACC,cAAP,CAAsBP,UAAtB,EAAkC,KAAlC,EAAyC;AACvCQ,IAAAA,KAAK,EAAE,UAASC,OAAT,EAAkBC,GAAlB,EAAuB;AAE5B,UAAII,UAAU,GAAG,KAAKH,OAAL,CAAaF,OAAb,CAAjB;;AAEA,UAAI,OAAOC,GAAP,KAAe,WAAnB,EAAgC;AAE9B,YAAII,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrB;AACA;AACD,SAL6B,CAO9B;;;AACAJ,QAAAA,GAAG,GAAG,KAAKK,MAAX;AACD,OAb2B,CAe5B;;;AACA,UAAID,UAAU,KAAK,CAAC,CAApB,EAAuB;AAErB;AACA,aAAKF,MAAL,CAAYE,UAAZ,EAAwB,CAAxB;AACD,OApB2B,CAsB5B;;;AACA,WAAKF,MAAL,CAAYF,GAAZ,EAAiB,CAAjB,EAAoBD,OAApB;;AAEA,UAAIK,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrB;AACA;AACAb,QAAAA,IAAI,CAACe,GAAL,CAASP,OAAT,EAAkBL,eAAlB,EAAmCD,MAAnC;AACD;AACF;AA/BsC,GAAzC,EA/CkD,CAiFlD;AACA;;AACAG,EAAAA,MAAM,CAACC,cAAP,CAAsBP,UAAtB,EAAkC,mBAAlC,EAAuD;AACrDQ,IAAAA,KAAK,EAAE;AAD8C,GAAvD;AAIA,SAAOR,UAAP;AACD;;AAGD,SAASiB,UAAT,CAAoBjB,UAApB,EAAgC;AAC9B,SAAOA,UAAU,CAACkB,iBAAX,KAAiC,IAAxC;AACD;;AAEDC,MAAM,CAACC,OAAP,CAAerB,MAAf,GAAwBA,MAAxB;AAEAoB,MAAM,CAACC,OAAP,CAAeH,UAAf,GAA4BA,UAA5B","sourcesContent":["'use strict';\n\n/**\n * An empty collection stub. Use {@link RefsCollection.extend} to extend a\n * collection with ref semantics.\n *\n * @class RefsCollection\n */\n\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @memberof RefsCollection\n * @static\n *\n * @param  {Array<Object>} collection\n * @param  {Refs} refs instance\n * @param  {Object} property represented by the collection\n * @param  {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function(element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function(element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function(element, idx) {\n\n      var currentIdx = this.indexOf(element);\n\n      if (typeof idx === 'undefined') {\n\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n\n  return collection;\n}\n\n\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nmodule.exports.extend = extend;\n\nmodule.exports.isExtended = isExtended;"]},"metadata":{},"sourceType":"script"}