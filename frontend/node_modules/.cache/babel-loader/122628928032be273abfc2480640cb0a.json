{"ast":null,"code":"import { forEach, find, assign } from 'min-dash';\nimport { Parser as SaxParser } from 'saxen';\nimport Moddle from 'moddle';\nimport { parseName as parseNameNs } from 'moddle/lib/ns';\nimport { coerceType, isSimple as isSimpleType } from 'moddle/lib/types';\nimport { XSI_TYPE, serializeAsType, hasLowerCaseAlias } from './common';\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction aliasToName(aliasNs, pkg) {\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\nfunction prefixedToName(nameNs, pkg) {\n  var name = nameNs.name,\n      localName = nameNs.localName;\n  var typePrefix = pkg.xml && pkg.xml.typePrefix;\n\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\n\nfunction normalizeXsiTypeName(name, model) {\n  var nameNs = parseNameNs(name);\n  var pkg = model.getPackage(nameNs.prefix);\n  return prefixedToName(nameNs, pkg);\n}\n\nfunction error(message) {\n  return new Error(message);\n}\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\n\n\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\nfunction defer(fn) {\n  setTimeout(fn, 0);\n}\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\n\n\nexport function Context(options) {\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n  assign(this, options);\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n\n  this.addReference = function (reference) {\n    this.references.push(reference);\n  };\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n\n\n  this.addElement = function (element) {\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n    var descriptor = getModdleDescriptor(element);\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n\n\n  this.addWarning = function (warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function () {};\n\nBaseHandler.prototype.handleText = function () {};\n\nBaseHandler.prototype.handleNode = function () {};\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\n\n\nfunction NoopHandler() {}\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function () {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function (text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function (node) {\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function () {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function (node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function () {\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n  value = coerceType(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function (node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n/**\n * @class Reader.ElementHandler\n *\n */\n\n\nexport function ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function (reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleText = function (text) {\n  var element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n\n  BodyHandler.prototype.handleText.call(this, text);\n};\n\nElementHandler.prototype.handleEnd = function () {\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\n\n\nElementHandler.prototype.createElement = function (node) {\n  var attributes = node.attributes,\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({}),\n      model = this.model,\n      propNameNs;\n  forEach(attributes, function (value, name) {\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n        forEach(values, function (v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else if (name !== 'xmlns') {\n        propNameNs = parseNameNs(name, descriptor.ns.prefix); // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n\n        if (model.getPackage(propNameNs.prefix)) {\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n\n      instance.set(name, value);\n    }\n  });\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function (node) {\n  var name = node.name;\n  var nameNs = parseNameNs(name);\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName],\n      elementTypeName,\n      elementType; // search for properties by name first\n\n  if (property) {\n    if (serializeAsType(property)) {\n      elementTypeName = node.attributes[XSI_TYPE]; // xsi type is optional, if it does not exists the\n      // default type is assumed\n\n      if (elementTypeName) {\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\"\n        elementTypeName = normalizeXsiTypeName(elementTypeName, model);\n        elementType = model.getType(elementTypeName);\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    } // search for properties by name first\n\n\n    return property;\n  }\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    elementTypeName = aliasToName(nameNs, pkg);\n    elementType = model.getType(elementTypeName); // search for collection members later\n\n    property = find(descriptor.properties, function (p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function (p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function () {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function (propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function (propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function (type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\n\n\nElementHandler.prototype.handleChild = function (node) {\n  var propertyDesc, type, element, childHandler;\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element; // child handles may decide to skip elements\n  // by not returning anything\n\n  if (newElement !== undefined) {\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n      this.context.addReference(newElement);\n    } else {\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\n\n\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\n\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\nRootElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n      nameNs = parseNameNs(name),\n      model = this.model,\n      type = this.type,\n      pkg = model.getPackage(nameNs.prefix),\n      typeName = pkg && aliasToName(nameNs, pkg) || name; // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n\n  return ElementHandler.prototype.createElement.call(this, node);\n};\n\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n      ns = parseNameNs(name),\n      prefix = ns.prefix,\n      uri = node.ns[prefix + '$uri'],\n      attributes = node.attributes;\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function (node) {\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement); // establish child -> parent relationship\n\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleEnd = function () {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\n\n\nexport function Reader(options) {\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  assign(this, {\n    lax: false\n  }, options);\n}\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n * @param  {Function} done\n */\n\nReader.prototype.fromXML = function (xml, options, done) {\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n  var context = new Context(assign({}, options, {\n    rootHandler: rootHandler\n  })),\n      parser = new SaxParser({\n    proxy: true\n  }),\n      stack = createStack();\n  rootHandler.context = context; // push root handler\n\n  stack.push(rootHandler);\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n\n  function handleError(err, getContext, lax) {\n    var ctx = getContext();\n    var line = ctx.line,\n        column = ctx.column,\n        data = ctx.data; // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n\n    var message = 'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' + 'line: ' + line + '\\n\\t' + 'column: ' + column + '\\n\\t' + 'nested error: ' + err.message;\n\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n\n  function handleWarning(err, getContext) {\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n  /**\n   * Resolve collected references on parse end.\n   */\n\n\n  function resolveReferences() {\n    var elementsById = context.elementsById;\n    var references = context.references;\n    var i, r;\n\n    for (i = 0; r = references[i]; i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r); // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n  var UTF_8_PATTERN = /^utf-8$/i;\n\n  function handleQuestion(question) {\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n\n    context.addWarning({\n      message: 'unsupported document encoding <' + encoding + '>, ' + 'falling back to UTF-8'\n    });\n  }\n\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n\n  function handleCData(text, getContext) {\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n\n  function handleText(text, getContext) {\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n    text = text.trim();\n\n    if (!text) {\n      return;\n    }\n\n    handleCData(text, getContext);\n  }\n\n  var uriMap = model.getPackages().reduce(function (uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n    return uriMap;\n  }, {});\n  parser.ns(uriMap).on('openTag', function (obj, decodeStr, selfClosing, getContext) {\n    // gracefully handle unparsable attributes (attrs=false)\n    var attrs = obj.attrs || {};\n    var decodedAttrs = Object.keys(attrs).reduce(function (d, key) {\n      var value = decodeStr(attrs[key]);\n      d[key] = value;\n      return d;\n    }, {});\n    var node = {\n      name: obj.name,\n      originalName: obj.originalName,\n      attributes: decodedAttrs,\n      ns: obj.ns\n    };\n    handleOpen(node, getContext);\n  }).on('question', handleQuestion).on('closeTag', handleClose).on('cdata', handleCData).on('text', function (text, decodeEntities, getContext) {\n    handleText(decodeEntities(text), getContext);\n  }).on('error', handleError).on('warn', handleWarning); // deferred parse XML to make loading really ascnchronous\n  // this ensures the execution environment (node or browser)\n  // is kept responsive and that certain optimization strategies\n  // can kick in\n\n  defer(function () {\n    var err;\n\n    try {\n      parser.parse(xml);\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n\n    var element = rootHandler.element; // handle the situation that we could not extract\n    // the desired root element from the document\n\n    if (!err && !element) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n\n    done(err, err ? undefined : element, context);\n  });\n};\n\nReader.prototype.handler = function (name) {\n  return new RootElementHandler(this.model, name);\n}; // helpers //////////////////////////\n\n\nfunction createStack() {\n  var stack = [];\n  Object.defineProperty(stack, 'peek', {\n    value: function () {\n      return this[this.length - 1];\n    }\n  });\n  return stack;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/moddle-xml/lib/read.js"],"names":["forEach","find","assign","Parser","SaxParser","Moddle","parseName","parseNameNs","coerceType","isSimple","isSimpleType","XSI_TYPE","serializeAsType","hasLowerCaseAlias","capitalize","str","charAt","toUpperCase","slice","aliasToName","aliasNs","pkg","name","prefix","localName","prefixedToName","nameNs","typePrefix","xml","indexOf","length","normalizeXsiTypeName","model","getPackage","error","message","Error","getModdleDescriptor","element","$descriptor","defer","fn","setTimeout","Context","options","elementsById","references","warnings","addReference","reference","push","addElement","descriptor","idProperty","id","get","test","addWarning","warning","BaseHandler","prototype","handleEnd","handleText","handleNode","NoopHandler","Object","create","BodyHandler","text","body","ReferenceHandler","property","context","node","createReference","ns","ValueHandler","propertyDesc","value","type","isMany","set","BaseElementHandler","parser","createElement","handleChild","ElementHandler","typeName","getType","bodyProperty","call","undefined","attributes","Type","instance","propNameNs","prop","propertiesByName","values","isReference","split","v","getPropertyForNode","propertyName","elementTypeName","elementType","effectiveType","properties","p","isVirtual","isAttribute","hasType","toString","valueHandler","referenceHandler","handler","GenericElementHandler","childHandler","newElement","$parent","RootElementHandler","originalName","uri","createAny","children","$children","$body","Reader","lax","fromXML","done","rootHandler","proxy","stack","createStack","handleError","err","getContext","ctx","line","column","data","handleWarning","resolveReferences","i","r","collection","idx","splice","handleClose","pop","PREAMBLE_START_PATTERN","ENCODING_PATTERN","UTF_8_PATTERN","handleQuestion","question","match","exec","encoding","handleOpen","peek","handleCData","trim","uriMap","getPackages","reduce","on","obj","decodeStr","selfClosing","attrs","decodedAttrs","keys","d","key","decodeEntities","parse","e","defineProperty"],"mappings":"AAAA,SACEA,OADF,EAEEC,IAFF,EAGEC,MAHF,QAIO,UAJP;AAMA,SACEC,MAAM,IAAIC,SADZ,QAEO,OAFP;AAIA,OAAOC,MAAP,MAAmB,QAAnB;AACA,SACEC,SAAS,IAAIC,WADf,QAEO,eAFP;AAIA,SACEC,UADF,EAEEC,QAAQ,IAAIC,YAFd,QAGO,kBAHP;AAKA,SACEC,QADF,EAEEC,eAFF,EAGEC,iBAHF,QAIO,UAJP;;AAMA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;AACvB,SAAOA,GAAG,CAACC,MAAJ,CAAW,CAAX,EAAcC,WAAd,KAA8BF,GAAG,CAACG,KAAJ,CAAU,CAAV,CAArC;AACD;;AAED,SAASC,WAAT,CAAqBC,OAArB,EAA8BC,GAA9B,EAAmC;AAEjC,MAAI,CAACR,iBAAiB,CAACQ,GAAD,CAAtB,EAA6B;AAC3B,WAAOD,OAAO,CAACE,IAAf;AACD;;AAED,SAAOF,OAAO,CAACG,MAAR,GAAiB,GAAjB,GAAuBT,UAAU,CAACM,OAAO,CAACI,SAAT,CAAxC;AACD;;AAED,SAASC,cAAT,CAAwBC,MAAxB,EAAgCL,GAAhC,EAAqC;AAEnC,MAAIC,IAAI,GAAGI,MAAM,CAACJ,IAAlB;AAAA,MACIE,SAAS,GAAGE,MAAM,CAACF,SADvB;AAGA,MAAIG,UAAU,GAAGN,GAAG,CAACO,GAAJ,IAAWP,GAAG,CAACO,GAAJ,CAAQD,UAApC;;AAEA,MAAIA,UAAU,IAAIH,SAAS,CAACK,OAAV,CAAkBF,UAAlB,MAAkC,CAApD,EAAuD;AACrD,WAAOD,MAAM,CAACH,MAAP,GAAgB,GAAhB,GAAsBC,SAAS,CAACN,KAAV,CAAgBS,UAAU,CAACG,MAA3B,CAA7B;AACD,GAFD,MAEO;AACL,WAAOR,IAAP;AACD;AACF;;AAED,SAASS,oBAAT,CAA8BT,IAA9B,EAAoCU,KAApC,EAA2C;AAEzC,MAAIN,MAAM,GAAGnB,WAAW,CAACe,IAAD,CAAxB;AACA,MAAID,GAAG,GAAGW,KAAK,CAACC,UAAN,CAAiBP,MAAM,CAACH,MAAxB,CAAV;AAEA,SAAOE,cAAc,CAACC,MAAD,EAASL,GAAT,CAArB;AACD;;AAED,SAASa,KAAT,CAAeC,OAAf,EAAwB;AACtB,SAAO,IAAIC,KAAJ,CAAUD,OAAV,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,mBAAT,CAA6BC,OAA7B,EAAsC;AACpC,SAAOA,OAAO,CAACC,WAAf;AACD;;AAED,SAASC,KAAT,CAAeC,EAAf,EAAmB;AACjBC,EAAAA,UAAU,CAACD,EAAD,EAAK,CAAL,CAAV;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASE,OAAT,CAAiBC,OAAjB,EAA0B;AAE/B;AACF;AACA;;AAEE;AACF;AACA;AAEE1C,EAAAA,MAAM,CAAC,IAAD,EAAO0C,OAAP,CAAN;AAEA,OAAKC,YAAL,GAAoB,EAApB;AACA,OAAKC,UAAL,GAAkB,EAAlB;AACA,OAAKC,QAAL,GAAgB,EAAhB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoB,UAASC,SAAT,EAAoB;AACtC,SAAKH,UAAL,CAAgBI,IAAhB,CAAqBD,SAArB;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKE,UAAL,GAAkB,UAASb,OAAT,EAAkB;AAElC,QAAI,CAACA,OAAL,EAAc;AACZ,YAAMJ,KAAK,CAAC,kBAAD,CAAX;AACD;;AAED,QAAIW,YAAY,GAAG,KAAKA,YAAxB;AAEA,QAAIO,UAAU,GAAGf,mBAAmB,CAACC,OAAD,CAApC;AAEA,QAAIe,UAAU,GAAGD,UAAU,CAACC,UAA5B;AAAA,QACIC,EADJ;;AAGA,QAAID,UAAJ,EAAgB;AACdC,MAAAA,EAAE,GAAGhB,OAAO,CAACiB,GAAR,CAAYF,UAAU,CAAC/B,IAAvB,CAAL;;AAEA,UAAIgC,EAAJ,EAAQ;AACN;AACA,YAAI,CAAC,mCAAmCE,IAAnC,CAAwCF,EAAxC,CAAL,EAAkD;AAChD,gBAAM,IAAIlB,KAAJ,CAAU,iBAAiBkB,EAAjB,GAAsB,GAAhC,CAAN;AACD;;AAED,YAAIT,YAAY,CAACS,EAAD,CAAhB,EAAsB;AACpB,gBAAMpB,KAAK,CAAC,mBAAmBoB,EAAnB,GAAwB,GAAzB,CAAX;AACD;;AAEDT,QAAAA,YAAY,CAACS,EAAD,CAAZ,GAAmBhB,OAAnB;AACD;AACF;AACF,GA7BD;AA+BA;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,OAAKmB,UAAL,GAAkB,UAASC,OAAT,EAAkB;AAClC,SAAKX,QAAL,CAAcG,IAAd,CAAmBQ,OAAnB;AACD,GAFD;AAGD;;AAED,SAASC,WAAT,GAAuB,CAAE;;AAEzBA,WAAW,CAACC,SAAZ,CAAsBC,SAAtB,GAAkC,YAAW,CAAE,CAA/C;;AACAF,WAAW,CAACC,SAAZ,CAAsBE,UAAtB,GAAmC,YAAW,CAAE,CAAhD;;AACAH,WAAW,CAACC,SAAZ,CAAsBG,UAAtB,GAAmC,YAAW,CAAE,CAAhD;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,WAAT,GAAuB,CAAG;;AAE1BA,WAAW,CAACJ,SAAZ,GAAwBK,MAAM,CAACC,MAAP,CAAcP,WAAW,CAACC,SAA1B,CAAxB;;AAEAI,WAAW,CAACJ,SAAZ,CAAsBG,UAAtB,GAAmC,YAAW;AAC5C,SAAO,IAAP;AACD,CAFD;;AAIA,SAASI,WAAT,GAAuB,CAAE;;AAEzBA,WAAW,CAACP,SAAZ,GAAwBK,MAAM,CAACC,MAAP,CAAcP,WAAW,CAACC,SAA1B,CAAxB;;AAEAO,WAAW,CAACP,SAAZ,CAAsBE,UAAtB,GAAmC,UAASM,IAAT,EAAe;AAChD,OAAKC,IAAL,GAAY,CAAC,KAAKA,IAAL,IAAa,EAAd,IAAoBD,IAAhC;AACD,CAFD;;AAIA,SAASE,gBAAT,CAA0BC,QAA1B,EAAoCC,OAApC,EAA6C;AAC3C,OAAKD,QAAL,GAAgBA,QAAhB;AACA,OAAKC,OAAL,GAAeA,OAAf;AACD;;AAEDF,gBAAgB,CAACV,SAAjB,GAA6BK,MAAM,CAACC,MAAP,CAAcC,WAAW,CAACP,SAA1B,CAA7B;;AAEAU,gBAAgB,CAACV,SAAjB,CAA2BG,UAA3B,GAAwC,UAASU,IAAT,EAAe;AAErD,MAAI,KAAKnC,OAAT,EAAkB;AAChB,UAAMJ,KAAK,CAAC,uBAAD,CAAX;AACD,GAFD,MAEO;AACL,SAAKI,OAAL,GAAe,KAAKoC,eAAL,CAAqBD,IAArB,CAAf;AACD;;AAED,SAAO,IAAP;AACD,CATD;;AAWAH,gBAAgB,CAACV,SAAjB,CAA2BC,SAA3B,GAAuC,YAAW;AAChD,OAAKvB,OAAL,CAAagB,EAAb,GAAkB,KAAKe,IAAvB;AACD,CAFD;;AAIAC,gBAAgB,CAACV,SAAjB,CAA2Bc,eAA3B,GAA6C,UAASD,IAAT,EAAe;AAC1D,SAAO;AACLF,IAAAA,QAAQ,EAAE,KAAKA,QAAL,CAAcI,EAAd,CAAiBrD,IADtB;AAELgC,IAAAA,EAAE,EAAE;AAFC,GAAP;AAID,CALD;;AAOA,SAASsB,YAAT,CAAsBC,YAAtB,EAAoCvC,OAApC,EAA6C;AAC3C,OAAKA,OAAL,GAAeA,OAAf;AACA,OAAKuC,YAAL,GAAoBA,YAApB;AACD;;AAEDD,YAAY,CAAChB,SAAb,GAAyBK,MAAM,CAACC,MAAP,CAAcC,WAAW,CAACP,SAA1B,CAAzB;;AAEAgB,YAAY,CAAChB,SAAb,CAAuBC,SAAvB,GAAmC,YAAW;AAE5C,MAAIiB,KAAK,GAAG,KAAKT,IAAL,IAAa,EAAzB;AAAA,MACI/B,OAAO,GAAG,KAAKA,OADnB;AAAA,MAEIuC,YAAY,GAAG,KAAKA,YAFxB;AAIAC,EAAAA,KAAK,GAAGtE,UAAU,CAACqE,YAAY,CAACE,IAAd,EAAoBD,KAApB,CAAlB;;AAEA,MAAID,YAAY,CAACG,MAAjB,EAAyB;AACvB1C,IAAAA,OAAO,CAACiB,GAAR,CAAYsB,YAAY,CAACvD,IAAzB,EAA+B4B,IAA/B,CAAoC4B,KAApC;AACD,GAFD,MAEO;AACLxC,IAAAA,OAAO,CAAC2C,GAAR,CAAYJ,YAAY,CAACvD,IAAzB,EAA+BwD,KAA/B;AACD;AACF,CAbD;;AAgBA,SAASI,kBAAT,GAA8B,CAAE;;AAEhCA,kBAAkB,CAACtB,SAAnB,GAA+BK,MAAM,CAACC,MAAP,CAAcC,WAAW,CAACP,SAA1B,CAA/B;;AAEAsB,kBAAkB,CAACtB,SAAnB,CAA6BG,UAA7B,GAA0C,UAASU,IAAT,EAAe;AACvD,MAAIU,MAAM,GAAG,IAAb;AAAA,MACI7C,OAAO,GAAG,KAAKA,OADnB;;AAGA,MAAI,CAACA,OAAL,EAAc;AACZA,IAAAA,OAAO,GAAG,KAAKA,OAAL,GAAe,KAAK8C,aAAL,CAAmBX,IAAnB,CAAzB;AAEA,SAAKD,OAAL,CAAarB,UAAb,CAAwBb,OAAxB;AACD,GAJD,MAIO;AACL6C,IAAAA,MAAM,GAAG,KAAKE,WAAL,CAAiBZ,IAAjB,CAAT;AACD;;AAED,SAAOU,MAAP;AACD,CAbD;AAeA;AACA;AACA;AACA;;;AACA,OAAO,SAASG,cAAT,CAAwBtD,KAAxB,EAA+BuD,QAA/B,EAAyCf,OAAzC,EAAkD;AACvD,OAAKxC,KAAL,GAAaA,KAAb;AACA,OAAK+C,IAAL,GAAY/C,KAAK,CAACwD,OAAN,CAAcD,QAAd,CAAZ;AACA,OAAKf,OAAL,GAAeA,OAAf;AACD;AAEDc,cAAc,CAAC1B,SAAf,GAA2BK,MAAM,CAACC,MAAP,CAAcgB,kBAAkB,CAACtB,SAAjC,CAA3B;;AAEA0B,cAAc,CAAC1B,SAAf,CAAyBZ,YAAzB,GAAwC,UAASC,SAAT,EAAoB;AAC1D,OAAKuB,OAAL,CAAaxB,YAAb,CAA0BC,SAA1B;AACD,CAFD;;AAIAqC,cAAc,CAAC1B,SAAf,CAAyBE,UAAzB,GAAsC,UAASM,IAAT,EAAe;AAEnD,MAAI9B,OAAO,GAAG,KAAKA,OAAnB;AAAA,MACIc,UAAU,GAAGf,mBAAmB,CAACC,OAAD,CADpC;AAAA,MAEImD,YAAY,GAAGrC,UAAU,CAACqC,YAF9B;;AAIA,MAAI,CAACA,YAAL,EAAmB;AACjB,UAAMvD,KAAK,CAAC,2BAA2BkC,IAA3B,GAAkC,GAAnC,CAAX;AACD;;AAEDD,EAAAA,WAAW,CAACP,SAAZ,CAAsBE,UAAtB,CAAiC4B,IAAjC,CAAsC,IAAtC,EAA4CtB,IAA5C;AACD,CAXD;;AAaAkB,cAAc,CAAC1B,SAAf,CAAyBC,SAAzB,GAAqC,YAAW;AAE9C,MAAIiB,KAAK,GAAG,KAAKT,IAAjB;AAAA,MACI/B,OAAO,GAAG,KAAKA,OADnB;AAAA,MAEIc,UAAU,GAAGf,mBAAmB,CAACC,OAAD,CAFpC;AAAA,MAGImD,YAAY,GAAGrC,UAAU,CAACqC,YAH9B;;AAKA,MAAIA,YAAY,IAAIX,KAAK,KAAKa,SAA9B,EAAyC;AACvCb,IAAAA,KAAK,GAAGtE,UAAU,CAACiF,YAAY,CAACV,IAAd,EAAoBD,KAApB,CAAlB;AACAxC,IAAAA,OAAO,CAAC2C,GAAR,CAAYQ,YAAY,CAACnE,IAAzB,EAA+BwD,KAA/B;AACD;AACF,CAXD;AAaA;AACA;AACA;AACA;AACA;;;AACAQ,cAAc,CAAC1B,SAAf,CAAyBwB,aAAzB,GAAyC,UAASX,IAAT,EAAe;AACtD,MAAImB,UAAU,GAAGnB,IAAI,CAACmB,UAAtB;AAAA,MACIC,IAAI,GAAG,KAAKd,IADhB;AAAA,MAEI3B,UAAU,GAAGf,mBAAmB,CAACwD,IAAD,CAFpC;AAAA,MAGIrB,OAAO,GAAG,KAAKA,OAHnB;AAAA,MAIIsB,QAAQ,GAAG,IAAID,IAAJ,CAAS,EAAT,CAJf;AAAA,MAKI7D,KAAK,GAAG,KAAKA,KALjB;AAAA,MAMI+D,UANJ;AAQA/F,EAAAA,OAAO,CAAC4F,UAAD,EAAa,UAASd,KAAT,EAAgBxD,IAAhB,EAAsB;AAExC,QAAI0E,IAAI,GAAG5C,UAAU,CAAC6C,gBAAX,CAA4B3E,IAA5B,CAAX;AAAA,QACI4E,MADJ;;AAGA,QAAIF,IAAI,IAAIA,IAAI,CAACG,WAAjB,EAA8B;AAE5B,UAAI,CAACH,IAAI,CAAChB,MAAV,EAAkB;AAChBR,QAAAA,OAAO,CAACxB,YAAR,CAAqB;AACnBV,UAAAA,OAAO,EAAEwD,QADU;AAEnBvB,UAAAA,QAAQ,EAAEyB,IAAI,CAACrB,EAAL,CAAQrD,IAFC;AAGnBgC,UAAAA,EAAE,EAAEwB;AAHe,SAArB;AAKD,OAND,MAMO;AACL;AACAoB,QAAAA,MAAM,GAAGpB,KAAK,CAACsB,KAAN,CAAY,GAAZ,CAAT;AAEApG,QAAAA,OAAO,CAACkG,MAAD,EAAS,UAASG,CAAT,EAAY;AAC1B7B,UAAAA,OAAO,CAACxB,YAAR,CAAqB;AACnBV,YAAAA,OAAO,EAAEwD,QADU;AAEnBvB,YAAAA,QAAQ,EAAEyB,IAAI,CAACrB,EAAL,CAAQrD,IAFC;AAGnBgC,YAAAA,EAAE,EAAE+C;AAHe,WAArB;AAKD,SANM,CAAP;AAOD;AAEF,KArBD,MAqBO;AACL,UAAIL,IAAJ,EAAU;AACRlB,QAAAA,KAAK,GAAGtE,UAAU,CAACwF,IAAI,CAACjB,IAAN,EAAYD,KAAZ,CAAlB;AACD,OAFD,MAGA,IAAIxD,IAAI,KAAK,OAAb,EAAsB;AACpByE,QAAAA,UAAU,GAAGxF,WAAW,CAACe,IAAD,EAAO8B,UAAU,CAACuB,EAAX,CAAcpD,MAArB,CAAxB,CADoB,CAGpB;AACA;;AACA,YAAIS,KAAK,CAACC,UAAN,CAAiB8D,UAAU,CAACxE,MAA5B,CAAJ,EAAyC;AAEvCiD,UAAAA,OAAO,CAACf,UAAR,CAAmB;AACjBtB,YAAAA,OAAO,EAAE,wBAAwBb,IAAxB,GAA+B,GADvB;AAEjBgB,YAAAA,OAAO,EAAEwD,QAFQ;AAGjBvB,YAAAA,QAAQ,EAAEjD,IAHO;AAIjBwD,YAAAA,KAAK,EAAEA;AAJU,WAAnB;AAMD;AACF;;AAEDgB,MAAAA,QAAQ,CAACb,GAAT,CAAa3D,IAAb,EAAmBwD,KAAnB;AACD;AACF,GAhDM,CAAP;AAkDA,SAAOgB,QAAP;AACD,CA5DD;;AA8DAR,cAAc,CAAC1B,SAAf,CAAyB0C,kBAAzB,GAA8C,UAAS7B,IAAT,EAAe;AAE3D,MAAInD,IAAI,GAAGmD,IAAI,CAACnD,IAAhB;AACA,MAAII,MAAM,GAAGnB,WAAW,CAACe,IAAD,CAAxB;AAEA,MAAIyD,IAAI,GAAG,KAAKA,IAAhB;AAAA,MACI/C,KAAK,GAAG,KAAKA,KADjB;AAAA,MAEIoB,UAAU,GAAGf,mBAAmB,CAAC0C,IAAD,CAFpC;AAIA,MAAIwB,YAAY,GAAG7E,MAAM,CAACJ,IAA1B;AAAA,MACIiD,QAAQ,GAAGnB,UAAU,CAAC6C,gBAAX,CAA4BM,YAA5B,CADf;AAAA,MAEIC,eAFJ;AAAA,MAGIC,WAHJ,CAT2D,CAc3D;;AAEA,MAAIlC,QAAJ,EAAc;AAEZ,QAAI3D,eAAe,CAAC2D,QAAD,CAAnB,EAA+B;AAC7BiC,MAAAA,eAAe,GAAG/B,IAAI,CAACmB,UAAL,CAAgBjF,QAAhB,CAAlB,CAD6B,CAG7B;AACA;;AACA,UAAI6F,eAAJ,EAAqB;AAEnB;AACA;AACAA,QAAAA,eAAe,GAAGzE,oBAAoB,CAACyE,eAAD,EAAkBxE,KAAlB,CAAtC;AAEAyE,QAAAA,WAAW,GAAGzE,KAAK,CAACwD,OAAN,CAAcgB,eAAd,CAAd;AAEA,eAAOtG,MAAM,CAAC,EAAD,EAAKqE,QAAL,EAAe;AAC1BmC,UAAAA,aAAa,EAAErE,mBAAmB,CAACoE,WAAD,CAAnB,CAAiCnF;AADtB,SAAf,CAAb;AAGD;AACF,KAnBW,CAqBZ;;;AACA,WAAOiD,QAAP;AACD;;AAED,MAAIlD,GAAG,GAAGW,KAAK,CAACC,UAAN,CAAiBP,MAAM,CAACH,MAAxB,CAAV;;AAEA,MAAIF,GAAJ,EAAS;AACPmF,IAAAA,eAAe,GAAGrF,WAAW,CAACO,MAAD,EAASL,GAAT,CAA7B;AACAoF,IAAAA,WAAW,GAAGzE,KAAK,CAACwD,OAAN,CAAcgB,eAAd,CAAd,CAFO,CAIP;;AACAjC,IAAAA,QAAQ,GAAGtE,IAAI,CAACmD,UAAU,CAACuD,UAAZ,EAAwB,UAASC,CAAT,EAAY;AACjD,aAAO,CAACA,CAAC,CAACC,SAAH,IAAgB,CAACD,CAAC,CAACT,WAAnB,IAAkC,CAACS,CAAC,CAACE,WAArC,IAAoDL,WAAW,CAACM,OAAZ,CAAoBH,CAAC,CAAC7B,IAAtB,CAA3D;AACD,KAFc,CAAf;;AAIA,QAAIR,QAAJ,EAAc;AACZ,aAAOrE,MAAM,CAAC,EAAD,EAAKqE,QAAL,EAAe;AAC1BmC,QAAAA,aAAa,EAAErE,mBAAmB,CAACoE,WAAD,CAAnB,CAAiCnF;AADtB,OAAf,CAAb;AAGD;AACF,GAdD,MAcO;AACL;AACAiD,IAAAA,QAAQ,GAAGtE,IAAI,CAACmD,UAAU,CAACuD,UAAZ,EAAwB,UAASC,CAAT,EAAY;AACjD,aAAO,CAACA,CAAC,CAACT,WAAH,IAAkB,CAACS,CAAC,CAACE,WAArB,IAAoCF,CAAC,CAAC7B,IAAF,KAAW,SAAtD;AACD,KAFc,CAAf;;AAIA,QAAIR,QAAJ,EAAc;AACZ,aAAOA,QAAP;AACD;AACF;;AAED,QAAMrC,KAAK,CAAC,2BAA2BR,MAAM,CAACJ,IAAlC,GAAyC,GAA1C,CAAX;AACD,CArED;;AAuEAgE,cAAc,CAAC1B,SAAf,CAAyBoD,QAAzB,GAAoC,YAAW;AAC7C,SAAO,uBAAuB3E,mBAAmB,CAAC,KAAK0C,IAAN,CAAnB,CAA+BzD,IAAtD,GAA6D,GAApE;AACD,CAFD;;AAIAgE,cAAc,CAAC1B,SAAf,CAAyBqD,YAAzB,GAAwC,UAASpC,YAAT,EAAuBvC,OAAvB,EAAgC;AACtE,SAAO,IAAIsC,YAAJ,CAAiBC,YAAjB,EAA+BvC,OAA/B,CAAP;AACD,CAFD;;AAIAgD,cAAc,CAAC1B,SAAf,CAAyBsD,gBAAzB,GAA4C,UAASrC,YAAT,EAAuB;AACjE,SAAO,IAAIP,gBAAJ,CAAqBO,YAArB,EAAmC,KAAKL,OAAxC,CAAP;AACD,CAFD;;AAIAc,cAAc,CAAC1B,SAAf,CAAyBuD,OAAzB,GAAmC,UAASpC,IAAT,EAAe;AAChD,MAAIA,IAAI,KAAK,SAAb,EAAwB;AACtB,WAAO,IAAIqC,qBAAJ,CAA0B,KAAKpF,KAA/B,EAAsC+C,IAAtC,EAA4C,KAAKP,OAAjD,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAIc,cAAJ,CAAmB,KAAKtD,KAAxB,EAA+B+C,IAA/B,EAAqC,KAAKP,OAA1C,CAAP;AACD;AACF,CAND;AAQA;AACA;AACA;AACA;AACA;;;AACAc,cAAc,CAAC1B,SAAf,CAAyByB,WAAzB,GAAuC,UAASZ,IAAT,EAAe;AACpD,MAAII,YAAJ,EAAkBE,IAAlB,EAAwBzC,OAAxB,EAAiC+E,YAAjC;AAEAxC,EAAAA,YAAY,GAAG,KAAKyB,kBAAL,CAAwB7B,IAAxB,CAAf;AACAnC,EAAAA,OAAO,GAAG,KAAKA,OAAf;AAEAyC,EAAAA,IAAI,GAAGF,YAAY,CAAC6B,aAAb,IAA8B7B,YAAY,CAACE,IAAlD;;AAEA,MAAIrE,YAAY,CAACqE,IAAD,CAAhB,EAAwB;AACtB,WAAO,KAAKkC,YAAL,CAAkBpC,YAAlB,EAAgCvC,OAAhC,CAAP;AACD;;AAED,MAAIuC,YAAY,CAACsB,WAAjB,EAA8B;AAC5BkB,IAAAA,YAAY,GAAG,KAAKH,gBAAL,CAAsBrC,YAAtB,EAAoCd,UAApC,CAA+CU,IAA/C,CAAf;AACD,GAFD,MAEO;AACL4C,IAAAA,YAAY,GAAG,KAAKF,OAAL,CAAapC,IAAb,EAAmBhB,UAAnB,CAA8BU,IAA9B,CAAf;AACD;;AAED,MAAI6C,UAAU,GAAGD,YAAY,CAAC/E,OAA9B,CAlBoD,CAoBpD;AACA;;AACA,MAAIgF,UAAU,KAAK3B,SAAnB,EAA8B;AAE5B,QAAId,YAAY,CAACG,MAAjB,EAAyB;AACvB1C,MAAAA,OAAO,CAACiB,GAAR,CAAYsB,YAAY,CAACvD,IAAzB,EAA+B4B,IAA/B,CAAoCoE,UAApC;AACD,KAFD,MAEO;AACLhF,MAAAA,OAAO,CAAC2C,GAAR,CAAYJ,YAAY,CAACvD,IAAzB,EAA+BgG,UAA/B;AACD;;AAED,QAAIzC,YAAY,CAACsB,WAAjB,EAA8B;AAC5BjG,MAAAA,MAAM,CAACoH,UAAD,EAAa;AACjBhF,QAAAA,OAAO,EAAEA;AADQ,OAAb,CAAN;AAIA,WAAKkC,OAAL,CAAaxB,YAAb,CAA0BsE,UAA1B;AACD,KAND,MAMO;AACL;AACAA,MAAAA,UAAU,CAACC,OAAX,GAAqBjF,OAArB;AACD;AACF;;AAED,SAAO+E,YAAP;AACD,CA3CD;AA6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,kBAAT,CAA4BxF,KAA5B,EAAmCuD,QAAnC,EAA6Cf,OAA7C,EAAsD;AACpDc,EAAAA,cAAc,CAACI,IAAf,CAAoB,IAApB,EAA0B1D,KAA1B,EAAiCuD,QAAjC,EAA2Cf,OAA3C;AACD;;AAEDgD,kBAAkB,CAAC5D,SAAnB,GAA+BK,MAAM,CAACC,MAAP,CAAcoB,cAAc,CAAC1B,SAA7B,CAA/B;;AAEA4D,kBAAkB,CAAC5D,SAAnB,CAA6BwB,aAA7B,GAA6C,UAASX,IAAT,EAAe;AAE1D,MAAInD,IAAI,GAAGmD,IAAI,CAACnD,IAAhB;AAAA,MACII,MAAM,GAAGnB,WAAW,CAACe,IAAD,CADxB;AAAA,MAEIU,KAAK,GAAG,KAAKA,KAFjB;AAAA,MAGI+C,IAAI,GAAG,KAAKA,IAHhB;AAAA,MAII1D,GAAG,GAAGW,KAAK,CAACC,UAAN,CAAiBP,MAAM,CAACH,MAAxB,CAJV;AAAA,MAKIgE,QAAQ,GAAGlE,GAAG,IAAIF,WAAW,CAACO,MAAD,EAASL,GAAT,CAAlB,IAAmCC,IALlD,CAF0D,CAS1D;AACA;AACA;AACA;;AACA,MAAI,CAACyD,IAAI,CAACgC,OAAL,CAAaxB,QAAb,CAAL,EAA6B;AAC3B,UAAMrD,KAAK,CAAC,yBAAyBuC,IAAI,CAACgD,YAA9B,GAA6C,GAA9C,CAAX;AACD;;AAED,SAAOnC,cAAc,CAAC1B,SAAf,CAAyBwB,aAAzB,CAAuCM,IAAvC,CAA4C,IAA5C,EAAkDjB,IAAlD,CAAP;AACD,CAlBD;;AAqBA,SAAS2C,qBAAT,CAA+BpF,KAA/B,EAAsCuD,QAAtC,EAAgDf,OAAhD,EAAyD;AACvD,OAAKxC,KAAL,GAAaA,KAAb;AACA,OAAKwC,OAAL,GAAeA,OAAf;AACD;;AAED4C,qBAAqB,CAACxD,SAAtB,GAAkCK,MAAM,CAACC,MAAP,CAAcgB,kBAAkB,CAACtB,SAAjC,CAAlC;;AAEAwD,qBAAqB,CAACxD,SAAtB,CAAgCwB,aAAhC,GAAgD,UAASX,IAAT,EAAe;AAE7D,MAAInD,IAAI,GAAGmD,IAAI,CAACnD,IAAhB;AAAA,MACIqD,EAAE,GAAGpE,WAAW,CAACe,IAAD,CADpB;AAAA,MAEIC,MAAM,GAAGoD,EAAE,CAACpD,MAFhB;AAAA,MAGImG,GAAG,GAAGjD,IAAI,CAACE,EAAL,CAAQpD,MAAM,GAAG,MAAjB,CAHV;AAAA,MAIIqE,UAAU,GAAGnB,IAAI,CAACmB,UAJtB;AAMA,SAAO,KAAK5D,KAAL,CAAW2F,SAAX,CAAqBrG,IAArB,EAA2BoG,GAA3B,EAAgC9B,UAAhC,CAAP;AACD,CATD;;AAWAwB,qBAAqB,CAACxD,SAAtB,CAAgCyB,WAAhC,GAA8C,UAASZ,IAAT,EAAe;AAE3D,MAAI0C,OAAO,GAAG,IAAIC,qBAAJ,CAA0B,KAAKpF,KAA/B,EAAsC,SAAtC,EAAiD,KAAKwC,OAAtD,EAA+DT,UAA/D,CAA0EU,IAA1E,CAAd;AAAA,MACInC,OAAO,GAAG,KAAKA,OADnB;AAGA,MAAIgF,UAAU,GAAGH,OAAO,CAAC7E,OAAzB;AAAA,MACIsF,QADJ;;AAGA,MAAIN,UAAU,KAAK3B,SAAnB,EAA8B;AAC5BiC,IAAAA,QAAQ,GAAGtF,OAAO,CAACuF,SAAR,GAAoBvF,OAAO,CAACuF,SAAR,IAAqB,EAApD;AACAD,IAAAA,QAAQ,CAAC1E,IAAT,CAAcoE,UAAd,EAF4B,CAI5B;;AACAA,IAAAA,UAAU,CAACC,OAAX,GAAqBjF,OAArB;AACD;;AAED,SAAO6E,OAAP;AACD,CAjBD;;AAmBAC,qBAAqB,CAACxD,SAAtB,CAAgCC,SAAhC,GAA4C,YAAW;AACrD,MAAI,KAAKQ,IAAT,EAAe;AACb,SAAK/B,OAAL,CAAawF,KAAb,GAAqB,KAAKzD,IAA1B;AACD;AACF,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAAS0D,MAAT,CAAgBnF,OAAhB,EAAyB;AAE9B,MAAIA,OAAO,YAAYvC,MAAvB,EAA+B;AAC7BuC,IAAAA,OAAO,GAAG;AACRZ,MAAAA,KAAK,EAAEY;AADC,KAAV;AAGD;;AAED1C,EAAAA,MAAM,CAAC,IAAD,EAAO;AAAE8H,IAAAA,GAAG,EAAE;AAAP,GAAP,EAAuBpF,OAAvB,CAAN;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;;AACAmF,MAAM,CAACnE,SAAP,CAAiBqE,OAAjB,GAA2B,UAASrG,GAAT,EAAcgB,OAAd,EAAuBsF,IAAvB,EAA6B;AAEtD,MAAIC,WAAW,GAAGvF,OAAO,CAACuF,WAA1B;;AAEA,MAAIvF,OAAO,YAAY0C,cAAvB,EAAuC;AACrC;AACA6C,IAAAA,WAAW,GAAGvF,OAAd;AACAA,IAAAA,OAAO,GAAG,EAAV;AACD,GAJD,MAIO;AACL,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/B;AACAuF,MAAAA,WAAW,GAAG,KAAKhB,OAAL,CAAavE,OAAb,CAAd;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD,KAJD,MAIO,IAAI,OAAOuF,WAAP,KAAuB,QAA3B,EAAqC;AAC1C;AACAA,MAAAA,WAAW,GAAG,KAAKhB,OAAL,CAAagB,WAAb,CAAd;AACD;AACF;;AAED,MAAInG,KAAK,GAAG,KAAKA,KAAjB;AAAA,MACIgG,GAAG,GAAG,KAAKA,GADf;AAGA,MAAIxD,OAAO,GAAG,IAAI7B,OAAJ,CAAYzC,MAAM,CAAC,EAAD,EAAK0C,OAAL,EAAc;AAAEuF,IAAAA,WAAW,EAAEA;AAAf,GAAd,CAAlB,CAAd;AAAA,MACIhD,MAAM,GAAG,IAAI/E,SAAJ,CAAc;AAAEgI,IAAAA,KAAK,EAAE;AAAT,GAAd,CADb;AAAA,MAEIC,KAAK,GAAGC,WAAW,EAFvB;AAIAH,EAAAA,WAAW,CAAC3D,OAAZ,GAAsBA,OAAtB,CA1BsD,CA4BtD;;AACA6D,EAAAA,KAAK,CAACnF,IAAN,CAAWiF,WAAX;AAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,WAASI,WAAT,CAAqBC,GAArB,EAA0BC,UAA1B,EAAsCT,GAAtC,EAA2C;AAEzC,QAAIU,GAAG,GAAGD,UAAU,EAApB;AAEA,QAAIE,IAAI,GAAGD,GAAG,CAACC,IAAf;AAAA,QACIC,MAAM,GAAGF,GAAG,CAACE,MADjB;AAAA,QAEIC,IAAI,GAAGH,GAAG,CAACG,IAFf,CAJyC,CAQzC;AACA;AACA;;AACA,QAAIA,IAAI,CAAC7H,MAAL,CAAY,CAAZ,MAAmB,GAAnB,IAA0B6H,IAAI,CAAChH,OAAL,CAAa,GAAb,MAAsB,CAAC,CAArD,EAAwD;AACtDgH,MAAAA,IAAI,GAAGA,IAAI,CAAC3H,KAAL,CAAW,CAAX,EAAc2H,IAAI,CAAChH,OAAL,CAAa,GAAb,CAAd,IAAmC,GAA1C;AACD;;AAED,QAAIM,OAAO,GACT,yBAAyB0G,IAAI,GAAGA,IAAI,GAAG,GAAV,GAAgB,EAA7C,IAAmD,cAAnD,GACE,QADF,GACaF,IADb,GACoB,MADpB,GAEE,UAFF,GAEeC,MAFf,GAEwB,MAFxB,GAGE,gBAHF,GAGqBJ,GAAG,CAACrG,OAJ3B;;AAMA,QAAI6F,GAAJ,EAAS;AACPxD,MAAAA,OAAO,CAACf,UAAR,CAAmB;AACjBtB,QAAAA,OAAO,EAAEA,OADQ;AAEjBD,QAAAA,KAAK,EAAEsG;AAFU,OAAnB;AAKA,aAAO,IAAP;AACD,KAPD,MAOO;AACL,YAAMtG,KAAK,CAACC,OAAD,CAAX;AACD;AACF;;AAED,WAAS2G,aAAT,CAAuBN,GAAvB,EAA4BC,UAA5B,EAAwC;AACtC;AACA,WAAOF,WAAW,CAACC,GAAD,EAAMC,UAAN,EAAkB,IAAlB,CAAlB;AACD;AAED;AACF;AACA;;;AACE,WAASM,iBAAT,GAA6B;AAE3B,QAAIlG,YAAY,GAAG2B,OAAO,CAAC3B,YAA3B;AACA,QAAIC,UAAU,GAAG0B,OAAO,CAAC1B,UAAzB;AAEA,QAAIkG,CAAJ,EAAOC,CAAP;;AAEA,SAAKD,CAAC,GAAG,CAAT,EAAaC,CAAC,GAAGnG,UAAU,CAACkG,CAAD,CAA3B,EAAiCA,CAAC,EAAlC,EAAsC;AACpC,UAAI1G,OAAO,GAAG2G,CAAC,CAAC3G,OAAhB;AACA,UAAIW,SAAS,GAAGJ,YAAY,CAACoG,CAAC,CAAC3F,EAAH,CAA5B;AACA,UAAIiB,QAAQ,GAAGlC,mBAAmB,CAACC,OAAD,CAAnB,CAA6B2D,gBAA7B,CAA8CgD,CAAC,CAAC1E,QAAhD,CAAf;;AAEA,UAAI,CAACtB,SAAL,EAAgB;AACduB,QAAAA,OAAO,CAACf,UAAR,CAAmB;AACjBtB,UAAAA,OAAO,EAAE,2BAA2B8G,CAAC,CAAC3F,EAA7B,GAAkC,GAD1B;AAEjBhB,UAAAA,OAAO,EAAE2G,CAAC,CAAC3G,OAFM;AAGjBiC,UAAAA,QAAQ,EAAE0E,CAAC,CAAC1E,QAHK;AAIjBO,UAAAA,KAAK,EAAEmE,CAAC,CAAC3F;AAJQ,SAAnB;AAMD;;AAED,UAAIiB,QAAQ,CAACS,MAAb,EAAqB;AACnB,YAAIkE,UAAU,GAAG5G,OAAO,CAACiB,GAAR,CAAYgB,QAAQ,CAACjD,IAArB,CAAjB;AAAA,YACI6H,GAAG,GAAGD,UAAU,CAACrH,OAAX,CAAmBoH,CAAnB,CADV,CADmB,CAInB;AACA;;AACA,YAAIE,GAAG,KAAK,CAAC,CAAb,EAAgB;AACdA,UAAAA,GAAG,GAAGD,UAAU,CAACpH,MAAjB;AACD;;AAED,YAAI,CAACmB,SAAL,EAAgB;AACd;AACAiG,UAAAA,UAAU,CAACE,MAAX,CAAkBD,GAAlB,EAAuB,CAAvB;AACD,SAHD,MAGO;AACL;AACAD,UAAAA,UAAU,CAACC,GAAD,CAAV,GAAkBlG,SAAlB;AACD;AACF,OAjBD,MAiBO;AACLX,QAAAA,OAAO,CAAC2C,GAAR,CAAYV,QAAQ,CAACjD,IAArB,EAA2B2B,SAA3B;AACD;AACF;AACF;;AAED,WAASoG,WAAT,GAAuB;AACrBhB,IAAAA,KAAK,CAACiB,GAAN,GAAYzF,SAAZ;AACD;;AAED,MAAI0F,sBAAsB,GAAG,WAA7B;AAEA,MAAIC,gBAAgB,GAAG,sBAAvB;AAEA,MAAIC,aAAa,GAAG,UAApB;;AAEA,WAASC,cAAT,CAAwBC,QAAxB,EAAkC;AAEhC,QAAI,CAACJ,sBAAsB,CAAC/F,IAAvB,CAA4BmG,QAA5B,CAAL,EAA4C;AAC1C;AACD;;AAED,QAAIC,KAAK,GAAGJ,gBAAgB,CAACK,IAAjB,CAAsBF,QAAtB,CAAZ;AACA,QAAIG,QAAQ,GAAGF,KAAK,IAAIA,KAAK,CAAC,CAAD,CAA7B;;AAEA,QAAI,CAACE,QAAD,IAAaL,aAAa,CAACjG,IAAd,CAAmBsG,QAAnB,CAAjB,EAA+C;AAC7C;AACD;;AAEDtF,IAAAA,OAAO,CAACf,UAAR,CAAmB;AACjBtB,MAAAA,OAAO,EACL,oCAAoC2H,QAApC,GAA+C,KAA/C,GACA;AAHe,KAAnB;AAKD;;AAED,WAASC,UAAT,CAAoBtF,IAApB,EAA0BgE,UAA1B,EAAsC;AACpC,QAAItB,OAAO,GAAGkB,KAAK,CAAC2B,IAAN,EAAd;;AAEA,QAAI;AACF3B,MAAAA,KAAK,CAACnF,IAAN,CAAWiE,OAAO,CAACpD,UAAR,CAAmBU,IAAnB,CAAX;AACD,KAFD,CAEE,OAAO+D,GAAP,EAAY;AAEZ,UAAID,WAAW,CAACC,GAAD,EAAMC,UAAN,EAAkBT,GAAlB,CAAf,EAAuC;AACrCK,QAAAA,KAAK,CAACnF,IAAN,CAAW,IAAIc,WAAJ,EAAX;AACD;AACF;AACF;;AAED,WAASiG,WAAT,CAAqB7F,IAArB,EAA2BqE,UAA3B,EAAuC;AAErC,QAAI;AACFJ,MAAAA,KAAK,CAAC2B,IAAN,GAAalG,UAAb,CAAwBM,IAAxB;AACD,KAFD,CAEE,OAAOoE,GAAP,EAAY;AACZM,MAAAA,aAAa,CAACN,GAAD,EAAMC,UAAN,CAAb;AACD;AACF;;AAED,WAAS3E,UAAT,CAAoBM,IAApB,EAA0BqE,UAA1B,EAAsC;AACpC;AACA;AACArE,IAAAA,IAAI,GAAGA,IAAI,CAAC8F,IAAL,EAAP;;AAEA,QAAI,CAAC9F,IAAL,EAAW;AACT;AACD;;AAED6F,IAAAA,WAAW,CAAC7F,IAAD,EAAOqE,UAAP,CAAX;AACD;;AAED,MAAI0B,MAAM,GAAGnI,KAAK,CAACoI,WAAN,GAAoBC,MAApB,CAA2B,UAASF,MAAT,EAAiBvD,CAAjB,EAAoB;AAC1DuD,IAAAA,MAAM,CAACvD,CAAC,CAACc,GAAH,CAAN,GAAgBd,CAAC,CAACrF,MAAlB;AAEA,WAAO4I,MAAP;AACD,GAJY,EAIV,EAJU,CAAb;AAMAhF,EAAAA,MAAM,CACHR,EADH,CACMwF,MADN,EAEGG,EAFH,CAEM,SAFN,EAEiB,UAASC,GAAT,EAAcC,SAAd,EAAyBC,WAAzB,EAAsChC,UAAtC,EAAkD;AAE/D;AACA,QAAIiC,KAAK,GAAGH,GAAG,CAACG,KAAJ,IAAa,EAAzB;AAEA,QAAIC,YAAY,GAAG1G,MAAM,CAAC2G,IAAP,CAAYF,KAAZ,EAAmBL,MAAnB,CAA0B,UAASQ,CAAT,EAAYC,GAAZ,EAAiB;AAC5D,UAAIhG,KAAK,GAAG0F,SAAS,CAACE,KAAK,CAACI,GAAD,CAAN,CAArB;AAEAD,MAAAA,CAAC,CAACC,GAAD,CAAD,GAAShG,KAAT;AAEA,aAAO+F,CAAP;AACD,KANkB,EAMhB,EANgB,CAAnB;AAQA,QAAIpG,IAAI,GAAG;AACTnD,MAAAA,IAAI,EAAEiJ,GAAG,CAACjJ,IADD;AAETmG,MAAAA,YAAY,EAAE8C,GAAG,CAAC9C,YAFT;AAGT7B,MAAAA,UAAU,EAAE+E,YAHH;AAIThG,MAAAA,EAAE,EAAE4F,GAAG,CAAC5F;AAJC,KAAX;AAOAoF,IAAAA,UAAU,CAACtF,IAAD,EAAOgE,UAAP,CAAV;AACD,GAvBH,EAwBG6B,EAxBH,CAwBM,UAxBN,EAwBkBZ,cAxBlB,EAyBGY,EAzBH,CAyBM,UAzBN,EAyBkBjB,WAzBlB,EA0BGiB,EA1BH,CA0BM,OA1BN,EA0BeL,WA1Bf,EA2BGK,EA3BH,CA2BM,MA3BN,EA2Bc,UAASlG,IAAT,EAAe2G,cAAf,EAA+BtC,UAA/B,EAA2C;AACrD3E,IAAAA,UAAU,CAACiH,cAAc,CAAC3G,IAAD,CAAf,EAAuBqE,UAAvB,CAAV;AACD,GA7BH,EA8BG6B,EA9BH,CA8BM,OA9BN,EA8Be/B,WA9Bf,EA+BG+B,EA/BH,CA+BM,MA/BN,EA+BcxB,aA/Bd,EApMsD,CAqOtD;AACA;AACA;AACA;;AACAtG,EAAAA,KAAK,CAAC,YAAW;AACf,QAAIgG,GAAJ;;AAEA,QAAI;AACFrD,MAAAA,MAAM,CAAC6F,KAAP,CAAapJ,GAAb;AAEAmH,MAAAA,iBAAiB;AAClB,KAJD,CAIE,OAAOkC,CAAP,EAAU;AACVzC,MAAAA,GAAG,GAAGyC,CAAN;AACD;;AAED,QAAI3I,OAAO,GAAG6F,WAAW,CAAC7F,OAA1B,CAXe,CAaf;AACA;;AACA,QAAI,CAACkG,GAAD,IAAQ,CAAClG,OAAb,EAAsB;AACpBkG,MAAAA,GAAG,GAAGtG,KAAK,CAAC,kCAAkCiG,WAAW,CAACpD,IAAZ,CAAiBxC,WAAjB,CAA6BjB,IAA/D,GAAsE,GAAvE,CAAX;AACD;;AAED4G,IAAAA,IAAI,CAACM,GAAD,EAAMA,GAAG,GAAG7C,SAAH,GAAerD,OAAxB,EAAiCkC,OAAjC,CAAJ;AACD,GApBI,CAAL;AAqBD,CA9PD;;AAgQAuD,MAAM,CAACnE,SAAP,CAAiBuD,OAAjB,GAA2B,UAAS7F,IAAT,EAAe;AACxC,SAAO,IAAIkG,kBAAJ,CAAuB,KAAKxF,KAA5B,EAAmCV,IAAnC,CAAP;AACD,CAFD,C,CAKA;;;AAEA,SAASgH,WAAT,GAAuB;AACrB,MAAID,KAAK,GAAG,EAAZ;AAEApE,EAAAA,MAAM,CAACiH,cAAP,CAAsB7C,KAAtB,EAA6B,MAA7B,EAAqC;AACnCvD,IAAAA,KAAK,EAAE,YAAW;AAChB,aAAO,KAAK,KAAKhD,MAAL,GAAc,CAAnB,CAAP;AACD;AAHkC,GAArC;AAMA,SAAOuG,KAAP;AACD","sourcesContent":["import {\n  forEach,\n  find,\n  assign\n} from 'min-dash';\n\nimport {\n  Parser as SaxParser\n} from 'saxen';\n\nimport Moddle from 'moddle';\nimport {\n  parseName as parseNameNs\n} from 'moddle/lib/ns';\n\nimport {\n  coerceType,\n  isSimple as isSimpleType\n} from 'moddle/lib/types';\n\nimport {\n  XSI_TYPE,\n  serializeAsType,\n  hasLowerCaseAlias\n} from './common';\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction aliasToName(aliasNs, pkg) {\n\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\nfunction prefixedToName(nameNs, pkg) {\n\n  var name = nameNs.name,\n      localName = nameNs.localName;\n\n  var typePrefix = pkg.xml && pkg.xml.typePrefix;\n\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\n\nfunction normalizeXsiTypeName(name, model) {\n\n  var nameNs = parseNameNs(name);\n  var pkg = model.getPackage(nameNs.prefix);\n\n  return prefixedToName(nameNs, pkg);\n}\n\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\nfunction defer(fn) {\n  setTimeout(fn, 0);\n}\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nexport function Context(options) {\n\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  assign(this, options);\n\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function(reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function(element) {\n\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n\n    var descriptor = getModdleDescriptor(element);\n\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function(warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function() {};\nBaseHandler.prototype.handleText = function() {};\nBaseHandler.prototype.handleNode = function() {};\n\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() { }\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function() {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function(text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function(node) {\n\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function() {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function(node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function() {\n\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n\n  value = coerceType(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function(node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n\n/**\n * @class Reader.ElementHandler\n *\n */\nexport function ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\n\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function(reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleText = function(text) {\n\n  var element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n\n  BodyHandler.prototype.handleText.call(this, text);\n};\n\nElementHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function(node) {\n  var attributes = node.attributes,\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({}),\n      model = this.model,\n      propNameNs;\n\n  forEach(attributes, function(value, name) {\n\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n\n        forEach(values, function(v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else\n      if (name !== 'xmlns') {\n        propNameNs = parseNameNs(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n\n      instance.set(name, value);\n    }\n  });\n\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function(node) {\n\n  var name = node.name;\n  var nameNs = parseNameNs(name);\n\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName],\n      elementTypeName,\n      elementType;\n\n  // search for properties by name first\n\n  if (property) {\n\n    if (serializeAsType(property)) {\n      elementTypeName = node.attributes[XSI_TYPE];\n\n      // xsi type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\"\n        elementTypeName = normalizeXsiTypeName(elementTypeName, model);\n\n        elementType = model.getType(elementTypeName);\n\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    elementTypeName = aliasToName(nameNs, pkg);\n    elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function(p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function(p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function() {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function(type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function(node) {\n  var propertyDesc, type, element, childHandler;\n\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n\n      this.context.addReference(newElement);\n    } else {\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\n\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\nRootElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      nameNs = parseNameNs(name),\n      model = this.model,\n      type = this.type,\n      pkg = model.getPackage(nameNs.prefix),\n      typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n\n  return ElementHandler.prototype.createElement.call(this, node);\n};\n\n\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      ns = parseNameNs(name),\n      prefix = ns.prefix,\n      uri = node.ns[prefix + '$uri'],\n      attributes = node.attributes;\n\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function(node) {\n\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleEnd = function() {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nexport function Reader(options) {\n\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  assign(this, { lax: false }, options);\n}\n\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n * @param  {Function} done\n */\nReader.prototype.fromXML = function(xml, options, done) {\n\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n\n  var context = new Context(assign({}, options, { rootHandler: rootHandler })),\n      parser = new SaxParser({ proxy: true }),\n      stack = createStack();\n\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n  function handleError(err, getContext, lax) {\n\n    var ctx = getContext();\n\n    var line = ctx.line,\n        column = ctx.column,\n        data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n\n    var message =\n      'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' +\n        'line: ' + line + '\\n\\t' +\n        'column: ' + column + '\\n\\t' +\n        'nested error: ' + err.message;\n\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n\n  function handleWarning(err, getContext) {\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\n   * Resolve collected references on parse end.\n   */\n  function resolveReferences() {\n\n    var elementsById = context.elementsById;\n    var references = context.references;\n\n    var i, r;\n\n    for (i = 0; (r = references[i]); i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n\n  var UTF_8_PATTERN = /^utf-8$/i;\n\n  function handleQuestion(question) {\n\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n\n    context.addWarning({\n      message:\n        'unsupported document encoding <' + encoding + '>, ' +\n        'falling back to UTF-8'\n    });\n  }\n\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n\n  function handleCData(text, getContext) {\n\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n\n  function handleText(text, getContext) {\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n    text = text.trim();\n\n    if (!text) {\n      return;\n    }\n\n    handleCData(text, getContext);\n  }\n\n  var uriMap = model.getPackages().reduce(function(uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n\n    return uriMap;\n  }, {});\n\n  parser\n    .ns(uriMap)\n    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {\n\n      // gracefully handle unparsable attributes (attrs=false)\n      var attrs = obj.attrs || {};\n\n      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\n        var value = decodeStr(attrs[key]);\n\n        d[key] = value;\n\n        return d;\n      }, {});\n\n      var node = {\n        name: obj.name,\n        originalName: obj.originalName,\n        attributes: decodedAttrs,\n        ns: obj.ns\n      };\n\n      handleOpen(node, getContext);\n    })\n    .on('question', handleQuestion)\n    .on('closeTag', handleClose)\n    .on('cdata', handleCData)\n    .on('text', function(text, decodeEntities, getContext) {\n      handleText(decodeEntities(text), getContext);\n    })\n    .on('error', handleError)\n    .on('warn', handleWarning);\n\n  // deferred parse XML to make loading really ascnchronous\n  // this ensures the execution environment (node or browser)\n  // is kept responsive and that certain optimization strategies\n  // can kick in\n  defer(function() {\n    var err;\n\n    try {\n      parser.parse(xml);\n\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n\n    var element = rootHandler.element;\n\n    // handle the situation that we could not extract\n    // the desired root element from the document\n    if (!err && !element) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n\n    done(err, err ? undefined : element, context);\n  });\n};\n\nReader.prototype.handler = function(name) {\n  return new RootElementHandler(this.model, name);\n};\n\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n\n  Object.defineProperty(stack, 'peek', {\n    value: function() {\n      return this[this.length - 1];\n    }\n  });\n\n  return stack;\n}"]},"metadata":{},"sourceType":"module"}