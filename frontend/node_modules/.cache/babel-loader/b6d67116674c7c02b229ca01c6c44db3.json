{"ast":null,"code":"import inherits from 'inherits';\nimport { getOrientation, getMid, asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nimport { substract } from 'diagram-js/lib/util/Math';\nimport { hasExternalLabel } from '../../../util/LabelUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\n\nexport default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  this.postExecuted(['connection.create', 'connection.layout', 'connection.updateWaypoints'], function (event) {\n    var context = event.context,\n        connection = context.connection;\n    var source = connection.source,\n        target = connection.target;\n    checkLabelAdjustment(source);\n    checkLabelAdjustment(target);\n  });\n  this.postExecuted(['label.create'], function (event) {\n    checkLabelAdjustment(event.context.shape.labelTarget);\n  });\n\n  function checkLabelAdjustment(element) {\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    var optimalPosition = getOptimalPosition(element); // no optimal position found\n\n    if (!optimalPosition) {\n      return;\n    }\n\n    adjustLabelPosition(element, optimalPosition);\n  }\n\n  var ELEMENT_LABEL_DISTANCE = 10;\n\n  function adjustLabelPosition(element, orientation) {\n    var elementMid = getMid(element),\n        label = element.label,\n        labelMid = getMid(label);\n    var elementTrbl = asTRBL(element);\n    var newLabelMid;\n\n    switch (orientation) {\n      case 'top':\n        newLabelMid = {\n          x: elementMid.x,\n          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n        };\n        break;\n\n      case 'left':\n        newLabelMid = {\n          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n          y: elementMid.y\n        };\n        break;\n\n      case 'bottom':\n        newLabelMid = {\n          x: elementMid.x,\n          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n        };\n        break;\n\n      case 'right':\n        newLabelMid = {\n          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n          y: elementMid.y\n        };\n        break;\n    }\n\n    var delta = substract(newLabelMid, labelMid);\n    modeling.moveShape(label, delta);\n  }\n}\ninherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);\nAdaptiveLabelPositioningBehavior.$inject = ['eventBus', 'modeling'];\n/**\n * Return the optimal label position around an element\n * or _undefined_, if none was found.\n *\n * @param  {Shape} element\n *\n * @return {String} positioning identifier\n */\n\nfunction getOptimalPosition(element) {\n  var labelMid = getMid(element.label);\n  var elementMid = getMid(element);\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n\n  var takenAlignments = [].concat(element.incoming.map(function (c) {\n    return c.waypoints[c.waypoints.length - 2];\n  }), element.outgoing.map(function (c) {\n    return c.waypoints[1];\n  })).map(function (point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n  var freeAlignments = ALIGNMENTS.filter(function (alignment) {\n    return takenAlignments.indexOf(alignment) === -1;\n  }); // NOTHING TO DO; label already aligned a.O.K.\n\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n\n  return freeAlignments[0];\n}\n\nvar ALIGNMENTS = ['top', 'bottom', 'left', 'right'];\n\nfunction getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}\n\nfunction isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js"],"names":["inherits","getOrientation","getMid","asTRBL","substract","hasExternalLabel","CommandInterceptor","AdaptiveLabelPositioningBehavior","eventBus","modeling","call","postExecuted","event","context","connection","source","target","checkLabelAdjustment","shape","labelTarget","element","optimalPosition","getOptimalPosition","adjustLabelPosition","ELEMENT_LABEL_DISTANCE","orientation","elementMid","label","labelMid","elementTrbl","newLabelMid","x","y","top","height","left","width","bottom","right","delta","moveShape","$inject","labelOrientation","getApproximateOrientation","isAligned","takenAlignments","concat","incoming","map","c","waypoints","length","outgoing","point","freeAlignments","ALIGNMENTS","filter","alignment","indexOf","p0","p1"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport {\n  getOrientation,\n  getMid,\n  asTRBL\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  substract\n} from 'diagram-js/lib/util/Math';\n\nimport {\n  hasExternalLabel\n} from '../../../util/LabelUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\n\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n */\nexport default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.postExecuted([\n    'connection.create',\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n\n    var context = event.context,\n        connection = context.connection;\n\n    var source = connection.source,\n        target = connection.target;\n\n    checkLabelAdjustment(source);\n    checkLabelAdjustment(target);\n  });\n\n\n  this.postExecuted([\n    'label.create'\n  ], function(event) {\n    checkLabelAdjustment(event.context.shape.labelTarget);\n  });\n\n\n  function checkLabelAdjustment(element) {\n\n    // skip non-existing labels\n    if (!hasExternalLabel(element)) {\n      return;\n    }\n\n    var optimalPosition = getOptimalPosition(element);\n\n    // no optimal position found\n    if (!optimalPosition) {\n      return;\n    }\n\n    adjustLabelPosition(element, optimalPosition);\n  }\n\n  var ELEMENT_LABEL_DISTANCE = 10;\n\n  function adjustLabelPosition(element, orientation) {\n\n    var elementMid = getMid(element),\n        label = element.label,\n        labelMid = getMid(label);\n\n    var elementTrbl = asTRBL(element);\n\n    var newLabelMid;\n\n    switch (orientation) {\n    case 'top':\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2\n      };\n\n      break;\n\n    case 'left':\n\n      newLabelMid = {\n        x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n\n    case 'bottom':\n\n      newLabelMid = {\n        x: elementMid.x,\n        y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2\n      };\n\n      break;\n\n    case 'right':\n\n      newLabelMid = {\n        x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,\n        y: elementMid.y\n      };\n\n      break;\n    }\n\n\n    var delta = substract(newLabelMid, labelMid);\n\n    modeling.moveShape(label, delta);\n  }\n\n}\n\ninherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);\n\nAdaptiveLabelPositioningBehavior.$inject = [\n  'eventBus',\n  'modeling'\n];\n\n\n/**\n * Return the optimal label position around an element\n * or _undefined_, if none was found.\n *\n * @param  {Shape} element\n *\n * @return {String} positioning identifier\n */\nfunction getOptimalPosition(element) {\n\n  var labelMid = getMid(element.label);\n\n  var elementMid = getMid(element);\n\n  var labelOrientation = getApproximateOrientation(elementMid, labelMid);\n\n  if (!isAligned(labelOrientation)) {\n    return;\n  }\n\n  var takenAlignments = [].concat(\n    element.incoming.map(function(c) {\n      return c.waypoints[c.waypoints.length - 2 ];\n    }),\n    element.outgoing.map(function(c) {\n      return c.waypoints[1];\n    })\n  ).map(function(point) {\n    return getApproximateOrientation(elementMid, point);\n  });\n\n  var freeAlignments = ALIGNMENTS.filter(function(alignment) {\n\n    return takenAlignments.indexOf(alignment) === -1;\n  });\n\n  // NOTHING TO DO; label already aligned a.O.K.\n  if (freeAlignments.indexOf(labelOrientation) !== -1) {\n    return;\n  }\n\n  return freeAlignments[0];\n}\n\nvar ALIGNMENTS = [\n  'top',\n  'bottom',\n  'left',\n  'right'\n];\n\nfunction getApproximateOrientation(p0, p1) {\n  return getOrientation(p1, p0, 5);\n}\n\nfunction isAligned(orientation) {\n  return ALIGNMENTS.indexOf(orientation) !== -1;\n}\n"]},"metadata":{},"sourceType":"module"}