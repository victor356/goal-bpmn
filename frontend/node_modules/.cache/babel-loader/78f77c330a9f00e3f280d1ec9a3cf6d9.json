{"ast":null,"code":"import { filter } from 'min-dash';\nimport { eachElement } from 'diagram-js/lib/util/Elements';\nimport { getLanesRoot, getChildLanes, LANE_INDENTATION } from '../util/LaneUtil';\n/**\n * A handler that allows us to add a new lane\n * above or below an existing one.\n *\n * @param {Modeling} modeling\n */\n\nexport default function AddLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\nAddLaneHandler.$inject = ['modeling', 'spaceTool'];\n\nAddLaneHandler.prototype.preExecute = function (context) {\n  var spaceTool = this._spaceTool,\n      modeling = this._modeling;\n  var shape = context.shape,\n      location = context.location;\n  var lanesRoot = getLanesRoot(shape);\n  var isRoot = lanesRoot === shape,\n      laneParent = isRoot ? shape : shape.parent;\n  var existingChildLanes = getChildLanes(laneParent); // (0) add a lane if we currently got none and are adding to root\n\n  if (!existingChildLanes.length) {\n    modeling.createShape({\n      type: 'bpmn:Lane'\n    }, {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y,\n      width: shape.width - LANE_INDENTATION,\n      height: shape.height\n    }, laneParent);\n  } // (1) collect affected elements to create necessary space\n\n\n  var allAffected = [];\n  eachElement(lanesRoot, function (element) {\n    allAffected.push(element);\n\n    if (element === shape) {\n      return [];\n    }\n\n    return filter(element.children, function (c) {\n      return c !== shape;\n    });\n  });\n  var offset = location === 'top' ? -120 : 120,\n      lanePosition = location === 'top' ? shape.y : shape.y + shape.height,\n      spacePos = lanePosition + (location === 'top' ? 10 : -10),\n      direction = location === 'top' ? 'n' : 's';\n  var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, {\n    x: 0,\n    y: offset\n  }, direction); // (2) create new lane at open space\n\n  context.newLane = modeling.createShape({\n    type: 'bpmn:Lane'\n  }, {\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\n    y: lanePosition - (location === 'top' ? 120 : 0),\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\n    height: 120\n  }, laneParent);\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/features/modeling/cmd/AddLaneHandler.js"],"names":["filter","eachElement","getLanesRoot","getChildLanes","LANE_INDENTATION","AddLaneHandler","modeling","spaceTool","_modeling","_spaceTool","$inject","prototype","preExecute","context","shape","location","lanesRoot","isRoot","laneParent","parent","existingChildLanes","length","createShape","type","x","y","width","height","allAffected","element","push","children","c","offset","lanePosition","spacePos","direction","adjustments","calculateAdjustments","makeSpace","movingShapes","resizingShapes","newLane"],"mappings":"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","sourcesContent":["import {\n  filter\n} from 'min-dash';\n\nimport {\n  eachElement\n} from 'diagram-js/lib/util/Elements';\n\nimport {\n  getLanesRoot,\n  getChildLanes,\n  LANE_INDENTATION\n} from '../util/LaneUtil';\n\n\n/**\n * A handler that allows us to add a new lane\n * above or below an existing one.\n *\n * @param {Modeling} modeling\n */\nexport default function AddLaneHandler(modeling, spaceTool) {\n  this._modeling = modeling;\n  this._spaceTool = spaceTool;\n}\n\nAddLaneHandler.$inject = [\n  'modeling',\n  'spaceTool'\n];\n\n\nAddLaneHandler.prototype.preExecute = function(context) {\n\n  var spaceTool = this._spaceTool,\n      modeling = this._modeling;\n\n  var shape = context.shape,\n      location = context.location;\n\n  var lanesRoot = getLanesRoot(shape);\n\n  var isRoot = lanesRoot === shape,\n      laneParent = isRoot ? shape : shape.parent;\n\n  var existingChildLanes = getChildLanes(laneParent);\n\n  // (0) add a lane if we currently got none and are adding to root\n  if (!existingChildLanes.length) {\n    modeling.createShape({ type: 'bpmn:Lane' }, {\n      x: shape.x + LANE_INDENTATION,\n      y: shape.y,\n      width: shape.width - LANE_INDENTATION,\n      height: shape.height\n    }, laneParent);\n  }\n\n  // (1) collect affected elements to create necessary space\n  var allAffected = [];\n\n  eachElement(lanesRoot, function(element) {\n    allAffected.push(element);\n\n    if (element === shape) {\n      return [];\n    }\n\n    return filter(element.children, function(c) {\n      return c !== shape;\n    });\n  });\n\n  var offset = location === 'top' ? -120 : 120,\n      lanePosition = location === 'top' ? shape.y : shape.y + shape.height,\n      spacePos = lanePosition + (location === 'top' ? 10 : -10),\n      direction = location === 'top' ? 'n' : 's';\n\n  var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);\n\n  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: offset }, direction);\n\n  // (2) create new lane at open space\n  context.newLane = modeling.createShape({ type: 'bpmn:Lane' }, {\n    x: shape.x + (isRoot ? LANE_INDENTATION : 0),\n    y: lanePosition - (location === 'top' ? 120 : 0),\n    width: shape.width - (isRoot ? LANE_INDENTATION : 0),\n    height: 120\n  }, laneParent);\n};\n"]},"metadata":{},"sourceType":"module"}