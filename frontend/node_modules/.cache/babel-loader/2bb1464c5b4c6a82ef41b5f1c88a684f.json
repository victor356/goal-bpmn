{"ast":null,"code":"'use strict';\n/**\n * Calculate the selection update for the given\n * current and new input values.\n *\n * @param {Object} currentSelection as {start, end}\n * @param {String} currentValue\n * @param {String} newValue\n *\n * @return {Object} newSelection as {start, end}\n */\n\nfunction calculateUpdate(currentSelection, currentValue, newValue) {\n  var currentCursor = currentSelection.start,\n      newCursor = currentCursor,\n      diff = newValue.length - currentValue.length,\n      idx;\n  var lengthDelta = newValue.length - currentValue.length;\n  var currentTail = currentValue.substring(currentCursor); // check if we can remove common ending from the equation\n  // to be able to properly detect a selection change for\n  // the following scenarios:\n  //\n  //  * (AAATTT|TF) => (AAAT|TF)\n  //  * (AAAT|TF) =>  (AAATTT|TF)\n  //\n\n  if (newValue.lastIndexOf(currentTail) === newValue.length - currentTail.length) {\n    currentValue = currentValue.substring(0, currentValue.length - currentTail.length);\n    newValue = newValue.substring(0, newValue.length - currentTail.length);\n  } // diff\n\n\n  var diff = createDiff(currentValue, newValue);\n\n  if (diff) {\n    if (diff.type === 'remove') {\n      newCursor = diff.newStart;\n    } else {\n      newCursor = diff.newEnd;\n    }\n  }\n\n  return range(newCursor);\n}\n\nmodule.exports = calculateUpdate;\n\nfunction createDiff(currentValue, newValue) {\n  var insert;\n  var l_str,\n      l_char,\n      l_idx = 0,\n      s_str,\n      s_char,\n      s_idx = 0;\n\n  if (newValue.length > currentValue.length) {\n    l_str = newValue;\n    s_str = currentValue;\n  } else {\n    l_str = currentValue;\n    s_str = newValue;\n  } // assume there will be only one insert / remove and\n  // detect that _first_ edit operation only\n\n\n  while (l_idx < l_str.length) {\n    l_char = l_str.charAt(l_idx);\n    s_char = s_str.charAt(s_idx); // chars no not equal\n\n    if (l_char !== s_char) {\n      if (!insert) {\n        insert = {\n          l_start: l_idx,\n          s_start: s_idx\n        };\n      }\n\n      l_idx++;\n    } // chars equal (again?)\n    else {\n        if (insert && !insert.complete) {\n          insert.l_end = l_idx;\n          insert.s_end = s_idx;\n          insert.complete = true;\n        }\n\n        s_idx++;\n        l_idx++;\n      }\n  }\n\n  if (insert && !insert.complete) {\n    insert.complete = true;\n    insert.s_end = s_str.length;\n    insert.l_end = l_str.length;\n  } // no diff\n\n\n  if (!insert) {\n    return;\n  }\n\n  if (newValue.length > currentValue.length) {\n    return {\n      newStart: insert.l_start,\n      newEnd: insert.l_end,\n      type: 'add'\n    };\n  } else {\n    return {\n      newStart: insert.s_start,\n      newEnd: insert.s_end,\n      type: newValue.length < currentValue.length ? 'remove' : 'replace'\n    };\n  }\n}\n/**\n * Utility method for creating a new selection range {start, end} object.\n *\n * @param {Number} start\n * @param {Number} [end]\n *\n * @return {Object} selection range as {start, end}\n */\n\n\nfunction range(start, end) {\n  return {\n    start: start,\n    end: end === undefined ? start : end\n  };\n}\n\nmodule.exports.range = range;\n\nfunction splitStr(str, position) {\n  return {\n    before: str.substring(0, position),\n    after: str.substring(position)\n  };\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/selection-update/index.js"],"names":["calculateUpdate","currentSelection","currentValue","newValue","currentCursor","start","newCursor","diff","length","idx","lengthDelta","currentTail","substring","lastIndexOf","createDiff","type","newStart","newEnd","range","module","exports","insert","l_str","l_char","l_idx","s_str","s_char","s_idx","charAt","l_start","s_start","complete","l_end","s_end","end","undefined","splitStr","str","position","before","after"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Calculate the selection update for the given\n * current and new input values.\n *\n * @param {Object} currentSelection as {start, end}\n * @param {String} currentValue\n * @param {String} newValue\n *\n * @return {Object} newSelection as {start, end}\n */\nfunction calculateUpdate(currentSelection, currentValue, newValue) {\n\n  var currentCursor = currentSelection.start,\n      newCursor = currentCursor,\n      diff = newValue.length - currentValue.length,\n      idx;\n\n  var lengthDelta = newValue.length - currentValue.length;\n\n  var currentTail = currentValue.substring(currentCursor);\n\n  // check if we can remove common ending from the equation\n  // to be able to properly detect a selection change for\n  // the following scenarios:\n  //\n  //  * (AAATTT|TF) => (AAAT|TF)\n  //  * (AAAT|TF) =>  (AAATTT|TF)\n  //\n  if (newValue.lastIndexOf(currentTail) === newValue.length - currentTail.length) {\n    currentValue = currentValue.substring(0, currentValue.length - currentTail.length);\n    newValue = newValue.substring(0, newValue.length - currentTail.length);\n  }\n\n  // diff\n  var diff = createDiff(currentValue, newValue);\n\n  if (diff) {\n    if (diff.type === 'remove') {\n      newCursor = diff.newStart;\n    } else {\n      newCursor = diff.newEnd;\n    }\n  }\n\n  return range(newCursor);\n}\n\nmodule.exports = calculateUpdate;\n\n\nfunction createDiff(currentValue, newValue) {\n\n  var insert;\n\n  var l_str, l_char, l_idx = 0,\n      s_str, s_char, s_idx = 0;\n\n  if (newValue.length > currentValue.length) {\n    l_str = newValue;\n    s_str = currentValue;\n  } else {\n    l_str = currentValue;\n    s_str = newValue;\n  }\n\n  // assume there will be only one insert / remove and\n  // detect that _first_ edit operation only\n  while (l_idx < l_str.length) {\n\n    l_char = l_str.charAt(l_idx);\n    s_char = s_str.charAt(s_idx);\n\n    // chars no not equal\n    if (l_char !== s_char) {\n\n      if (!insert) {\n        insert = {\n          l_start: l_idx,\n          s_start: s_idx\n        };\n      }\n\n      l_idx++;\n    }\n\n    // chars equal (again?)\n    else {\n\n      if (insert && !insert.complete) {\n        insert.l_end = l_idx;\n        insert.s_end = s_idx;\n        insert.complete = true;\n      }\n\n      s_idx++;\n      l_idx++;\n    }\n  }\n\n  if (insert && !insert.complete) {\n    insert.complete = true;\n    insert.s_end = s_str.length;\n    insert.l_end = l_str.length;\n  }\n\n  // no diff\n  if (!insert) {\n    return;\n  }\n\n  if (newValue.length > currentValue.length) {\n    return {\n      newStart: insert.l_start,\n      newEnd: insert.l_end,\n      type: 'add'\n    };\n  } else {\n    return {\n      newStart: insert.s_start,\n      newEnd: insert.s_end,\n      type: newValue.length < currentValue.length ? 'remove' : 'replace'\n    };\n  }\n}\n\n/**\n * Utility method for creating a new selection range {start, end} object.\n *\n * @param {Number} start\n * @param {Number} [end]\n *\n * @return {Object} selection range as {start, end}\n */\nfunction range(start, end) {\n  return {\n    start: start,\n    end: end === undefined ? start : end\n  };\n}\n\nmodule.exports.range = range;\n\n\nfunction splitStr(str, position) {\n  return {\n    before: str.substring(0, position),\n    after: str.substring(position)\n  };\n}"]},"metadata":{},"sourceType":"script"}