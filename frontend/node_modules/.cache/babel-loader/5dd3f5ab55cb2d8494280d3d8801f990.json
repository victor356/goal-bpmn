{"ast":null,"code":"import inherits from 'inherits';\nimport { forEach } from 'min-dash';\nimport { getBBox as getBoundingBox } from 'diagram-js/lib/util/Elements';\nimport { is } from '../../util/ModelUtil';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { isExpanded } from '../../util/DiUtil';\nimport Snapping from 'diagram-js/lib/features/snapping/Snapping';\nimport { mid, topLeft, bottomRight, isSnapped, setSnapped } from 'diagram-js/lib/features/snapping/SnapUtil';\nimport { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nimport { getBoundaryAttachment, getParticipantSizeConstraints } from './BpmnSnappingUtil';\nimport { getLanesRoot } from '../modeling/util/LaneUtil';\nvar round = Math.round;\nvar HIGH_PRIORITY = 1500;\n/**\n * BPMN specific snapping functionality\n *\n *  * snap on process elements if a pool is created inside a\n *    process diagram\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\n\nexport default function BpmnSnapping(eventBus, canvas, bpmnRules, elementRegistry) {\n  // instantiate super\n  Snapping.call(this, eventBus, canvas);\n  /**\n   * Drop participant on process <> process elements snapping\n   */\n\n  eventBus.on('create.start', function (event) {\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement(); // snap participant around existing elements (if any)\n\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n  eventBus.on(['create.move', 'create.end'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n        shape = context.shape,\n        participantSnapBox = context.participantSnapBox;\n\n    if (!isSnapped(event) && participantSnapBox) {\n      snapParticipant(participantSnapBox, shape, event);\n    }\n  });\n  eventBus.on('shape.move.start', function (event) {\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement(); // snap participant around existing elements (if any)\n\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n  function canAttach(shape, target, position) {\n    return bpmnRules.canAttach([shape], target, null, position) === 'attach';\n  }\n\n  function canConnect(source, target) {\n    return bpmnRules.canConnect(source, target);\n  }\n  /**\n   * Snap boundary events to elements border\n   */\n\n\n  eventBus.on(['create.move', 'create.end', 'shape.move.move', 'shape.move.end'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n        target = context.target,\n        shape = context.shape;\n\n    if (target && !isSnapped(event) && canAttach(shape, target, event)) {\n      snapBoundaryEvent(event, shape, target);\n    }\n  });\n  /**\n   * Adjust parent for flowElements to the target participant\n   * when droping onto lanes.\n   */\n\n  eventBus.on(['shape.move.hover', 'shape.move.move', 'shape.move.end', 'create.hover', 'create.move', 'create.end'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n        shape = context.shape,\n        hover = event.hover;\n\n    if (is(hover, 'bpmn:Lane') && !isAny(shape, ['bpmn:Lane', 'bpmn:Participant'])) {\n      event.hover = getLanesRoot(hover);\n      event.hoverGfx = elementRegistry.getGraphics(event.hover);\n    }\n  });\n  /**\n   * Snap sequence flows.\n   */\n\n  eventBus.on(['connect.move', 'connect.hover', 'connect.end'], HIGH_PRIORITY, function (event) {\n    var context = event.context,\n        source = context.source,\n        target = context.target;\n    var connection = canConnect(source, target) || {};\n\n    if (!context.initialSourcePosition) {\n      context.initialSourcePosition = context.sourcePosition;\n    }\n\n    if (target && (connection.type === 'bpmn:Association' || connection.type === 'bpmn:DataOutputAssociation' || connection.type === 'bpmn:DataInputAssociation' || connection.type === 'bpmn:SequenceFlow')) {\n      // snap source\n      context.sourcePosition = mid(source); // snap target\n\n      snapToPosition(event, mid(target));\n    } else if (connection.type === 'bpmn:MessageFlow') {\n      if (is(source, 'bpmn:Event')) {\n        // snap source\n        context.sourcePosition = mid(source);\n      }\n\n      if (is(target, 'bpmn:Event')) {\n        // snap target\n        snapToPosition(event, mid(target));\n      }\n    } else {\n      // otherwise reset source snap\n      context.sourcePosition = context.initialSourcePosition;\n    }\n  });\n  eventBus.on('resize.start', HIGH_PRIORITY, function (event) {\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {\n      context.minDimensions = {\n        width: 140,\n        height: 120\n      };\n    }\n\n    if (is(shape, 'bpmn:Participant')) {\n      context.minDimensions = {\n        width: 300,\n        height: 150\n      };\n    }\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n      context.resizeConstraints = getParticipantSizeConstraints(shape, context.direction, context.balanced);\n    }\n\n    if (is(shape, 'bpmn:TextAnnotation')) {\n      context.minDimensions = {\n        width: 50,\n        height: 30\n      };\n    }\n  });\n}\ninherits(BpmnSnapping, Snapping);\nBpmnSnapping.$inject = ['eventBus', 'canvas', 'bpmnRules', 'elementRegistry'];\n\nBpmnSnapping.prototype.initSnap = function (event) {\n  var context = event.context,\n      shape = event.shape,\n      shapeMid,\n      shapeBounds,\n      shapeTopLeft,\n      shapeBottomRight,\n      snapContext;\n  snapContext = Snapping.prototype.initSnap.call(this, event);\n\n  if (is(shape, 'bpmn:Participant')) {\n    // assign higher priority for outer snaps on participants\n    snapContext.setSnapLocations(['top-left', 'bottom-right', 'mid']);\n  }\n\n  if (shape) {\n    shapeMid = mid(shape, event);\n    shapeBounds = {\n      width: shape.width,\n      height: shape.height,\n      x: isNaN(shape.x) ? round(shapeMid.x - shape.width / 2) : shape.x,\n      y: isNaN(shape.y) ? round(shapeMid.y - shape.height / 2) : shape.y\n    };\n    shapeTopLeft = topLeft(shapeBounds);\n    shapeBottomRight = bottomRight(shapeBounds);\n    snapContext.setSnapOrigin('top-left', {\n      x: shapeTopLeft.x - event.x,\n      y: shapeTopLeft.y - event.y\n    });\n    snapContext.setSnapOrigin('bottom-right', {\n      x: shapeBottomRight.x - event.x,\n      y: shapeBottomRight.y - event.y\n    });\n    forEach(shape.outgoing, function (c) {\n      var docking = c.waypoints[0];\n      docking = docking.original || docking;\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n    forEach(shape.incoming, function (c) {\n      var docking = c.waypoints[c.waypoints.length - 1];\n      docking = docking.original || docking;\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n  }\n\n  var source = context.source;\n\n  if (source) {\n    snapContext.addDefaultSnap('mid', mid(source));\n  }\n};\n\nBpmnSnapping.prototype.addTargetSnaps = function (snapPoints, shape, target) {\n  // use target parent as snap target\n  if (is(shape, 'bpmn:BoundaryEvent') && shape.type !== 'label') {\n    target = target.parent;\n  } // add sequence flow parents as snap targets\n\n\n  if (is(target, 'bpmn:SequenceFlow')) {\n    this.addTargetSnaps(snapPoints, shape, target.parent);\n  }\n\n  var siblings = this.getSiblings(shape, target) || [];\n  forEach(siblings, function (sibling) {\n    // do not snap to lanes\n    if (is(sibling, 'bpmn:Lane')) {\n      return;\n    }\n\n    if (sibling.waypoints) {\n      forEach(sibling.waypoints.slice(1, -1), function (waypoint, i) {\n        var nextWaypoint = sibling.waypoints[i + 2],\n            previousWaypoint = sibling.waypoints[i];\n\n        if (!nextWaypoint || !previousWaypoint) {\n          throw new Error('waypoints must exist');\n        }\n\n        if (nextWaypoint.x === waypoint.x || nextWaypoint.y === waypoint.y || previousWaypoint.x === waypoint.x || previousWaypoint.y === waypoint.y) {\n          snapPoints.add('mid', waypoint);\n        }\n      });\n      return;\n    }\n\n    snapPoints.add('mid', mid(sibling));\n\n    if (is(sibling, 'bpmn:Participant')) {\n      snapPoints.add('top-left', topLeft(sibling));\n      snapPoints.add('bottom-right', bottomRight(sibling));\n    }\n  });\n  forEach(shape.incoming, function (c) {\n    if (siblings.indexOf(c.source) === -1) {\n      snapPoints.add('mid', mid(c.source));\n    }\n\n    var docking = c.waypoints[0];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n  forEach(shape.outgoing, function (c) {\n    if (siblings.indexOf(c.target) === -1) {\n      snapPoints.add('mid', mid(c.target));\n    }\n\n    var docking = c.waypoints[c.waypoints.length - 1];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n}; // participant snapping //////////////////////\n\n\nfunction initParticipantSnapping(context, shape, elements) {\n  if (!elements.length) {\n    return;\n  }\n\n  var snapBox = getBoundingBox(elements.filter(function (e) {\n    return !e.labelTarget && !e.waypoints;\n  }));\n  snapBox.x -= 50;\n  snapBox.y -= 20;\n  snapBox.width += 70;\n  snapBox.height += 40; // adjust shape height to include bounding box\n\n  shape.width = Math.max(shape.width, snapBox.width);\n  shape.height = Math.max(shape.height, snapBox.height);\n  context.participantSnapBox = snapBox;\n}\n\nfunction snapParticipant(snapBox, shape, event, offset) {\n  offset = offset || 0;\n  var shapeHalfWidth = shape.width / 2 - offset,\n      shapeHalfHeight = shape.height / 2;\n  var currentTopLeft = {\n    x: event.x - shapeHalfWidth - offset,\n    y: event.y - shapeHalfHeight\n  };\n  var currentBottomRight = {\n    x: event.x + shapeHalfWidth + offset,\n    y: event.y + shapeHalfHeight\n  };\n  var snapTopLeft = snapBox,\n      snapBottomRight = bottomRight(snapBox);\n\n  if (currentTopLeft.x >= snapTopLeft.x) {\n    setSnapped(event, 'x', snapTopLeft.x + offset + shapeHalfWidth);\n  } else if (currentBottomRight.x <= snapBottomRight.x) {\n    setSnapped(event, 'x', snapBottomRight.x - offset - shapeHalfWidth);\n  }\n\n  if (currentTopLeft.y >= snapTopLeft.y) {\n    setSnapped(event, 'y', snapTopLeft.y + shapeHalfHeight);\n  } else if (currentBottomRight.y <= snapBottomRight.y) {\n    setSnapped(event, 'y', snapBottomRight.y - shapeHalfHeight);\n  }\n} // boundary event snapping //////////////////////\n\n\nfunction snapBoundaryEvent(event, shape, target) {\n  var targetTRBL = asTRBL(target);\n  var direction = getBoundaryAttachment(event, target);\n\n  if (/top/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.top);\n  } else if (/bottom/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.bottom);\n  }\n\n  if (/left/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.left);\n  } else if (/right/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.right);\n  }\n}\n\nfunction snapToPosition(event, position) {\n  setSnapped(event, 'x', position.x);\n  setSnapped(event, 'y', position.y);\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/features/snapping/BpmnSnapping.js"],"names":["inherits","forEach","getBBox","getBoundingBox","is","isAny","isExpanded","Snapping","mid","topLeft","bottomRight","isSnapped","setSnapped","asTRBL","getBoundaryAttachment","getParticipantSizeConstraints","getLanesRoot","round","Math","HIGH_PRIORITY","BpmnSnapping","eventBus","canvas","bpmnRules","elementRegistry","call","on","event","context","shape","rootElement","getRootElement","initParticipantSnapping","children","participantSnapBox","snapParticipant","canAttach","target","position","canConnect","source","snapBoundaryEvent","hover","hoverGfx","getGraphics","connection","initialSourcePosition","sourcePosition","type","snapToPosition","minDimensions","width","height","resizeConstraints","direction","balanced","$inject","prototype","initSnap","shapeMid","shapeBounds","shapeTopLeft","shapeBottomRight","snapContext","setSnapLocations","x","isNaN","y","setSnapOrigin","outgoing","c","docking","waypoints","original","id","incoming","length","addDefaultSnap","addTargetSnaps","snapPoints","parent","siblings","getSiblings","sibling","slice","waypoint","i","nextWaypoint","previousWaypoint","Error","add","indexOf","elements","snapBox","filter","e","labelTarget","max","offset","shapeHalfWidth","shapeHalfHeight","currentTopLeft","currentBottomRight","snapTopLeft","snapBottomRight","targetTRBL","test","top","bottom","left","right"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,UAArB;AAEA,SACEC,OADF,QAEO,UAFP;AAIA,SACEC,OAAO,IAAIC,cADb,QAEO,8BAFP;AAIA,SAASC,EAAT,QAAmB,sBAAnB;AAEA,SAASC,KAAT,QAAsB,+BAAtB;AAEA,SACEC,UADF,QAEO,mBAFP;AAIA,OAAOC,QAAP,MAAqB,2CAArB;AAEA,SACEC,GADF,EAEEC,OAFF,EAGEC,WAHF,EAIEC,SAJF,EAKEC,UALF,QAMO,2CANP;AAQA,SACEC,MADF,QAEO,kCAFP;AAKA,SACEC,qBADF,EAEEC,6BAFF,QAGO,oBAHP;AAKA,SACEC,YADF,QAEO,2BAFP;AAIA,IAAIC,KAAK,GAAGC,IAAI,CAACD,KAAjB;AAEA,IAAIE,aAAa,GAAG,IAApB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,YAAT,CAAsBC,QAAtB,EAAgCC,MAAhC,EAAwCC,SAAxC,EAAmDC,eAAnD,EAAoE;AAEjF;AACAjB,EAAAA,QAAQ,CAACkB,IAAT,CAAc,IAAd,EAAoBJ,QAApB,EAA8BC,MAA9B;AAGA;AACF;AACA;;AACED,EAAAA,QAAQ,CAACK,EAAT,CAAY,cAAZ,EAA4B,UAASC,KAAT,EAAgB;AAE1C,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACIC,KAAK,GAAGD,OAAO,CAACC,KADpB;AAAA,QAEIC,WAAW,GAAGR,MAAM,CAACS,cAAP,EAFlB,CAF0C,CAM1C;;AACA,QAAI3B,EAAE,CAACyB,KAAD,EAAQ,kBAAR,CAAF,IAAiCzB,EAAE,CAAC0B,WAAD,EAAc,cAAd,CAAvC,EAAsE;AACpEE,MAAAA,uBAAuB,CAACJ,OAAD,EAAUC,KAAV,EAAiBC,WAAW,CAACG,QAA7B,CAAvB;AACD;AACF,GAVD;AAYAZ,EAAAA,QAAQ,CAACK,EAAT,CAAY,CAAE,aAAF,EAAiB,YAAjB,CAAZ,EAA6CP,aAA7C,EAA4D,UAASQ,KAAT,EAAgB;AAE1E,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACIC,KAAK,GAAGD,OAAO,CAACC,KADpB;AAAA,QAEIK,kBAAkB,GAAGN,OAAO,CAACM,kBAFjC;;AAIA,QAAI,CAACvB,SAAS,CAACgB,KAAD,CAAV,IAAqBO,kBAAzB,EAA6C;AAC3CC,MAAAA,eAAe,CAACD,kBAAD,EAAqBL,KAArB,EAA4BF,KAA5B,CAAf;AACD;AACF,GATD;AAWAN,EAAAA,QAAQ,CAACK,EAAT,CAAY,kBAAZ,EAAgC,UAASC,KAAT,EAAgB;AAE9C,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACIC,KAAK,GAAGD,OAAO,CAACC,KADpB;AAAA,QAEIC,WAAW,GAAGR,MAAM,CAACS,cAAP,EAFlB,CAF8C,CAM9C;;AACA,QAAI3B,EAAE,CAACyB,KAAD,EAAQ,kBAAR,CAAF,IAAiCzB,EAAE,CAAC0B,WAAD,EAAc,cAAd,CAAvC,EAAsE;AACpEE,MAAAA,uBAAuB,CAACJ,OAAD,EAAUC,KAAV,EAAiBC,WAAW,CAACG,QAA7B,CAAvB;AACD;AACF,GAVD;;AAaA,WAASG,SAAT,CAAmBP,KAAnB,EAA0BQ,MAA1B,EAAkCC,QAAlC,EAA4C;AAC1C,WAAOf,SAAS,CAACa,SAAV,CAAoB,CAAEP,KAAF,CAApB,EAA+BQ,MAA/B,EAAuC,IAAvC,EAA6CC,QAA7C,MAA2D,QAAlE;AACD;;AAED,WAASC,UAAT,CAAoBC,MAApB,EAA4BH,MAA5B,EAAoC;AAClC,WAAOd,SAAS,CAACgB,UAAV,CAAqBC,MAArB,EAA6BH,MAA7B,CAAP;AACD;AAED;AACF;AACA;;;AACEhB,EAAAA,QAAQ,CAACK,EAAT,CAAY,CACV,aADU,EAEV,YAFU,EAGV,iBAHU,EAIV,gBAJU,CAAZ,EAKGP,aALH,EAKkB,UAASQ,KAAT,EAAgB;AAEhC,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACIS,MAAM,GAAGT,OAAO,CAACS,MADrB;AAAA,QAEIR,KAAK,GAAGD,OAAO,CAACC,KAFpB;;AAIA,QAAIQ,MAAM,IAAI,CAAC1B,SAAS,CAACgB,KAAD,CAApB,IAA+BS,SAAS,CAACP,KAAD,EAAQQ,MAAR,EAAgBV,KAAhB,CAA5C,EAAoE;AAClEc,MAAAA,iBAAiB,CAACd,KAAD,EAAQE,KAAR,EAAeQ,MAAf,CAAjB;AACD;AACF,GAdD;AAgBA;AACF;AACA;AACA;;AACEhB,EAAAA,QAAQ,CAACK,EAAT,CAAY,CACV,kBADU,EAEV,iBAFU,EAGV,gBAHU,EAIV,cAJU,EAKV,aALU,EAMV,YANU,CAAZ,EAOGP,aAPH,EAOkB,UAASQ,KAAT,EAAgB;AAChC,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACIC,KAAK,GAAGD,OAAO,CAACC,KADpB;AAAA,QAEIa,KAAK,GAAGf,KAAK,CAACe,KAFlB;;AAIA,QAAItC,EAAE,CAACsC,KAAD,EAAQ,WAAR,CAAF,IAA0B,CAACrC,KAAK,CAACwB,KAAD,EAAQ,CAAE,WAAF,EAAe,kBAAf,CAAR,CAApC,EAAkF;AAChFF,MAAAA,KAAK,CAACe,KAAN,GAAc1B,YAAY,CAAC0B,KAAD,CAA1B;AACAf,MAAAA,KAAK,CAACgB,QAAN,GAAiBnB,eAAe,CAACoB,WAAhB,CAA4BjB,KAAK,CAACe,KAAlC,CAAjB;AACD;AACF,GAhBD;AAkBA;AACF;AACA;;AACErB,EAAAA,QAAQ,CAACK,EAAT,CAAY,CACV,cADU,EAEV,eAFU,EAGV,aAHU,CAAZ,EAIGP,aAJH,EAIkB,UAASQ,KAAT,EAAgB;AAChC,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACIY,MAAM,GAAGZ,OAAO,CAACY,MADrB;AAAA,QAEIH,MAAM,GAAGT,OAAO,CAACS,MAFrB;AAIA,QAAIQ,UAAU,GAAGN,UAAU,CAACC,MAAD,EAASH,MAAT,CAAV,IAA8B,EAA/C;;AAEA,QAAI,CAACT,OAAO,CAACkB,qBAAb,EAAoC;AAClClB,MAAAA,OAAO,CAACkB,qBAAR,GAAgClB,OAAO,CAACmB,cAAxC;AACD;;AAED,QACEV,MAAM,KACJQ,UAAU,CAACG,IAAX,KAAoB,kBAApB,IACAH,UAAU,CAACG,IAAX,KAAoB,4BADpB,IAEAH,UAAU,CAACG,IAAX,KAAoB,2BAFpB,IAGAH,UAAU,CAACG,IAAX,KAAoB,mBAJhB,CADR,EAOE;AACA;AACApB,MAAAA,OAAO,CAACmB,cAAR,GAAyBvC,GAAG,CAACgC,MAAD,CAA5B,CAFA,CAIA;;AACAS,MAAAA,cAAc,CAACtB,KAAD,EAAQnB,GAAG,CAAC6B,MAAD,CAAX,CAAd;AACD,KAbD,MAeA,IAAIQ,UAAU,CAACG,IAAX,KAAoB,kBAAxB,EAA4C;AAE1C,UAAI5C,EAAE,CAACoC,MAAD,EAAS,YAAT,CAAN,EAA8B;AAC5B;AACAZ,QAAAA,OAAO,CAACmB,cAAR,GAAyBvC,GAAG,CAACgC,MAAD,CAA5B;AACD;;AAED,UAAIpC,EAAE,CAACiC,MAAD,EAAS,YAAT,CAAN,EAA8B;AAC5B;AACAY,QAAAA,cAAc,CAACtB,KAAD,EAAQnB,GAAG,CAAC6B,MAAD,CAAX,CAAd;AACD;AACF,KAXD,MAaK;AACH;AACAT,MAAAA,OAAO,CAACmB,cAAR,GAAyBnB,OAAO,CAACkB,qBAAjC;AACD;AAEF,GAhDD;AAmDAzB,EAAAA,QAAQ,CAACK,EAAT,CAAY,cAAZ,EAA4BP,aAA5B,EAA2C,UAASQ,KAAT,EAAgB;AACzD,QAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,QACIC,KAAK,GAAGD,OAAO,CAACC,KADpB;;AAGA,QAAIzB,EAAE,CAACyB,KAAD,EAAQ,iBAAR,CAAF,IAAgCvB,UAAU,CAACuB,KAAD,CAA9C,EAAuD;AACrDD,MAAAA,OAAO,CAACsB,aAAR,GAAwB;AAAEC,QAAAA,KAAK,EAAE,GAAT;AAAcC,QAAAA,MAAM,EAAE;AAAtB,OAAxB;AACD;;AAED,QAAIhD,EAAE,CAACyB,KAAD,EAAQ,kBAAR,CAAN,EAAmC;AACjCD,MAAAA,OAAO,CAACsB,aAAR,GAAwB;AAAEC,QAAAA,KAAK,EAAE,GAAT;AAAcC,QAAAA,MAAM,EAAE;AAAtB,OAAxB;AACD;;AAED,QAAIhD,EAAE,CAACyB,KAAD,EAAQ,WAAR,CAAF,IAA0BzB,EAAE,CAACyB,KAAD,EAAQ,kBAAR,CAAhC,EAA6D;AAC3DD,MAAAA,OAAO,CAACyB,iBAAR,GAA4BtC,6BAA6B,CACvDc,KADuD,EAEvDD,OAAO,CAAC0B,SAF+C,EAGvD1B,OAAO,CAAC2B,QAH+C,CAAzD;AAKD;;AAED,QAAInD,EAAE,CAACyB,KAAD,EAAQ,qBAAR,CAAN,EAAsC;AACpCD,MAAAA,OAAO,CAACsB,aAAR,GAAwB;AAAEC,QAAAA,KAAK,EAAE,EAAT;AAAaC,QAAAA,MAAM,EAAE;AAArB,OAAxB;AACD;AACF,GAvBD;AAyBD;AAEDpD,QAAQ,CAACoB,YAAD,EAAeb,QAAf,CAAR;AAEAa,YAAY,CAACoC,OAAb,GAAuB,CACrB,UADqB,EAErB,QAFqB,EAGrB,WAHqB,EAIrB,iBAJqB,CAAvB;;AAQApC,YAAY,CAACqC,SAAb,CAAuBC,QAAvB,GAAkC,UAAS/B,KAAT,EAAgB;AAEhD,MAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAAA,MACIC,KAAK,GAAGF,KAAK,CAACE,KADlB;AAAA,MAEI8B,QAFJ;AAAA,MAGIC,WAHJ;AAAA,MAIIC,YAJJ;AAAA,MAKIC,gBALJ;AAAA,MAMIC,WANJ;AASAA,EAAAA,WAAW,GAAGxD,QAAQ,CAACkD,SAAT,CAAmBC,QAAnB,CAA4BjC,IAA5B,CAAiC,IAAjC,EAAuCE,KAAvC,CAAd;;AAEA,MAAIvB,EAAE,CAACyB,KAAD,EAAQ,kBAAR,CAAN,EAAmC;AACjC;AACAkC,IAAAA,WAAW,CAACC,gBAAZ,CAA6B,CAAE,UAAF,EAAc,cAAd,EAA8B,KAA9B,CAA7B;AACD;;AAGD,MAAInC,KAAJ,EAAW;AAET8B,IAAAA,QAAQ,GAAGnD,GAAG,CAACqB,KAAD,EAAQF,KAAR,CAAd;AAEAiC,IAAAA,WAAW,GAAG;AACZT,MAAAA,KAAK,EAAEtB,KAAK,CAACsB,KADD;AAEZC,MAAAA,MAAM,EAAEvB,KAAK,CAACuB,MAFF;AAGZa,MAAAA,CAAC,EAAEC,KAAK,CAACrC,KAAK,CAACoC,CAAP,CAAL,GAAiBhD,KAAK,CAAC0C,QAAQ,CAACM,CAAT,GAAapC,KAAK,CAACsB,KAAN,GAAc,CAA5B,CAAtB,GAAuDtB,KAAK,CAACoC,CAHpD;AAIZE,MAAAA,CAAC,EAAED,KAAK,CAACrC,KAAK,CAACsC,CAAP,CAAL,GAAiBlD,KAAK,CAAC0C,QAAQ,CAACQ,CAAT,GAAatC,KAAK,CAACuB,MAAN,GAAe,CAA7B,CAAtB,GAAwDvB,KAAK,CAACsC;AAJrD,KAAd;AAOAN,IAAAA,YAAY,GAAGpD,OAAO,CAACmD,WAAD,CAAtB;AACAE,IAAAA,gBAAgB,GAAGpD,WAAW,CAACkD,WAAD,CAA9B;AAEAG,IAAAA,WAAW,CAACK,aAAZ,CAA0B,UAA1B,EAAsC;AACpCH,MAAAA,CAAC,EAAEJ,YAAY,CAACI,CAAb,GAAiBtC,KAAK,CAACsC,CADU;AAEpCE,MAAAA,CAAC,EAAEN,YAAY,CAACM,CAAb,GAAiBxC,KAAK,CAACwC;AAFU,KAAtC;AAKAJ,IAAAA,WAAW,CAACK,aAAZ,CAA0B,cAA1B,EAA0C;AACxCH,MAAAA,CAAC,EAAEH,gBAAgB,CAACG,CAAjB,GAAqBtC,KAAK,CAACsC,CADU;AAExCE,MAAAA,CAAC,EAAEL,gBAAgB,CAACK,CAAjB,GAAqBxC,KAAK,CAACwC;AAFU,KAA1C;AAKAlE,IAAAA,OAAO,CAAC4B,KAAK,CAACwC,QAAP,EAAiB,UAASC,CAAT,EAAY;AAClC,UAAIC,OAAO,GAAGD,CAAC,CAACE,SAAF,CAAY,CAAZ,CAAd;AAEAD,MAAAA,OAAO,GAAGA,OAAO,CAACE,QAAR,IAAoBF,OAA9B;AAEAR,MAAAA,WAAW,CAACK,aAAZ,CAA0BE,CAAC,CAACI,EAAF,GAAO,UAAjC,EAA6C;AAC3CT,QAAAA,CAAC,EAAEM,OAAO,CAACN,CAAR,GAAYtC,KAAK,CAACsC,CADsB;AAE3CE,QAAAA,CAAC,EAAEI,OAAO,CAACJ,CAAR,GAAYxC,KAAK,CAACwC;AAFsB,OAA7C;AAID,KATM,CAAP;AAWAlE,IAAAA,OAAO,CAAC4B,KAAK,CAAC8C,QAAP,EAAiB,UAASL,CAAT,EAAY;AAClC,UAAIC,OAAO,GAAGD,CAAC,CAACE,SAAF,CAAYF,CAAC,CAACE,SAAF,CAAYI,MAAZ,GAAqB,CAAjC,CAAd;AAEAL,MAAAA,OAAO,GAAGA,OAAO,CAACE,QAAR,IAAoBF,OAA9B;AAEAR,MAAAA,WAAW,CAACK,aAAZ,CAA0BE,CAAC,CAACI,EAAF,GAAO,UAAjC,EAA6C;AAC3CT,QAAAA,CAAC,EAAEM,OAAO,CAACN,CAAR,GAAYtC,KAAK,CAACsC,CADsB;AAE3CE,QAAAA,CAAC,EAAEI,OAAO,CAACJ,CAAR,GAAYxC,KAAK,CAACwC;AAFsB,OAA7C;AAID,KATM,CAAP;AAWD;;AAED,MAAI3B,MAAM,GAAGZ,OAAO,CAACY,MAArB;;AAEA,MAAIA,MAAJ,EAAY;AACVuB,IAAAA,WAAW,CAACc,cAAZ,CAA2B,KAA3B,EAAkCrE,GAAG,CAACgC,MAAD,CAArC;AACD;AACF,CAxED;;AA2EApB,YAAY,CAACqC,SAAb,CAAuBqB,cAAvB,GAAwC,UAASC,UAAT,EAAqBlD,KAArB,EAA4BQ,MAA5B,EAAoC;AAE1E;AACA,MAAIjC,EAAE,CAACyB,KAAD,EAAQ,oBAAR,CAAF,IAAmCA,KAAK,CAACmB,IAAN,KAAe,OAAtD,EAA+D;AAC7DX,IAAAA,MAAM,GAAGA,MAAM,CAAC2C,MAAhB;AACD,GALyE,CAO1E;;;AACA,MAAI5E,EAAE,CAACiC,MAAD,EAAS,mBAAT,CAAN,EAAqC;AACnC,SAAKyC,cAAL,CAAoBC,UAApB,EAAgClD,KAAhC,EAAuCQ,MAAM,CAAC2C,MAA9C;AACD;;AAED,MAAIC,QAAQ,GAAG,KAAKC,WAAL,CAAiBrD,KAAjB,EAAwBQ,MAAxB,KAAmC,EAAlD;AAEApC,EAAAA,OAAO,CAACgF,QAAD,EAAW,UAASE,OAAT,EAAkB;AAElC;AACA,QAAI/E,EAAE,CAAC+E,OAAD,EAAU,WAAV,CAAN,EAA8B;AAC5B;AACD;;AAED,QAAIA,OAAO,CAACX,SAAZ,EAAuB;AAErBvE,MAAAA,OAAO,CAACkF,OAAO,CAACX,SAAR,CAAkBY,KAAlB,CAAwB,CAAxB,EAA2B,CAAC,CAA5B,CAAD,EAAiC,UAASC,QAAT,EAAmBC,CAAnB,EAAsB;AAC5D,YAAIC,YAAY,GAAGJ,OAAO,CAACX,SAAR,CAAkBc,CAAC,GAAG,CAAtB,CAAnB;AAAA,YACIE,gBAAgB,GAAGL,OAAO,CAACX,SAAR,CAAkBc,CAAlB,CADvB;;AAGA,YAAI,CAACC,YAAD,IAAiB,CAACC,gBAAtB,EAAwC;AACtC,gBAAM,IAAIC,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,YAAIF,YAAY,CAACtB,CAAb,KAAmBoB,QAAQ,CAACpB,CAA5B,IACAsB,YAAY,CAACpB,CAAb,KAAmBkB,QAAQ,CAAClB,CAD5B,IAEAqB,gBAAgB,CAACvB,CAAjB,KAAuBoB,QAAQ,CAACpB,CAFhC,IAGAuB,gBAAgB,CAACrB,CAAjB,KAAuBkB,QAAQ,CAAClB,CAHpC,EAGuC;AACrCY,UAAAA,UAAU,CAACW,GAAX,CAAe,KAAf,EAAsBL,QAAtB;AACD;AACF,OAdM,CAAP;AAgBA;AACD;;AAEDN,IAAAA,UAAU,CAACW,GAAX,CAAe,KAAf,EAAsBlF,GAAG,CAAC2E,OAAD,CAAzB;;AAEA,QAAI/E,EAAE,CAAC+E,OAAD,EAAU,kBAAV,CAAN,EAAqC;AACnCJ,MAAAA,UAAU,CAACW,GAAX,CAAe,UAAf,EAA2BjF,OAAO,CAAC0E,OAAD,CAAlC;AACAJ,MAAAA,UAAU,CAACW,GAAX,CAAe,cAAf,EAA+BhF,WAAW,CAACyE,OAAD,CAA1C;AACD;AACF,GAlCM,CAAP;AAqCAlF,EAAAA,OAAO,CAAC4B,KAAK,CAAC8C,QAAP,EAAiB,UAASL,CAAT,EAAY;AAElC,QAAIW,QAAQ,CAACU,OAAT,CAAiBrB,CAAC,CAAC9B,MAAnB,MAA+B,CAAC,CAApC,EAAuC;AACrCuC,MAAAA,UAAU,CAACW,GAAX,CAAe,KAAf,EAAsBlF,GAAG,CAAC8D,CAAC,CAAC9B,MAAH,CAAzB;AACD;;AAED,QAAI+B,OAAO,GAAGD,CAAC,CAACE,SAAF,CAAY,CAAZ,CAAd;AACAO,IAAAA,UAAU,CAACW,GAAX,CAAepB,CAAC,CAACI,EAAF,GAAO,UAAtB,EAAkCH,OAAO,CAACE,QAAR,IAAoBF,OAAtD;AACD,GARM,CAAP;AAWAtE,EAAAA,OAAO,CAAC4B,KAAK,CAACwC,QAAP,EAAiB,UAASC,CAAT,EAAY;AAElC,QAAIW,QAAQ,CAACU,OAAT,CAAiBrB,CAAC,CAACjC,MAAnB,MAA+B,CAAC,CAApC,EAAuC;AACrC0C,MAAAA,UAAU,CAACW,GAAX,CAAe,KAAf,EAAsBlF,GAAG,CAAC8D,CAAC,CAACjC,MAAH,CAAzB;AACD;;AAED,QAAIkC,OAAO,GAAGD,CAAC,CAACE,SAAF,CAAYF,CAAC,CAACE,SAAF,CAAYI,MAAZ,GAAqB,CAAjC,CAAd;AACAG,IAAAA,UAAU,CAACW,GAAX,CAAepB,CAAC,CAACI,EAAF,GAAO,UAAtB,EAAkCH,OAAO,CAACE,QAAR,IAAoBF,OAAtD;AACD,GARM,CAAP;AASD,CAvED,C,CA0EA;;;AAEA,SAASvC,uBAAT,CAAiCJ,OAAjC,EAA0CC,KAA1C,EAAiD+D,QAAjD,EAA2D;AAEzD,MAAI,CAACA,QAAQ,CAAChB,MAAd,EAAsB;AACpB;AACD;;AAED,MAAIiB,OAAO,GAAG1F,cAAc,CAACyF,QAAQ,CAACE,MAAT,CAAgB,UAASC,CAAT,EAAY;AACvD,WAAO,CAACA,CAAC,CAACC,WAAH,IAAkB,CAACD,CAAC,CAACvB,SAA5B;AACD,GAF4B,CAAD,CAA5B;AAIAqB,EAAAA,OAAO,CAAC5B,CAAR,IAAa,EAAb;AACA4B,EAAAA,OAAO,CAAC1B,CAAR,IAAa,EAAb;AACA0B,EAAAA,OAAO,CAAC1C,KAAR,IAAiB,EAAjB;AACA0C,EAAAA,OAAO,CAACzC,MAAR,IAAkB,EAAlB,CAbyD,CAezD;;AACAvB,EAAAA,KAAK,CAACsB,KAAN,GAAcjC,IAAI,CAAC+E,GAAL,CAASpE,KAAK,CAACsB,KAAf,EAAsB0C,OAAO,CAAC1C,KAA9B,CAAd;AACAtB,EAAAA,KAAK,CAACuB,MAAN,GAAelC,IAAI,CAAC+E,GAAL,CAASpE,KAAK,CAACuB,MAAf,EAAuByC,OAAO,CAACzC,MAA/B,CAAf;AAEAxB,EAAAA,OAAO,CAACM,kBAAR,GAA6B2D,OAA7B;AACD;;AAED,SAAS1D,eAAT,CAAyB0D,OAAzB,EAAkChE,KAAlC,EAAyCF,KAAzC,EAAgDuE,MAAhD,EAAwD;AACtDA,EAAAA,MAAM,GAAGA,MAAM,IAAI,CAAnB;AAEA,MAAIC,cAAc,GAAGtE,KAAK,CAACsB,KAAN,GAAc,CAAd,GAAkB+C,MAAvC;AAAA,MACIE,eAAe,GAAGvE,KAAK,CAACuB,MAAN,GAAe,CADrC;AAGA,MAAIiD,cAAc,GAAG;AACnBpC,IAAAA,CAAC,EAAEtC,KAAK,CAACsC,CAAN,GAAUkC,cAAV,GAA2BD,MADX;AAEnB/B,IAAAA,CAAC,EAAExC,KAAK,CAACwC,CAAN,GAAUiC;AAFM,GAArB;AAKA,MAAIE,kBAAkB,GAAG;AACvBrC,IAAAA,CAAC,EAAEtC,KAAK,CAACsC,CAAN,GAAUkC,cAAV,GAA2BD,MADP;AAEvB/B,IAAAA,CAAC,EAAExC,KAAK,CAACwC,CAAN,GAAUiC;AAFU,GAAzB;AAKA,MAAIG,WAAW,GAAGV,OAAlB;AAAA,MACIW,eAAe,GAAG9F,WAAW,CAACmF,OAAD,CADjC;;AAGA,MAAIQ,cAAc,CAACpC,CAAf,IAAoBsC,WAAW,CAACtC,CAApC,EAAuC;AACrCrD,IAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAa4E,WAAW,CAACtC,CAAZ,GAAgBiC,MAAhB,GAAyBC,cAAtC,CAAV;AACD,GAFD,MAGA,IAAIG,kBAAkB,CAACrC,CAAnB,IAAwBuC,eAAe,CAACvC,CAA5C,EAA+C;AAC7CrD,IAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAa6E,eAAe,CAACvC,CAAhB,GAAoBiC,MAApB,GAA6BC,cAA1C,CAAV;AACD;;AAED,MAAIE,cAAc,CAAClC,CAAf,IAAoBoC,WAAW,CAACpC,CAApC,EAAuC;AACrCvD,IAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAa4E,WAAW,CAACpC,CAAZ,GAAgBiC,eAA7B,CAAV;AACD,GAFD,MAGA,IAAIE,kBAAkB,CAACnC,CAAnB,IAAwBqC,eAAe,CAACrC,CAA5C,EAA+C;AAC7CvD,IAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAa6E,eAAe,CAACrC,CAAhB,GAAoBiC,eAAjC,CAAV;AACD;AACF,C,CAGD;;;AAEA,SAAS3D,iBAAT,CAA2Bd,KAA3B,EAAkCE,KAAlC,EAAyCQ,MAAzC,EAAiD;AAC/C,MAAIoE,UAAU,GAAG5F,MAAM,CAACwB,MAAD,CAAvB;AAEA,MAAIiB,SAAS,GAAGxC,qBAAqB,CAACa,KAAD,EAAQU,MAAR,CAArC;;AAEA,MAAI,MAAMqE,IAAN,CAAWpD,SAAX,CAAJ,EAA2B;AACzB1C,IAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAa8E,UAAU,CAACE,GAAxB,CAAV;AACD,GAFD,MAGA,IAAI,SAASD,IAAT,CAAcpD,SAAd,CAAJ,EAA8B;AAC5B1C,IAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAa8E,UAAU,CAACG,MAAxB,CAAV;AACD;;AAED,MAAI,OAAOF,IAAP,CAAYpD,SAAZ,CAAJ,EAA4B;AAC1B1C,IAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAa8E,UAAU,CAACI,IAAxB,CAAV;AACD,GAFD,MAGA,IAAI,QAAQH,IAAR,CAAapD,SAAb,CAAJ,EAA6B;AAC3B1C,IAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAa8E,UAAU,CAACK,KAAxB,CAAV;AACD;AACF;;AAGD,SAAS7D,cAAT,CAAwBtB,KAAxB,EAA+BW,QAA/B,EAAyC;AACvC1B,EAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAaW,QAAQ,CAAC2B,CAAtB,CAAV;AACArD,EAAAA,UAAU,CAACe,KAAD,EAAQ,GAAR,EAAaW,QAAQ,CAAC6B,CAAtB,CAAV;AACD","sourcesContent":["import inherits from 'inherits';\n\nimport {\n  forEach\n} from 'min-dash';\n\nimport {\n  getBBox as getBoundingBox\n} from 'diagram-js/lib/util/Elements';\n\nimport { is } from '../../util/ModelUtil';\n\nimport { isAny } from '../modeling/util/ModelingUtil';\n\nimport {\n  isExpanded\n} from '../../util/DiUtil';\n\nimport Snapping from 'diagram-js/lib/features/snapping/Snapping';\n\nimport {\n  mid,\n  topLeft,\n  bottomRight,\n  isSnapped,\n  setSnapped\n} from 'diagram-js/lib/features/snapping/SnapUtil';\n\nimport {\n  asTRBL\n} from 'diagram-js/lib/layout/LayoutUtil';\n\n\nimport {\n  getBoundaryAttachment,\n  getParticipantSizeConstraints\n} from './BpmnSnappingUtil';\n\nimport {\n  getLanesRoot\n} from '../modeling/util/LaneUtil';\n\nvar round = Math.round;\n\nvar HIGH_PRIORITY = 1500;\n\n\n/**\n * BPMN specific snapping functionality\n *\n *  * snap on process elements if a pool is created inside a\n *    process diagram\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\nexport default function BpmnSnapping(eventBus, canvas, bpmnRules, elementRegistry) {\n\n  // instantiate super\n  Snapping.call(this, eventBus, canvas);\n\n\n  /**\n   * Drop participant on process <> process elements snapping\n   */\n  eventBus.on('create.start', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    // snap participant around existing elements (if any)\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n  eventBus.on([ 'create.move', 'create.end' ], HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        participantSnapBox = context.participantSnapBox;\n\n    if (!isSnapped(event) && participantSnapBox) {\n      snapParticipant(participantSnapBox, shape, event);\n    }\n  });\n\n  eventBus.on('shape.move.start', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    // snap participant around existing elements (if any)\n    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {\n      initParticipantSnapping(context, shape, rootElement.children);\n    }\n  });\n\n\n  function canAttach(shape, target, position) {\n    return bpmnRules.canAttach([ shape ], target, null, position) === 'attach';\n  }\n\n  function canConnect(source, target) {\n    return bpmnRules.canConnect(source, target);\n  }\n\n  /**\n   * Snap boundary events to elements border\n   */\n  eventBus.on([\n    'create.move',\n    'create.end',\n    'shape.move.move',\n    'shape.move.end'\n  ], HIGH_PRIORITY, function(event) {\n\n    var context = event.context,\n        target = context.target,\n        shape = context.shape;\n\n    if (target && !isSnapped(event) && canAttach(shape, target, event)) {\n      snapBoundaryEvent(event, shape, target);\n    }\n  });\n\n  /**\n   * Adjust parent for flowElements to the target participant\n   * when droping onto lanes.\n   */\n  eventBus.on([\n    'shape.move.hover',\n    'shape.move.move',\n    'shape.move.end',\n    'create.hover',\n    'create.move',\n    'create.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape,\n        hover = event.hover;\n\n    if (is(hover, 'bpmn:Lane') && !isAny(shape, [ 'bpmn:Lane', 'bpmn:Participant' ])) {\n      event.hover = getLanesRoot(hover);\n      event.hoverGfx = elementRegistry.getGraphics(event.hover);\n    }\n  });\n\n  /**\n   * Snap sequence flows.\n   */\n  eventBus.on([\n    'connect.move',\n    'connect.hover',\n    'connect.end'\n  ], HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        source = context.source,\n        target = context.target;\n\n    var connection = canConnect(source, target) || {};\n\n    if (!context.initialSourcePosition) {\n      context.initialSourcePosition = context.sourcePosition;\n    }\n\n    if (\n      target && (\n        connection.type === 'bpmn:Association' ||\n        connection.type === 'bpmn:DataOutputAssociation' ||\n        connection.type === 'bpmn:DataInputAssociation' ||\n        connection.type === 'bpmn:SequenceFlow'\n      )\n    ) {\n      // snap source\n      context.sourcePosition = mid(source);\n\n      // snap target\n      snapToPosition(event, mid(target));\n    } else\n\n    if (connection.type === 'bpmn:MessageFlow') {\n\n      if (is(source, 'bpmn:Event')) {\n        // snap source\n        context.sourcePosition = mid(source);\n      }\n\n      if (is(target, 'bpmn:Event')) {\n        // snap target\n        snapToPosition(event, mid(target));\n      }\n    }\n\n    else {\n      // otherwise reset source snap\n      context.sourcePosition = context.initialSourcePosition;\n    }\n\n  });\n\n\n  eventBus.on('resize.start', HIGH_PRIORITY, function(event) {\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {\n      context.minDimensions = { width: 140, height: 120 };\n    }\n\n    if (is(shape, 'bpmn:Participant')) {\n      context.minDimensions = { width: 300, height: 150 };\n    }\n\n    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {\n      context.resizeConstraints = getParticipantSizeConstraints(\n        shape,\n        context.direction,\n        context.balanced\n      );\n    }\n\n    if (is(shape, 'bpmn:TextAnnotation')) {\n      context.minDimensions = { width: 50, height: 30 };\n    }\n  });\n\n}\n\ninherits(BpmnSnapping, Snapping);\n\nBpmnSnapping.$inject = [\n  'eventBus',\n  'canvas',\n  'bpmnRules',\n  'elementRegistry'\n];\n\n\nBpmnSnapping.prototype.initSnap = function(event) {\n\n  var context = event.context,\n      shape = event.shape,\n      shapeMid,\n      shapeBounds,\n      shapeTopLeft,\n      shapeBottomRight,\n      snapContext;\n\n\n  snapContext = Snapping.prototype.initSnap.call(this, event);\n\n  if (is(shape, 'bpmn:Participant')) {\n    // assign higher priority for outer snaps on participants\n    snapContext.setSnapLocations([ 'top-left', 'bottom-right', 'mid' ]);\n  }\n\n\n  if (shape) {\n\n    shapeMid = mid(shape, event);\n\n    shapeBounds = {\n      width: shape.width,\n      height: shape.height,\n      x: isNaN(shape.x) ? round(shapeMid.x - shape.width / 2) : shape.x,\n      y: isNaN(shape.y) ? round(shapeMid.y - shape.height / 2) : shape.y\n    };\n\n    shapeTopLeft = topLeft(shapeBounds);\n    shapeBottomRight = bottomRight(shapeBounds);\n\n    snapContext.setSnapOrigin('top-left', {\n      x: shapeTopLeft.x - event.x,\n      y: shapeTopLeft.y - event.y\n    });\n\n    snapContext.setSnapOrigin('bottom-right', {\n      x: shapeBottomRight.x - event.x,\n      y: shapeBottomRight.y - event.y\n    });\n\n    forEach(shape.outgoing, function(c) {\n      var docking = c.waypoints[0];\n\n      docking = docking.original || docking;\n\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n\n    forEach(shape.incoming, function(c) {\n      var docking = c.waypoints[c.waypoints.length - 1];\n\n      docking = docking.original || docking;\n\n      snapContext.setSnapOrigin(c.id + '-docking', {\n        x: docking.x - event.x,\n        y: docking.y - event.y\n      });\n    });\n\n  }\n\n  var source = context.source;\n\n  if (source) {\n    snapContext.addDefaultSnap('mid', mid(source));\n  }\n};\n\n\nBpmnSnapping.prototype.addTargetSnaps = function(snapPoints, shape, target) {\n\n  // use target parent as snap target\n  if (is(shape, 'bpmn:BoundaryEvent') && shape.type !== 'label') {\n    target = target.parent;\n  }\n\n  // add sequence flow parents as snap targets\n  if (is(target, 'bpmn:SequenceFlow')) {\n    this.addTargetSnaps(snapPoints, shape, target.parent);\n  }\n\n  var siblings = this.getSiblings(shape, target) || [];\n\n  forEach(siblings, function(sibling) {\n\n    // do not snap to lanes\n    if (is(sibling, 'bpmn:Lane')) {\n      return;\n    }\n\n    if (sibling.waypoints) {\n\n      forEach(sibling.waypoints.slice(1, -1), function(waypoint, i) {\n        var nextWaypoint = sibling.waypoints[i + 2],\n            previousWaypoint = sibling.waypoints[i];\n\n        if (!nextWaypoint || !previousWaypoint) {\n          throw new Error('waypoints must exist');\n        }\n\n        if (nextWaypoint.x === waypoint.x ||\n            nextWaypoint.y === waypoint.y ||\n            previousWaypoint.x === waypoint.x ||\n            previousWaypoint.y === waypoint.y) {\n          snapPoints.add('mid', waypoint);\n        }\n      });\n\n      return;\n    }\n\n    snapPoints.add('mid', mid(sibling));\n\n    if (is(sibling, 'bpmn:Participant')) {\n      snapPoints.add('top-left', topLeft(sibling));\n      snapPoints.add('bottom-right', bottomRight(sibling));\n    }\n  });\n\n\n  forEach(shape.incoming, function(c) {\n\n    if (siblings.indexOf(c.source) === -1) {\n      snapPoints.add('mid', mid(c.source));\n    }\n\n    var docking = c.waypoints[0];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n\n\n  forEach(shape.outgoing, function(c) {\n\n    if (siblings.indexOf(c.target) === -1) {\n      snapPoints.add('mid', mid(c.target));\n    }\n\n    var docking = c.waypoints[c.waypoints.length - 1];\n    snapPoints.add(c.id + '-docking', docking.original || docking);\n  });\n};\n\n\n// participant snapping //////////////////////\n\nfunction initParticipantSnapping(context, shape, elements) {\n\n  if (!elements.length) {\n    return;\n  }\n\n  var snapBox = getBoundingBox(elements.filter(function(e) {\n    return !e.labelTarget && !e.waypoints;\n  }));\n\n  snapBox.x -= 50;\n  snapBox.y -= 20;\n  snapBox.width += 70;\n  snapBox.height += 40;\n\n  // adjust shape height to include bounding box\n  shape.width = Math.max(shape.width, snapBox.width);\n  shape.height = Math.max(shape.height, snapBox.height);\n\n  context.participantSnapBox = snapBox;\n}\n\nfunction snapParticipant(snapBox, shape, event, offset) {\n  offset = offset || 0;\n\n  var shapeHalfWidth = shape.width / 2 - offset,\n      shapeHalfHeight = shape.height / 2;\n\n  var currentTopLeft = {\n    x: event.x - shapeHalfWidth - offset,\n    y: event.y - shapeHalfHeight\n  };\n\n  var currentBottomRight = {\n    x: event.x + shapeHalfWidth + offset,\n    y: event.y + shapeHalfHeight\n  };\n\n  var snapTopLeft = snapBox,\n      snapBottomRight = bottomRight(snapBox);\n\n  if (currentTopLeft.x >= snapTopLeft.x) {\n    setSnapped(event, 'x', snapTopLeft.x + offset + shapeHalfWidth);\n  } else\n  if (currentBottomRight.x <= snapBottomRight.x) {\n    setSnapped(event, 'x', snapBottomRight.x - offset - shapeHalfWidth);\n  }\n\n  if (currentTopLeft.y >= snapTopLeft.y) {\n    setSnapped(event, 'y', snapTopLeft.y + shapeHalfHeight);\n  } else\n  if (currentBottomRight.y <= snapBottomRight.y) {\n    setSnapped(event, 'y', snapBottomRight.y - shapeHalfHeight);\n  }\n}\n\n\n// boundary event snapping //////////////////////\n\nfunction snapBoundaryEvent(event, shape, target) {\n  var targetTRBL = asTRBL(target);\n\n  var direction = getBoundaryAttachment(event, target);\n\n  if (/top/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.top);\n  } else\n  if (/bottom/.test(direction)) {\n    setSnapped(event, 'y', targetTRBL.bottom);\n  }\n\n  if (/left/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.left);\n  } else\n  if (/right/.test(direction)) {\n    setSnapped(event, 'x', targetTRBL.right);\n  }\n}\n\n\nfunction snapToPosition(event, position) {\n  setSnapped(event, 'x', position.x);\n  setSnapped(event, 'y', position.y);\n}"]},"metadata":{},"sourceType":"module"}