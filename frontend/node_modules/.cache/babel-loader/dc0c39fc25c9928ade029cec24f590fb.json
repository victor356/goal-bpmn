{"ast":null,"code":"import { uniqueBy, isArray } from 'min-dash';\n/**\n * A service that offers un- and redoable execution of commands.\n *\n * The command stack is responsible for executing modeling actions\n * in a un- and redoable manner. To do this it delegates the actual\n * command execution to {@link CommandHandler}s.\n *\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\n * identified by a command context.\n *\n *\n * ## Life-Cycle events\n *\n * In the process the command stack fires a number of life-cycle events\n * that other components to participate in the command execution.\n *\n *    * preExecute\n *    * preExecuted\n *    * execute\n *    * executed\n *    * postExecute\n *    * postExecuted\n *    * revert\n *    * reverted\n *\n * A special event is used for validating, whether a command can be\n * performed prior to its execution.\n *\n *    * canExecute\n *\n * Each of the events is fired as `commandStack.{eventName}` and\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\n * components fine grained control on where to hook into.\n *\n * The event object fired transports `command`, the name of the\n * command and `context`, the command context.\n *\n *\n * ## Creating Command Handlers\n *\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\n * and {@link CommandHandler#revert(ctx)} methods to implement\n * redoing and undoing of a command.\n *\n * A command handler _must_ ensure undo is performed properly in order\n * not to break the undo chain. It must also return the shapes that\n * got changed during the `execute` and `revert` operations.\n *\n * Command handlers may execute other modeling operations (and thus\n * commands) in their `preExecute` and `postExecute` phases. The command\n * stack will properly group all commands together into a logical unit\n * that may be re- and undone atomically.\n *\n * Command handlers must not execute other commands from within their\n * core implementation (`execute`, `revert`).\n *\n *\n * ## Change Tracking\n *\n * During the execution of the CommandStack it will keep track of all\n * elements that have been touched during the command's execution.\n *\n * At the end of the CommandStack execution it will notify interested\n * components via an 'elements.changed' event with all the dirty\n * elements.\n *\n * The event can be picked up by components that are interested in the fact\n * that elements have been changed. One use case for this is updating\n * their graphical representation after moving / resizing or deletion.\n *\n * @see CommandHandler\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\n\nexport default function CommandStack(eventBus, injector) {\n  /**\n   * A map of all registered command handlers.\n   *\n   * @type {Object}\n   */\n  this._handlerMap = {};\n  /**\n   * A stack containing all re/undoable actions on the diagram\n   *\n   * @type {Array<Object>}\n   */\n\n  this._stack = [];\n  /**\n   * The current index on the stack\n   *\n   * @type {Number}\n   */\n\n  this._stackIdx = -1;\n  /**\n   * Current active commandStack execution\n   *\n   * @type {Object}\n   */\n\n  this._currentExecution = {\n    actions: [],\n    dirty: []\n  };\n  this._injector = injector;\n  this._eventBus = eventBus;\n  this._uid = 1;\n  eventBus.on(['diagram.destroy', 'diagram.clear'], function () {\n    this.clear(false);\n  }, this);\n}\nCommandStack.$inject = ['eventBus', 'injector'];\n/**\n * Execute a command\n *\n * @param {String} command the command to execute\n * @param {Object} context the environment to execute the command in\n */\n\nCommandStack.prototype.execute = function (command, context) {\n  if (!command) {\n    throw new Error('command required');\n  }\n\n  var action = {\n    command: command,\n    context: context\n  };\n\n  this._pushAction(action);\n\n  this._internalExecute(action);\n\n  this._popAction(action);\n};\n/**\n * Ask whether a given command can be executed.\n *\n * Implementors may hook into the mechanism on two ways:\n *\n *   * in event listeners:\n *\n *     Users may prevent the execution via an event listener.\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\n *\n *   * in command handlers:\n *\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\n *     it will be called to figure out whether the execution is allowed.\n *\n * @param  {String} command the command to execute\n * @param  {Object} context the environment to execute the command in\n *\n * @return {Boolean} true if the command can be executed\n */\n\n\nCommandStack.prototype.canExecute = function (command, context) {\n  var action = {\n    command: command,\n    context: context\n  };\n\n  var handler = this._getHandler(command);\n\n  var result = this._fire(command, 'canExecute', action); // handler#canExecute will only be called if no listener\n  // decided on a result already\n\n\n  if (result === undefined) {\n    if (!handler) {\n      return false;\n    }\n\n    if (handler.canExecute) {\n      result = handler.canExecute(context);\n    }\n  }\n\n  return result;\n};\n/**\n * Clear the command stack, erasing all undo / redo history\n */\n\n\nCommandStack.prototype.clear = function (emit) {\n  this._stack.length = 0;\n  this._stackIdx = -1;\n\n  if (emit !== false) {\n    this._fire('changed');\n  }\n};\n/**\n * Undo last command(s)\n */\n\n\nCommandStack.prototype.undo = function () {\n  var action = this._getUndoAction(),\n      next;\n\n  if (action) {\n    this._pushAction(action);\n\n    while (action) {\n      this._internalUndo(action);\n\n      next = this._getUndoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n/**\n * Redo last command(s)\n */\n\n\nCommandStack.prototype.redo = function () {\n  var action = this._getRedoAction(),\n      next;\n\n  if (action) {\n    this._pushAction(action);\n\n    while (action) {\n      this._internalExecute(action, true);\n\n      next = this._getRedoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n/**\n * Register a handler instance with the command stack\n *\n * @param {String} command\n * @param {CommandHandler} handler\n */\n\n\nCommandStack.prototype.register = function (command, handler) {\n  this._setHandler(command, handler);\n};\n/**\n * Register a handler type with the command stack\n * by instantiating it and injecting its dependencies.\n *\n * @param {String} command\n * @param {Function} a constructor for a {@link CommandHandler}\n */\n\n\nCommandStack.prototype.registerHandler = function (command, handlerCls) {\n  if (!command || !handlerCls) {\n    throw new Error('command and handlerCls must be defined');\n  }\n\n  var handler = this._injector.instantiate(handlerCls);\n\n  this.register(command, handler);\n};\n\nCommandStack.prototype.canUndo = function () {\n  return !!this._getUndoAction();\n};\n\nCommandStack.prototype.canRedo = function () {\n  return !!this._getRedoAction();\n}; // stack access  //////////////////////\n\n\nCommandStack.prototype._getRedoAction = function () {\n  return this._stack[this._stackIdx + 1];\n};\n\nCommandStack.prototype._getUndoAction = function () {\n  return this._stack[this._stackIdx];\n}; // internal functionality //////////////////////\n\n\nCommandStack.prototype._internalUndo = function (action) {\n  var self = this;\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command); // guard against illegal nested command stack invocations\n\n\n  this._atomicDo(function () {\n    self._fire(command, 'revert', action);\n\n    if (handler.revert) {\n      self._markDirty(handler.revert(context));\n    }\n\n    self._revertedAction(action);\n\n    self._fire(command, 'reverted', action);\n  });\n};\n\nCommandStack.prototype._fire = function (command, qualifier, event) {\n  if (arguments.length < 3) {\n    event = qualifier;\n    qualifier = null;\n  }\n\n  var names = qualifier ? [command + '.' + qualifier, qualifier] : [command],\n      i,\n      name,\n      result;\n  event = this._eventBus.createEvent(event);\n\n  for (i = 0; name = names[i]; i++) {\n    result = this._eventBus.fire('commandStack.' + name, event);\n\n    if (event.cancelBubble) {\n      break;\n    }\n  }\n\n  return result;\n};\n\nCommandStack.prototype._createId = function () {\n  return this._uid++;\n};\n\nCommandStack.prototype._atomicDo = function (fn) {\n  var execution = this._currentExecution;\n  execution.atomic = true;\n\n  try {\n    fn();\n  } finally {\n    execution.atomic = false;\n  }\n};\n\nCommandStack.prototype._internalExecute = function (action, redo) {\n  var self = this;\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command);\n\n  if (!handler) {\n    throw new Error('no command handler registered for <' + command + '>');\n  }\n\n  this._pushAction(action);\n\n  if (!redo) {\n    this._fire(command, 'preExecute', action);\n\n    if (handler.preExecute) {\n      handler.preExecute(context);\n    }\n\n    this._fire(command, 'preExecuted', action);\n  } // guard against illegal nested command stack invocations\n\n\n  this._atomicDo(function () {\n    self._fire(command, 'execute', action);\n\n    if (handler.execute) {\n      // actual execute + mark return results as dirty\n      self._markDirty(handler.execute(context));\n    } // log to stack\n\n\n    self._executedAction(action, redo);\n\n    self._fire(command, 'executed', action);\n  });\n\n  if (!redo) {\n    this._fire(command, 'postExecute', action);\n\n    if (handler.postExecute) {\n      handler.postExecute(context);\n    }\n\n    this._fire(command, 'postExecuted', action);\n  }\n\n  this._popAction(action);\n};\n\nCommandStack.prototype._pushAction = function (action) {\n  var execution = this._currentExecution,\n      actions = execution.actions;\n  var baseAction = actions[0];\n\n  if (execution.atomic) {\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\n  }\n\n  if (!action.id) {\n    action.id = baseAction && baseAction.id || this._createId();\n  }\n\n  actions.push(action);\n};\n\nCommandStack.prototype._popAction = function () {\n  var execution = this._currentExecution,\n      actions = execution.actions,\n      dirty = execution.dirty;\n  actions.pop();\n\n  if (!actions.length) {\n    this._eventBus.fire('elements.changed', {\n      elements: uniqueBy('id', dirty)\n    });\n\n    dirty.length = 0;\n\n    this._fire('changed');\n  }\n};\n\nCommandStack.prototype._markDirty = function (elements) {\n  var execution = this._currentExecution;\n\n  if (!elements) {\n    return;\n  }\n\n  elements = isArray(elements) ? elements : [elements];\n  execution.dirty = execution.dirty.concat(elements);\n};\n\nCommandStack.prototype._executedAction = function (action, redo) {\n  var stackIdx = ++this._stackIdx;\n\n  if (!redo) {\n    this._stack.splice(stackIdx, this._stack.length, action);\n  }\n};\n\nCommandStack.prototype._revertedAction = function (action) {\n  this._stackIdx--;\n};\n\nCommandStack.prototype._getHandler = function (command) {\n  return this._handlerMap[command];\n};\n\nCommandStack.prototype._setHandler = function (command, handler) {\n  if (!command || !handler) {\n    throw new Error('command and handler required');\n  }\n\n  if (this._handlerMap[command]) {\n    throw new Error('overriding handler for command <' + command + '>');\n  }\n\n  this._handlerMap[command] = handler;\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/node_modules/diagram-js/lib/command/CommandStack.js"],"names":["uniqueBy","isArray","CommandStack","eventBus","injector","_handlerMap","_stack","_stackIdx","_currentExecution","actions","dirty","_injector","_eventBus","_uid","on","clear","$inject","prototype","execute","command","context","Error","action","_pushAction","_internalExecute","_popAction","canExecute","handler","_getHandler","result","_fire","undefined","emit","length","undo","_getUndoAction","next","_internalUndo","id","redo","_getRedoAction","register","_setHandler","registerHandler","handlerCls","instantiate","canUndo","canRedo","self","_atomicDo","revert","_markDirty","_revertedAction","qualifier","event","arguments","names","i","name","createEvent","fire","cancelBubble","_createId","fn","execution","atomic","preExecute","_executedAction","postExecute","baseAction","push","pop","elements","concat","stackIdx","splice"],"mappings":"AAAA,SACEA,QADF,EAEEC,OAFF,QAGO,UAHP;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,YAAT,CAAsBC,QAAtB,EAAgCC,QAAhC,EAA0C;AAEvD;AACF;AACA;AACA;AACA;AACE,OAAKC,WAAL,GAAmB,EAAnB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,MAAL,GAAc,EAAd;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,SAAL,GAAiB,CAAC,CAAlB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyB;AACvBC,IAAAA,OAAO,EAAE,EADc;AAEvBC,IAAAA,KAAK,EAAE;AAFgB,GAAzB;AAMA,OAAKC,SAAL,GAAiBP,QAAjB;AACA,OAAKQ,SAAL,GAAiBT,QAAjB;AAEA,OAAKU,IAAL,GAAY,CAAZ;AAEAV,EAAAA,QAAQ,CAACW,EAAT,CAAY,CACV,iBADU,EAEV,eAFU,CAAZ,EAGG,YAAW;AACZ,SAAKC,KAAL,CAAW,KAAX;AACD,GALD,EAKG,IALH;AAMD;AAEDb,YAAY,CAACc,OAAb,GAAuB,CAAE,UAAF,EAAc,UAAd,CAAvB;AAGA;AACA;AACA;AACA;AACA;AACA;;AACAd,YAAY,CAACe,SAAb,CAAuBC,OAAvB,GAAiC,UAASC,OAAT,EAAkBC,OAAlB,EAA2B;AAC1D,MAAI,CAACD,OAAL,EAAc;AACZ,UAAM,IAAIE,KAAJ,CAAU,kBAAV,CAAN;AACD;;AAED,MAAIC,MAAM,GAAG;A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","sourcesContent":["import {\n  uniqueBy,\n  isArray\n} from 'min-dash';\n\n\n/**\n * A service that offers un- and redoable execution of commands.\n *\n * The command stack is responsible for executing modeling actions\n * in a un- and redoable manner. To do this it delegates the actual\n * command execution to {@link CommandHandler}s.\n *\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\n * identified by a command context.\n *\n *\n * ## Life-Cycle events\n *\n * In the process the command stack fires a number of life-cycle events\n * that other components to participate in the command execution.\n *\n *    * preExecute\n *    * preExecuted\n *    * execute\n *    * executed\n *    * postExecute\n *    * postExecuted\n *    * revert\n *    * reverted\n *\n * A special event is used for validating, whether a command can be\n * performed prior to its execution.\n *\n *    * canExecute\n *\n * Each of the events is fired as `commandStack.{eventName}` and\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\n * components fine grained control on where to hook into.\n *\n * The event object fired transports `command`, the name of the\n * command and `context`, the command context.\n *\n *\n * ## Creating Command Handlers\n *\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\n * and {@link CommandHandler#revert(ctx)} methods to implement\n * redoing and undoing of a command.\n *\n * A command handler _must_ ensure undo is performed properly in order\n * not to break the undo chain. It must also return the shapes that\n * got changed during the `execute` and `revert` operations.\n *\n * Command handlers may execute other modeling operations (and thus\n * commands) in their `preExecute` and `postExecute` phases. The command\n * stack will properly group all commands together into a logical unit\n * that may be re- and undone atomically.\n *\n * Command handlers must not execute other commands from within their\n * core implementation (`execute`, `revert`).\n *\n *\n * ## Change Tracking\n *\n * During the execution of the CommandStack it will keep track of all\n * elements that have been touched during the command's execution.\n *\n * At the end of the CommandStack execution it will notify interested\n * components via an 'elements.changed' event with all the dirty\n * elements.\n *\n * The event can be picked up by components that are interested in the fact\n * that elements have been changed. One use case for this is updating\n * their graphical representation after moving / resizing or deletion.\n *\n * @see CommandHandler\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function CommandStack(eventBus, injector) {\n\n  /**\n   * A map of all registered command handlers.\n   *\n   * @type {Object}\n   */\n  this._handlerMap = {};\n\n  /**\n   * A stack containing all re/undoable actions on the diagram\n   *\n   * @type {Array<Object>}\n   */\n  this._stack = [];\n\n  /**\n   * The current index on the stack\n   *\n   * @type {Number}\n   */\n  this._stackIdx = -1;\n\n  /**\n   * Current active commandStack execution\n   *\n   * @type {Object}\n   */\n  this._currentExecution = {\n    actions: [],\n    dirty: []\n  };\n\n\n  this._injector = injector;\n  this._eventBus = eventBus;\n\n  this._uid = 1;\n\n  eventBus.on([\n    'diagram.destroy',\n    'diagram.clear'\n  ], function() {\n    this.clear(false);\n  }, this);\n}\n\nCommandStack.$inject = [ 'eventBus', 'injector' ];\n\n\n/**\n * Execute a command\n *\n * @param {String} command the command to execute\n * @param {Object} context the environment to execute the command in\n */\nCommandStack.prototype.execute = function(command, context) {\n  if (!command) {\n    throw new Error('command required');\n  }\n\n  var action = { command: command, context: context };\n\n  this._pushAction(action);\n  this._internalExecute(action);\n  this._popAction(action);\n};\n\n\n/**\n * Ask whether a given command can be executed.\n *\n * Implementors may hook into the mechanism on two ways:\n *\n *   * in event listeners:\n *\n *     Users may prevent the execution via an event listener.\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\n *\n *   * in command handlers:\n *\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\n *     it will be called to figure out whether the execution is allowed.\n *\n * @param  {String} command the command to execute\n * @param  {Object} context the environment to execute the command in\n *\n * @return {Boolean} true if the command can be executed\n */\nCommandStack.prototype.canExecute = function(command, context) {\n\n  var action = { command: command, context: context };\n\n  var handler = this._getHandler(command);\n\n  var result = this._fire(command, 'canExecute', action);\n\n  // handler#canExecute will only be called if no listener\n  // decided on a result already\n  if (result === undefined) {\n    if (!handler) {\n      return false;\n    }\n\n    if (handler.canExecute) {\n      result = handler.canExecute(context);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Clear the command stack, erasing all undo / redo history\n */\nCommandStack.prototype.clear = function(emit) {\n  this._stack.length = 0;\n  this._stackIdx = -1;\n\n  if (emit !== false) {\n    this._fire('changed');\n  }\n};\n\n\n/**\n * Undo last command(s)\n */\nCommandStack.prototype.undo = function() {\n  var action = this._getUndoAction(),\n      next;\n\n  if (action) {\n    this._pushAction(action);\n\n    while (action) {\n      this._internalUndo(action);\n      next = this._getUndoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Redo last command(s)\n */\nCommandStack.prototype.redo = function() {\n  var action = this._getRedoAction(),\n      next;\n\n  if (action) {\n    this._pushAction(action);\n\n    while (action) {\n      this._internalExecute(action, true);\n      next = this._getRedoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Register a handler instance with the command stack\n *\n * @param {String} command\n * @param {CommandHandler} handler\n */\nCommandStack.prototype.register = function(command, handler) {\n  this._setHandler(command, handler);\n};\n\n\n/**\n * Register a handler type with the command stack\n * by instantiating it and injecting its dependencies.\n *\n * @param {String} command\n * @param {Function} a constructor for a {@link CommandHandler}\n */\nCommandStack.prototype.registerHandler = function(command, handlerCls) {\n\n  if (!command || !handlerCls) {\n    throw new Error('command and handlerCls must be defined');\n  }\n\n  var handler = this._injector.instantiate(handlerCls);\n  this.register(command, handler);\n};\n\nCommandStack.prototype.canUndo = function() {\n  return !!this._getUndoAction();\n};\n\nCommandStack.prototype.canRedo = function() {\n  return !!this._getRedoAction();\n};\n\n// stack access  //////////////////////\n\nCommandStack.prototype._getRedoAction = function() {\n  return this._stack[this._stackIdx + 1];\n};\n\n\nCommandStack.prototype._getUndoAction = function() {\n  return this._stack[this._stackIdx];\n};\n\n\n// internal functionality //////////////////////\n\nCommandStack.prototype._internalUndo = function(action) {\n  var self = this;\n\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command);\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(function() {\n    self._fire(command, 'revert', action);\n\n    if (handler.revert) {\n      self._markDirty(handler.revert(context));\n    }\n\n    self._revertedAction(action);\n\n    self._fire(command, 'reverted', action);\n  });\n};\n\n\nCommandStack.prototype._fire = function(command, qualifier, event) {\n  if (arguments.length < 3) {\n    event = qualifier;\n    qualifier = null;\n  }\n\n  var names = qualifier ? [ command + '.' + qualifier, qualifier ] : [ command ],\n      i, name, result;\n\n  event = this._eventBus.createEvent(event);\n\n  for (i = 0; (name = names[i]); i++) {\n    result = this._eventBus.fire('commandStack.' + name, event);\n\n    if (event.cancelBubble) {\n      break;\n    }\n  }\n\n  return result;\n};\n\nCommandStack.prototype._createId = function() {\n  return this._uid++;\n};\n\nCommandStack.prototype._atomicDo = function(fn) {\n\n  var execution = this._currentExecution;\n\n  execution.atomic = true;\n\n  try {\n    fn();\n  } finally {\n    execution.atomic = false;\n  }\n};\n\nCommandStack.prototype._internalExecute = function(action, redo) {\n  var self = this;\n\n  var command = action.command,\n      context = action.context;\n\n  var handler = this._getHandler(command);\n\n  if (!handler) {\n    throw new Error('no command handler registered for <' + command + '>');\n  }\n\n  this._pushAction(action);\n\n  if (!redo) {\n    this._fire(command, 'preExecute', action);\n\n    if (handler.preExecute) {\n      handler.preExecute(context);\n    }\n\n    this._fire(command, 'preExecuted', action);\n  }\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(function() {\n\n    self._fire(command, 'execute', action);\n\n    if (handler.execute) {\n      // actual execute + mark return results as dirty\n      self._markDirty(handler.execute(context));\n    }\n\n    // log to stack\n    self._executedAction(action, redo);\n\n    self._fire(command, 'executed', action);\n  });\n\n  if (!redo) {\n    this._fire(command, 'postExecute', action);\n\n    if (handler.postExecute) {\n      handler.postExecute(context);\n    }\n\n    this._fire(command, 'postExecuted', action);\n  }\n\n  this._popAction(action);\n};\n\n\nCommandStack.prototype._pushAction = function(action) {\n\n  var execution = this._currentExecution,\n      actions = execution.actions;\n\n  var baseAction = actions[0];\n\n  if (execution.atomic) {\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\n  }\n\n  if (!action.id) {\n    action.id = (baseAction && baseAction.id) || this._createId();\n  }\n\n  actions.push(action);\n};\n\n\nCommandStack.prototype._popAction = function() {\n  var execution = this._currentExecution,\n      actions = execution.actions,\n      dirty = execution.dirty;\n\n  actions.pop();\n\n  if (!actions.length) {\n    this._eventBus.fire('elements.changed', { elements: uniqueBy('id', dirty) });\n\n    dirty.length = 0;\n\n    this._fire('changed');\n  }\n};\n\n\nCommandStack.prototype._markDirty = function(elements) {\n  var execution = this._currentExecution;\n\n  if (!elements) {\n    return;\n  }\n\n  elements = isArray(elements) ? elements : [ elements ];\n\n  execution.dirty = execution.dirty.concat(elements);\n};\n\n\nCommandStack.prototype._executedAction = function(action, redo) {\n  var stackIdx = ++this._stackIdx;\n\n  if (!redo) {\n    this._stack.splice(stackIdx, this._stack.length, action);\n  }\n};\n\n\nCommandStack.prototype._revertedAction = function(action) {\n  this._stackIdx--;\n};\n\n\nCommandStack.prototype._getHandler = function(command) {\n  return this._handlerMap[command];\n};\n\nCommandStack.prototype._setHandler = function(command, handler) {\n  if (!command || !handler) {\n    throw new Error('command and handler required');\n  }\n\n  if (this._handlerMap[command]) {\n    throw new Error('overriding handler for command <' + command + '>');\n  }\n\n  this._handlerMap[command] = handler;\n};\n"]},"metadata":{},"sourceType":"module"}