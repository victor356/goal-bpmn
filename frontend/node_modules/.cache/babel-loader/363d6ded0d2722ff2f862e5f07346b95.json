{"ast":null,"code":"import { getDistancePointPoint, rotateVector, getAngle } from './GeometricUtil';\nimport { getAttachment } from './LineAttachmentUtil';\nimport { roundPoint } from 'diagram-js/lib/layout/LayoutUtil';\nexport function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\n  var index = attachment.segmentIndex;\n  var offset = newWaypoints.length - oldWaypoints.length; // segmentMove happend\n\n  if (hints.segmentMove) {\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\n        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex; // if label was on moved segment return new segment index\n\n    if (index === oldSegmentStartIndex) {\n      return newSegmentStartIndex;\n    } // label is after new segment index\n\n\n    if (index >= newSegmentStartIndex) {\n      return index + offset < newSegmentStartIndex ? newSegmentStartIndex : index + offset;\n    } // if label is before new segment index\n\n\n    return index;\n  } // bendpointMove happend\n\n\n  if (hints.bendpointMove) {\n    var insert = hints.bendpointMove.insert,\n        bendpointIndex = hints.bendpointMove.bendpointIndex,\n        newIndex; // waypoints length didnt change\n\n    if (offset === 0) {\n      return index;\n    } // label behind new/removed bendpoint\n\n\n    if (index >= bendpointIndex) {\n      newIndex = insert ? index + 1 : index - 1;\n    } // label before new/removed bendpoint\n\n\n    if (index < bendpointIndex) {\n      newIndex = index; // decide label should take right or left segment\n\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex - 1 === index) {\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\n\n        if (rel < attachment.relativeLocation) {\n          newIndex++;\n        }\n      }\n    }\n\n    return newIndex;\n  } // start/end changed\n\n\n  if (offset === 0) {\n    return index;\n  }\n\n  if (hints.connectionStart) {\n    return index === 0 ? 0 : null;\n  }\n\n  if (hints.connectionEnd) {\n    return index === oldWaypoints.length - 2 ? newWaypoints.length - 2 : null;\n  } // if nothing fits, return null\n\n\n  return null;\n}\n/**\n * Calculate the required adjustment (move delta) for the given label\n * after the connection waypoints got updated.\n *\n * @param {djs.model.Label} label\n * @param {Array<Point>} newWaypoints\n * @param {Array<Point>} oldWaypoints\n * @param {Object} hints\n *\n * @return {Point} delta\n */\n\nexport function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {\n  var x = 0,\n      y = 0;\n  var labelPosition = getLabelMid(label); // get closest attachment\n\n  var attachment = getAttachment(labelPosition, oldWaypoints),\n      oldLabelLineIndex = attachment.segmentIndex,\n      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);\n\n  if (newLabelLineIndex === null) {\n    return {\n      x: x,\n      y: y\n    };\n  } // should never happen\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\n\n\n  if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2) {\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\n      newLabelLine = getLine(newWaypoints, newLabelLineIndex),\n      oldFoot = attachment.position;\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\n      angleDelta = getAngleDelta(oldLabelLine, newLabelLine); // special rule if label on bendpoint\n\n  if (attachment.type === 'bendpoint') {\n    var offset = newWaypoints.length - oldWaypoints.length,\n        oldBendpointIndex = attachment.bendpointIndex,\n        oldBendpoint = oldWaypoints[oldBendpointIndex]; // bendpoint position hasnt changed, return same position\n\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\n      return {\n        x: x,\n        y: y\n      };\n    } // new bendpoint and old bendpoint have same index, then just return the offset\n\n\n    if (offset === 0) {\n      var newBendpoint = newWaypoints[oldBendpointIndex];\n      return {\n        x: newBendpoint.x - attachment.position.x,\n        y: newBendpoint.y - attachment.position.y\n      };\n    } // if bendpoints get removed\n\n\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\n    }\n  }\n\n  var newFoot = {\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\n  }; // the rotated vector to label\n\n  var newLabelVector = rotateVector({\n    x: labelPosition.x - oldFoot.x,\n    y: labelPosition.y - oldFoot.y\n  }, angleDelta); // the new relative position\n\n  x = newFoot.x + newLabelVector.x - labelPosition.x;\n  y = newFoot.y + newLabelVector.y - labelPosition.y;\n  return roundPoint({\n    x: x,\n    y: y\n  });\n} // HELPERS //////////////////////\n\nfunction relativePositionMidWaypoint(waypoints, idx) {\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]),\n      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);\n  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);\n  return relativePosition;\n}\n\nfunction getLabelMid(label) {\n  return {\n    x: label.x + label.width / 2,\n    y: label.y + label.height / 2\n  };\n}\n\nfunction getAngleDelta(l1, l2) {\n  var a1 = getAngle(l1),\n      a2 = getAngle(l2);\n  return a2 - a1;\n}\n\nfunction getLine(waypoints, idx) {\n  return [waypoints[idx], waypoints[idx + 1]];\n}\n\nfunction getRelativeFootPosition(line, foot) {\n  var length = getDistancePointPoint(line[0], line[1]),\n      lengthToFoot = getDistancePointPoint(line[0], foot);\n  return length === 0 ? 0 : lengthToFoot / length;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/modeling/behavior/util/LabelLayoutUtil.js"],"names":["getDistancePointPoint","rotateVector","getAngle","getAttachment","roundPoint","findNewLabelLineStartIndex","oldWaypoints","newWaypoints","attachment","hints","index","segmentIndex","offset","length","segmentMove","oldSegmentStartIndex","segmentStartIndex","newSegmentStartIndex","bendpointMove","insert","bendpointIndex","newIndex","type","rel","relativePositionMidWaypoint","relativeLocation","connectionStart","connectionEnd","getLabelAdjustment","label","x","y","labelPosition","getLabelMid","oldLabelLineIndex","newLabelLineIndex","oldLabelLine","getLine","newLabelLine","oldFoot","position","relativeFootPosition","getRelativeFootPosition","angleDelta","getAngleDelta","oldBendpointIndex","oldBendpoint","indexOf","newBendpoint","newFoot","newLabelVector","waypoints","idx","distanceSegment1","distanceSegment2","relativePosition","width","height","l1","l2","a1","a2","line","foot","lengthToFoot"],"mappings":"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","sourcesContent":["import {\n  getDistancePointPoint,\n  rotateVector,\n  getAngle\n} from './GeometricUtil';\n\nimport {\n  getAttachment\n} from './LineAttachmentUtil';\n\nimport {\n  roundPoint\n} from 'diagram-js/lib/layout/LayoutUtil';\n\n\nexport function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {\n\n  var index = attachment.segmentIndex;\n\n  var offset = newWaypoints.length - oldWaypoints.length;\n\n  // segmentMove happend\n  if (hints.segmentMove) {\n\n    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,\n        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;\n\n    // if label was on moved segment return new segment index\n    if (index === oldSegmentStartIndex) {\n      return newSegmentStartIndex;\n    }\n\n    // label is after new segment index\n    if (index >= newSegmentStartIndex) {\n      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;\n    }\n\n    // if label is before new segment index\n    return index;\n  }\n\n  // bendpointMove happend\n  if (hints.bendpointMove) {\n\n    var insert = hints.bendpointMove.insert,\n        bendpointIndex = hints.bendpointMove.bendpointIndex,\n        newIndex;\n\n    // waypoints length didnt change\n    if (offset === 0) {\n      return index;\n    }\n\n    // label behind new/removed bendpoint\n    if (index >= bendpointIndex) {\n      newIndex = insert ? index + 1 : index - 1;\n    }\n\n    // label before new/removed bendpoint\n    if (index < bendpointIndex) {\n\n      newIndex = index;\n\n      // decide label should take right or left segment\n      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {\n\n        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);\n\n        if (rel < attachment.relativeLocation) {\n          newIndex++;\n        }\n      }\n    }\n\n    return newIndex;\n  }\n\n  // start/end changed\n  if (offset === 0) {\n    return index;\n  }\n\n  if (hints.connectionStart) {\n    return (index === 0) ? 0 : null;\n  }\n\n  if (hints.connectionEnd) {\n    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;\n  }\n\n  // if nothing fits, return null\n  return null;\n}\n\n\n/**\n * Calculate the required adjustment (move delta) for the given label\n * after the connection waypoints got updated.\n *\n * @param {djs.model.Label} label\n * @param {Array<Point>} newWaypoints\n * @param {Array<Point>} oldWaypoints\n * @param {Object} hints\n *\n * @return {Point} delta\n */\nexport function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {\n\n  var x = 0,\n      y = 0;\n\n  var labelPosition = getLabelMid(label);\n\n  // get closest attachment\n  var attachment = getAttachment(labelPosition, oldWaypoints),\n      oldLabelLineIndex = attachment.segmentIndex,\n      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);\n\n  if (newLabelLineIndex === null) {\n    return { x: x, y: y };\n  }\n\n  // should never happen\n  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored\n  if (newLabelLineIndex < 0 ||\n      newLabelLineIndex > newWaypoints.length - 2) {\n    return { x: x, y: y };\n  }\n\n  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),\n      newLabelLine = getLine(newWaypoints, newLabelLineIndex),\n      oldFoot = attachment.position;\n\n  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),\n      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);\n\n  // special rule if label on bendpoint\n  if (attachment.type === 'bendpoint') {\n\n    var offset = newWaypoints.length - oldWaypoints.length,\n        oldBendpointIndex = attachment.bendpointIndex,\n        oldBendpoint = oldWaypoints[oldBendpointIndex];\n\n    // bendpoint position hasnt changed, return same position\n    if (newWaypoints.indexOf(oldBendpoint) !== -1) {\n      return { x: x, y: y };\n    }\n\n    // new bendpoint and old bendpoint have same index, then just return the offset\n    if (offset === 0) {\n      var newBendpoint = newWaypoints[oldBendpointIndex];\n\n      return {\n        x: newBendpoint.x - attachment.position.x,\n        y: newBendpoint.y - attachment.position.y\n      };\n    }\n\n    // if bendpoints get removed\n    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {\n      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);\n    }\n  }\n\n  var newFoot = {\n    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,\n    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y\n  };\n\n  // the rotated vector to label\n  var newLabelVector = rotateVector({\n    x: labelPosition.x - oldFoot.x,\n    y: labelPosition.y - oldFoot.y\n  }, angleDelta);\n\n  // the new relative position\n  x = newFoot.x + newLabelVector.x - labelPosition.x;\n  y = newFoot.y + newLabelVector.y - labelPosition.y;\n\n  return roundPoint({\n    x: x,\n    y: y\n  });\n}\n\n\n// HELPERS //////////////////////\n\nfunction relativePositionMidWaypoint(waypoints, idx) {\n\n  var distanceSegment1 = getDistancePointPoint(waypoints[idx-1], waypoints[idx]),\n      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx+1]);\n\n  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);\n\n  return relativePosition;\n}\n\nfunction getLabelMid(label) {\n  return {\n    x: label.x + label.width / 2,\n    y: label.y + label.height / 2\n  };\n}\n\nfunction getAngleDelta(l1, l2) {\n  var a1 = getAngle(l1),\n      a2 = getAngle(l2);\n  return a2 - a1;\n}\n\nfunction getLine(waypoints, idx) {\n  return [ waypoints[idx], waypoints[idx+1] ];\n}\n\nfunction getRelativeFootPosition(line, foot) {\n\n  var length = getDistancePointPoint(line[0], line[1]),\n      lengthToFoot = getDistancePointPoint(line[0], foot);\n\n  return length === 0 ? 0 : lengthToFoot / length;\n}\n"]},"metadata":{},"sourceType":"module"}