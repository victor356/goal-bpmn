{"ast":null,"code":"var LOW_PRIORITY = 750;\nvar MARKER_OK = 'drop-ok',\n    MARKER_NOT_OK = 'drop-not-ok',\n    MARKER_ATTACH = 'attach-ok',\n    MARKER_NEW_PARENT = 'new-parent';\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nimport { translate } from '../../util/SvgTransformUtil';\n/**\n * Adds the ability to create new shapes via drag and drop.\n *\n * Create must be activated via {@link Create#start}. From that\n * point on, create will invoke `shape.create` and `shape.attach`\n * rules to query whether or not creation or attachment on a certain\n * position is allowed.\n *\n * If create or attach is allowed and a source is given, Create it\n * will invoke `connection.create` rules to query whether a connection\n * can be drawn between source and new shape. During rule evaluation\n * the target is not attached yet, however\n *\n *   hints = { targetParent, targetAttach }\n *\n * are passed to the evaluating rules.\n *\n *\n * ## Rule Return Values\n *\n * Return values interpreted from  `shape.create`:\n *\n *   * `true`: create is allowed\n *   * `false`: create is disallowed\n *   * `null`: create is not allowed but should be ignored visually\n *\n * Return values interpreted from `shape.attach`:\n *\n *   * `true`: attach is allowed\n *   * `Any`: attach is allowed with the constraints\n *   * `false`: attach is disallowed\n *\n * Return values interpreted from `connection.create`:\n *\n *   * `true`: connection can be created\n *   * `Any`: connection with the given attributes can be created\n *   * `false`: connection can't be created\n *\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {Rules} rules\n * @param {Modeling} modeling\n * @param {Canvas} canvas\n * @param {Styles} styles\n * @param {GraphicsFactory} graphicsFactory\n */\n\nexport default function Create(eventBus, dragging, rules, modeling, canvas, styles, graphicsFactory) {\n  // rules\n  function canCreate(shape, target, source, position) {\n    if (!target) {\n      return false;\n    }\n\n    var ctx = {\n      source: source,\n      shape: shape,\n      target: target,\n      position: position\n    };\n    var create, attach, connect;\n    attach = rules.allowed('shape.attach', ctx);\n\n    if (!attach) {\n      create = rules.allowed('shape.create', ctx);\n    }\n\n    if (create || attach) {\n      connect = source && rules.allowed('connection.create', {\n        source: source,\n        target: shape,\n        hints: {\n          targetParent: target,\n          targetAttach: attach\n        }\n      });\n    }\n\n    if (create || attach) {\n      return {\n        attach: attach,\n        connect: connect\n      };\n    }\n\n    return false;\n  }\n  /** set drop marker on an element */\n\n\n  function setMarker(element, marker) {\n    [MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT].forEach(function (m) {\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  } // visual helpers\n\n\n  function createVisual(shape) {\n    var group, preview, visual;\n    group = svgCreate('g');\n    svgAttr(group, styles.cls('djs-drag-group', ['no-events']));\n    svgAppend(canvas.getDefaultLayer(), group);\n    preview = svgCreate('g');\n    svgClasses(preview).add('djs-dragger');\n    svgAppend(group, preview);\n    translate(preview, shape.width / -2, shape.height / -2);\n    var visualGroup = svgCreate('g');\n    svgClasses(visualGroup).add('djs-visual');\n    svgAppend(preview, visualGroup);\n    visual = visualGroup; // hijack renderer to draw preview\n\n    graphicsFactory.drawShape(visual, shape);\n    return group;\n  } // event handlers\n\n\n  eventBus.on('create.move', function (event) {\n    var context = event.context,\n        hover = event.hover,\n        shape = context.shape,\n        source = context.source,\n        canExecute;\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n    canExecute = context.canExecute = hover && canCreate(shape, hover, source, position); // ignore hover visually if canExecute is null\n\n    if (hover && canExecute !== null) {\n      context.target = hover;\n\n      if (canExecute && canExecute.attach) {\n        setMarker(hover, MARKER_ATTACH);\n      } else {\n        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\n      }\n    }\n  });\n  eventBus.on('create.move', LOW_PRIORITY, function (event) {\n    var context = event.context,\n        shape = context.shape,\n        visual = context.visual; // lazy init drag visual once we received the first real\n    // drag move event (this allows us to get the proper canvas local coordinates)\n\n    if (!visual) {\n      visual = context.visual = createVisual(shape);\n    }\n\n    translate(visual, event.x, event.y);\n  });\n  eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {\n    var context = event.context,\n        target = context.target;\n\n    if (target) {\n      setMarker(target, null);\n    }\n  });\n  eventBus.on('create.end', function (event) {\n    var context = event.context,\n        source = context.source,\n        shape = context.shape,\n        target = context.target,\n        canExecute = context.canExecute,\n        attach = canExecute && canExecute.attach,\n        connect = canExecute && canExecute.connect,\n        position = {\n      x: event.x,\n      y: event.y\n    };\n\n    if (!canExecute) {\n      return false;\n    }\n\n    if (connect) {\n      // invoke append if connect is set via rules\n      shape = modeling.appendShape(source, shape, position, target, {\n        attach: attach,\n        connection: connect === true ? {} : connect\n      });\n    } else {\n      // invoke create, if connect is not set\n      shape = modeling.createShape(shape, position, target, {\n        attach: attach\n      });\n    } // make sure we provide the actual attached\n    // shape with the context so that selection and\n    // other components can use it right after the create\n    // operation ends\n\n\n    context.shape = shape;\n  });\n  eventBus.on('create.cleanup', function (event) {\n    var context = event.context;\n\n    if (context.visual) {\n      svgRemove(context.visual);\n    }\n  }); // API\n\n  this.start = function (event, shape, source) {\n    dragging.init(event, 'create', {\n      cursor: 'grabbing',\n      autoActivate: true,\n      data: {\n        shape: shape,\n        context: {\n          shape: shape,\n          source: source\n        }\n      }\n    });\n  };\n}\nCreate.$inject = ['eventBus', 'dragging', 'rules', 'modeling', 'canvas', 'styles', 'graphicsFactory'];","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/node_modules/diagram-js/lib/features/create/Create.js"],"names":["LOW_PRIORITY","MARKER_OK","MARKER_NOT_OK","MARKER_ATTACH","MARKER_NEW_PARENT","append","svgAppend","attr","svgAttr","classes","svgClasses","create","svgCreate","remove","svgRemove","translate","Create","eventBus","dragging","rules","modeling","canvas","styles","graphicsFactory","canCreate","shape","target","source","position","ctx","attach","connect","allowed","hints","targetParent","targetAttach","setMarker","element","marker","forEach","m","addMarker","removeMarker","createVisual","group","preview","visual","cls","getDefaultLayer","add","width","height","visualGroup","drawShape","on","event","context","hover","canExecute","x","y","appendShape","connection","createShape","start","init","cursor","autoActivate","data","$inject"],"mappings":"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","sourcesContent":["var LOW_PRIORITY = 750;\n\nvar MARKER_OK = 'drop-ok',\n    MARKER_NOT_OK = 'drop-not-ok',\n    MARKER_ATTACH = 'attach-ok',\n    MARKER_NEW_PARENT = 'new-parent';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate,\n  remove as svgRemove\n} from 'tiny-svg';\n\nimport {\n  translate\n} from '../../util/SvgTransformUtil';\n\n\n/**\n * Adds the ability to create new shapes via drag and drop.\n *\n * Create must be activated via {@link Create#start}. From that\n * point on, create will invoke `shape.create` and `shape.attach`\n * rules to query whether or not creation or attachment on a certain\n * position is allowed.\n *\n * If create or attach is allowed and a source is given, Create it\n * will invoke `connection.create` rules to query whether a connection\n * can be drawn between source and new shape. During rule evaluation\n * the target is not attached yet, however\n *\n *   hints = { targetParent, targetAttach }\n *\n * are passed to the evaluating rules.\n *\n *\n * ## Rule Return Values\n *\n * Return values interpreted from  `shape.create`:\n *\n *   * `true`: create is allowed\n *   * `false`: create is disallowed\n *   * `null`: create is not allowed but should be ignored visually\n *\n * Return values interpreted from `shape.attach`:\n *\n *   * `true`: attach is allowed\n *   * `Any`: attach is allowed with the constraints\n *   * `false`: attach is disallowed\n *\n * Return values interpreted from `connection.create`:\n *\n *   * `true`: connection can be created\n *   * `Any`: connection with the given attributes can be created\n *   * `false`: connection can't be created\n *\n *\n * @param {EventBus} eventBus\n * @param {Dragging} dragging\n * @param {Rules} rules\n * @param {Modeling} modeling\n * @param {Canvas} canvas\n * @param {Styles} styles\n * @param {GraphicsFactory} graphicsFactory\n */\nexport default function Create(\n    eventBus, dragging, rules, modeling,\n    canvas, styles, graphicsFactory) {\n\n  // rules\n\n  function canCreate(shape, target, source, position) {\n\n    if (!target) {\n      return false;\n    }\n\n    var ctx = {\n      source: source,\n      shape: shape,\n      target: target,\n      position: position\n    };\n\n    var create,\n        attach,\n        connect;\n\n    attach = rules.allowed('shape.attach', ctx);\n\n    if (!attach) {\n      create = rules.allowed('shape.create', ctx);\n    }\n\n    if (create || attach) {\n\n      connect = source && rules.allowed('connection.create', {\n        source: source,\n        target: shape,\n        hints: {\n          targetParent: target,\n          targetAttach: attach\n        }\n      });\n    }\n\n    if (create || attach) {\n      return {\n        attach: attach,\n        connect: connect\n      };\n    }\n\n    return false;\n  }\n\n\n  /** set drop marker on an element */\n  function setMarker(element, marker) {\n\n    [ MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT ].forEach(function(m) {\n\n      if (m === marker) {\n        canvas.addMarker(element, m);\n      } else {\n        canvas.removeMarker(element, m);\n      }\n    });\n  }\n\n\n  // visual helpers\n\n  function createVisual(shape) {\n    var group, preview, visual;\n\n    group = svgCreate('g');\n    svgAttr(group, styles.cls('djs-drag-group', [ 'no-events' ]));\n\n    svgAppend(canvas.getDefaultLayer(), group);\n\n    preview = svgCreate('g');\n    svgClasses(preview).add('djs-dragger');\n\n    svgAppend(group, preview);\n\n    translate(preview, shape.width / -2, shape.height / -2);\n\n    var visualGroup = svgCreate('g');\n    svgClasses(visualGroup).add('djs-visual');\n\n    svgAppend(preview, visualGroup);\n\n    visual = visualGroup;\n\n    // hijack renderer to draw preview\n    graphicsFactory.drawShape(visual, shape);\n\n    return group;\n  }\n\n\n  // event handlers\n\n  eventBus.on('create.move', function(event) {\n\n    var context = event.context,\n        hover = event.hover,\n        shape = context.shape,\n        source = context.source,\n        canExecute;\n\n    var position = {\n      x: event.x,\n      y: event.y\n    };\n\n    canExecute = context.canExecute = hover && canCreate(shape, hover, source, position);\n\n    // ignore hover visually if canExecute is null\n    if (hover && canExecute !== null) {\n      context.target = hover;\n\n      if (canExecute && canExecute.attach) {\n        setMarker(hover, MARKER_ATTACH);\n      } else {\n        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);\n      }\n    }\n  });\n\n  eventBus.on('create.move', LOW_PRIORITY, function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        visual = context.visual;\n\n    // lazy init drag visual once we received the first real\n    // drag move event (this allows us to get the proper canvas local coordinates)\n    if (!visual) {\n      visual = context.visual = createVisual(shape);\n    }\n\n    translate(visual, event.x, event.y);\n  });\n\n\n  eventBus.on([ 'create.end', 'create.out', 'create.cleanup' ], function(event) {\n    var context = event.context,\n        target = context.target;\n\n    if (target) {\n      setMarker(target, null);\n    }\n  });\n\n  eventBus.on('create.end', function(event) {\n    var context = event.context,\n        source = context.source,\n        shape = context.shape,\n        target = context.target,\n        canExecute = context.canExecute,\n        attach = canExecute && canExecute.attach,\n        connect = canExecute && canExecute.connect,\n        position = {\n          x: event.x,\n          y: event.y\n        };\n\n    if (!canExecute) {\n      return false;\n    }\n\n    if (connect) {\n      // invoke append if connect is set via rules\n      shape = modeling.appendShape(source, shape, position, target, {\n        attach: attach,\n        connection: connect === true ? {} : connect\n      });\n    } else {\n      // invoke create, if connect is not set\n      shape = modeling.createShape(shape, position, target, {\n        attach: attach\n      });\n    }\n\n    // make sure we provide the actual attached\n    // shape with the context so that selection and\n    // other components can use it right after the create\n    // operation ends\n    context.shape = shape;\n  });\n\n\n  eventBus.on('create.cleanup', function(event) {\n    var context = event.context;\n\n    if (context.visual) {\n      svgRemove(context.visual);\n    }\n  });\n\n  // API\n\n  this.start = function(event, shape, source) {\n\n    dragging.init(event, 'create', {\n      cursor: 'grabbing',\n      autoActivate: true,\n      data: {\n        shape: shape,\n        context: {\n          shape: shape,\n          source: source\n        }\n      }\n    });\n  };\n}\n\nCreate.$inject = [\n  'eventBus',\n  'dragging',\n  'rules',\n  'modeling',\n  'canvas',\n  'styles',\n  'graphicsFactory'\n];"]},"metadata":{},"sourceType":"module"}