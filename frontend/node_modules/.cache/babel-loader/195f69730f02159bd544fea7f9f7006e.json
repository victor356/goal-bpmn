{"ast":null,"code":"import { assign } from 'min-dash';\nimport inherits from 'inherits';\nimport { is, getBusinessObject } from '../../../util/ModelUtil';\nimport { isLabelExternal, getExternalLabelMid } from '../../../util/LabelUtil';\nimport { getLabelAdjustment } from './util/LabelLayoutUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nvar DEFAULT_LABEL_DIMENSIONS = {\n  width: 90,\n  height: 20\n};\nvar NAME_PROPERTY = 'name';\nvar TEXT_PROPERTY = 'text';\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnFactory} bpmnFactory\n * @param {TextRenderer} textRenderer\n */\n\nexport default function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {\n  CommandInterceptor.call(this, eventBus); // update label if name property was updated\n\n  this.postExecute('element.updateProperties', function (e) {\n    var context = e.context,\n        element = context.element,\n        properties = context.properties;\n\n    if (NAME_PROPERTY in properties) {\n      modeling.updateLabel(element, properties[NAME_PROPERTY]);\n    }\n\n    if (TEXT_PROPERTY in properties && is(element, 'bpmn:TextAnnotation')) {\n      var newBounds = textRenderer.getTextAnnotationBounds({\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height\n      }, properties[TEXT_PROPERTY] || '');\n      modeling.updateLabel(element, properties.text, newBounds);\n    }\n  }); // create label shape after shape/connection was created\n\n  this.postExecute(['shape.create', 'connection.create'], function (e) {\n    var context = e.context;\n    var element = context.shape || context.connection,\n        businessObject = element.businessObject;\n\n    if (!isLabelExternal(element)) {\n      return;\n    } // only create label if name\n\n\n    if (!businessObject.name) {\n      return;\n    }\n\n    var labelCenter = getExternalLabelMid(element); // we don't care about x and y\n\n    var labelDimensions = textRenderer.getExternalLabelBounds(DEFAULT_LABEL_DIMENSIONS, businessObject.name || '');\n    modeling.createLabel(element, labelCenter, {\n      id: businessObject.id + '_label',\n      businessObject: businessObject,\n      width: labelDimensions.width,\n      height: labelDimensions.height\n    });\n  }); // update label after label shape was deleted\n\n  this.postExecute('shape.delete', function (event) {\n    var context = event.context,\n        labelTarget = context.labelTarget,\n        hints = context.hints || {}; // check if label\n\n    if (labelTarget && hints.unsetLabel !== false) {\n      modeling.updateLabel(labelTarget, null, null, {\n        removeShape: false\n      });\n    }\n  }); // update di information on label creation\n\n  this.postExecute(['label.create'], function (event) {\n    var context = event.context,\n        element = context.shape,\n        businessObject,\n        di; // we want to trigger on real labels only\n\n    if (!element.labelTarget) {\n      return;\n    } // we want to trigger on BPMN elements only\n\n\n    if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    businessObject = element.businessObject, di = businessObject.di;\n\n    if (!di.label) {\n      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {\n        bounds: bpmnFactory.create('dc:Bounds')\n      });\n    }\n\n    assign(di.label.bounds, {\n      x: element.x,\n      y: element.y,\n      width: element.width,\n      height: element.height\n    });\n  });\n\n  function getVisibleLabelAdjustment(event) {\n    var context = event.context,\n        connection = context.connection,\n        label = connection.label,\n        hints = assign({}, context.hints),\n        newWaypoints = context.newWaypoints || connection.waypoints,\n        oldWaypoints = context.oldWaypoints;\n\n    if (typeof hints.startChanged === 'undefined') {\n      hints.startChanged = !!hints.connectionStart;\n    }\n\n    if (typeof hints.endChanged === 'undefined') {\n      hints.endChanged = !!hints.connectionEnd;\n    }\n\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\n  }\n\n  this.postExecute(['connection.layout', 'connection.updateWaypoints'], function (event) {\n    var label = event.context.connection.label,\n        labelAdjustment;\n\n    if (!label) {\n      return;\n    }\n\n    labelAdjustment = getVisibleLabelAdjustment(event);\n    modeling.moveShape(label, labelAdjustment);\n  }); // keep label position on shape replace\n\n  this.postExecute(['shape.replace'], function (event) {\n    var context = event.context,\n        newShape = context.newShape,\n        oldShape = context.oldShape;\n    var businessObject = getBusinessObject(newShape);\n\n    if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {\n      newShape.label.x = oldShape.label.x;\n      newShape.label.y = oldShape.label.y;\n    }\n  });\n}\ninherits(LabelBehavior, CommandInterceptor);\nLabelBehavior.$inject = ['eventBus', 'modeling', 'bpmnFactory', 'textRenderer'];","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/features/modeling/behavior/LabelBehavior.js"],"names":["assign","inherits","is","getBusinessObject","isLabelExternal","getExternalLabelMid","getLabelAdjustment","CommandInterceptor","DEFAULT_LABEL_DIMENSIONS","width","height","NAME_PROPERTY","TEXT_PROPERTY","LabelBehavior","eventBus","modeling","bpmnFactory","textRenderer","call","postExecute","e","context","element","properties","updateLabel","newBounds","getTextAnnotationBounds","x","y","text","shape","connection","businessObject","name","labelCenter","labelDimensions","getExternalLabelBounds","createLabel","id","event","labelTarget","hints","unsetLabel","removeShape","di","label","create","bounds","getVisibleLabelAdjustment","newWaypoints","waypoints","oldWaypoints","startChanged","connectionStart","endChanged","connectionEnd","labelAdjustment","moveShape","newShape","oldShape","$inject"],"mappings":"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","sourcesContent":["import {\n  assign\n} from 'min-dash';\n\nimport inherits from 'inherits';\n\nimport {\n  is,\n  getBusinessObject\n} from '../../../util/ModelUtil';\n\nimport {\n  isLabelExternal,\n  getExternalLabelMid,\n} from '../../../util/LabelUtil';\n\nimport {\n  getLabelAdjustment\n} from './util/LabelLayoutUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nvar DEFAULT_LABEL_DIMENSIONS = {\n  width: 90,\n  height: 20\n};\n\nvar NAME_PROPERTY = 'name';\nvar TEXT_PROPERTY = 'text';\n\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnFactory} bpmnFactory\n * @param {TextRenderer} textRenderer\n */\nexport default function LabelBehavior(\n    eventBus, modeling, bpmnFactory,\n    textRenderer) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  // update label if name property was updated\n  this.postExecute('element.updateProperties', function(e) {\n    var context = e.context,\n        element = context.element,\n        properties = context.properties;\n\n    if (NAME_PROPERTY in properties) {\n      modeling.updateLabel(element, properties[NAME_PROPERTY]);\n    }\n\n    if (TEXT_PROPERTY in properties\n        && is(element, 'bpmn:TextAnnotation')) {\n\n      var newBounds = textRenderer.getTextAnnotationBounds(\n        {\n          x: element.x,\n          y: element.y,\n          width: element.width,\n          height: element.height\n        },\n        properties[TEXT_PROPERTY] || ''\n      );\n\n      modeling.updateLabel(element, properties.text, newBounds);\n    }\n  });\n\n  // create label shape after shape/connection was created\n  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n        businessObject = element.businessObject;\n\n    if (!isLabelExternal(element)) {\n      return;\n    }\n\n    // only create label if name\n    if (!businessObject.name) {\n      return;\n    }\n\n    var labelCenter = getExternalLabelMid(element);\n\n    // we don't care about x and y\n    var labelDimensions = textRenderer.getExternalLabelBounds(\n      DEFAULT_LABEL_DIMENSIONS,\n      businessObject.name || ''\n    );\n\n    modeling.createLabel(element, labelCenter, {\n      id: businessObject.id + '_label',\n      businessObject: businessObject,\n      width: labelDimensions.width,\n      height: labelDimensions.height\n    });\n  });\n\n  // update label after label shape was deleted\n  this.postExecute('shape.delete', function(event) {\n    var context = event.context,\n        labelTarget = context.labelTarget,\n        hints = context.hints || {};\n\n    // check if label\n    if (labelTarget && hints.unsetLabel !== false) {\n      modeling.updateLabel(labelTarget, null, null, { removeShape: false });\n    }\n  });\n\n  // update di information on label creation\n  this.postExecute([ 'label.create' ], function(event) {\n\n    var context = event.context,\n        element = context.shape,\n        businessObject,\n        di;\n\n    // we want to trigger on real labels only\n    if (!element.labelTarget) {\n      return;\n    }\n\n    // we want to trigger on BPMN elements only\n    if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    businessObject = element.businessObject,\n    di = businessObject.di;\n\n\n    if (!di.label) {\n      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {\n        bounds: bpmnFactory.create('dc:Bounds')\n      });\n    }\n\n    assign(di.label.bounds, {\n      x: element.x,\n      y: element.y,\n      width: element.width,\n      height: element.height\n    });\n  });\n\n  function getVisibleLabelAdjustment(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        label = connection.label,\n        hints = assign({}, context.hints),\n        newWaypoints = context.newWaypoints || connection.waypoints,\n        oldWaypoints = context.oldWaypoints;\n\n\n    if (typeof hints.startChanged === 'undefined') {\n      hints.startChanged = !!hints.connectionStart;\n    }\n\n    if (typeof hints.endChanged === 'undefined') {\n      hints.endChanged = !!hints.connectionEnd;\n    }\n\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\n  }\n\n  this.postExecute([\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n\n    var label = event.context.connection.label,\n        labelAdjustment;\n\n    if (!label) {\n      return;\n    }\n\n    labelAdjustment = getVisibleLabelAdjustment(event);\n\n    modeling.moveShape(label, labelAdjustment);\n  });\n\n\n  // keep label position on shape replace\n  this.postExecute([ 'shape.replace' ], function(event) {\n    var context = event.context,\n        newShape = context.newShape,\n        oldShape = context.oldShape;\n\n    var businessObject = getBusinessObject(newShape);\n\n    if (businessObject\n      && isLabelExternal(businessObject)\n      && oldShape.label\n      && newShape.label) {\n      newShape.label.x = oldShape.label.x;\n      newShape.label.y = oldShape.label.y;\n    }\n  });\n\n}\n\ninherits(LabelBehavior, CommandInterceptor);\n\nLabelBehavior.$inject = [\n  'eventBus',\n  'modeling',\n  'bpmnFactory',\n  'textRenderer'\n];"]},"metadata":{},"sourceType":"module"}