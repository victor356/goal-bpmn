{"ast":null,"code":"import { map, filter, sortBy } from 'min-dash';\nimport { getLabel } from '../label-editing/LabelUtil';\n/**\n * Provides ability to search through BPMN elements\n */\n\nexport default function BpmnSearchProvider(elementRegistry, searchPad, canvas) {\n  this._elementRegistry = elementRegistry;\n  this._canvas = canvas;\n  searchPad.registerProvider(this);\n}\nBpmnSearchProvider.$inject = ['elementRegistry', 'searchPad', 'canvas'];\n/**\n * Finds all elements that match given pattern\n *\n * <Result> :\n *  {\n *    primaryTokens: <Array<Token>>,\n *    secondaryTokens: <Array<Token>>,\n *    element: <Element>\n *  }\n *\n * <Token> :\n *  {\n *    normal|matched: <String>\n *  }\n *\n * @param  {String} pattern\n * @return {Array<Result>}\n */\n\nBpmnSearchProvider.prototype.find = function (pattern) {\n  var rootElement = this._canvas.getRootElement();\n\n  var elements = this._elementRegistry.filter(function (element) {\n    if (element.labelTarget) {\n      return false;\n    }\n\n    return true;\n  }); // do not include root element\n\n\n  elements = filter(elements, function (element) {\n    return element !== rootElement;\n  });\n  elements = map(elements, function (element) {\n    return {\n      primaryTokens: matchAndSplit(getLabel(element), pattern),\n      secondaryTokens: matchAndSplit(element.id, pattern),\n      element: element\n    };\n  }); // exclude non-matched elements\n\n  elements = filter(elements, function (element) {\n    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);\n  });\n  elements = sortBy(elements, function (element) {\n    return getLabel(element.element) + element.element.id;\n  });\n  return elements;\n};\n\nfunction hasMatched(tokens) {\n  var matched = filter(tokens, function (t) {\n    return !!t.matched;\n  });\n  return matched.length > 0;\n}\n\nfunction matchAndSplit(text, pattern) {\n  var tokens = [],\n      originalText = text;\n\n  if (!text) {\n    return tokens;\n  }\n\n  text = text.toLowerCase();\n  pattern = pattern.toLowerCase();\n  var i = text.indexOf(pattern);\n\n  if (i > -1) {\n    if (i !== 0) {\n      tokens.push({\n        normal: originalText.substr(0, i)\n      });\n    }\n\n    tokens.push({\n      matched: originalText.substr(i, pattern.length)\n    });\n\n    if (pattern.length + i < text.length) {\n      tokens.push({\n        normal: originalText.substr(pattern.length + i, text.length)\n      });\n    }\n  } else {\n    tokens.push({\n      normal: originalText\n    });\n  }\n\n  return tokens;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/search/BpmnSearchProvider.js"],"names":["map","filter","sortBy","getLabel","BpmnSearchProvider","elementRegistry","searchPad","canvas","_elementRegistry","_canvas","registerProvider","$inject","prototype","find","pattern","rootElement","getRootElement","elements","element","labelTarget","primaryTokens","matchAndSplit","secondaryTokens","id","hasMatched","tokens","matched","t","length","text","originalText","toLowerCase","i","indexOf","push","normal","substr"],"mappings":"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","sourcesContent":["import {\n  map,\n  filter,\n  sortBy\n} from 'min-dash';\n\nimport {\n  getLabel\n} from '../label-editing/LabelUtil';\n\n\n/**\n * Provides ability to search through BPMN elements\n */\nexport default function BpmnSearchProvider(elementRegistry, searchPad, canvas) {\n\n  this._elementRegistry = elementRegistry;\n  this._canvas = canvas;\n\n  searchPad.registerProvider(this);\n}\n\nBpmnSearchProvider.$inject = [\n  'elementRegistry',\n  'searchPad',\n  'canvas'\n];\n\n\n/**\n * Finds all elements that match given pattern\n *\n * <Result> :\n *  {\n *    primaryTokens: <Array<Token>>,\n *    secondaryTokens: <Array<Token>>,\n *    element: <Element>\n *  }\n *\n * <Token> :\n *  {\n *    normal|matched: <String>\n *  }\n *\n * @param  {String} pattern\n * @return {Array<Result>}\n */\nBpmnSearchProvider.prototype.find = function(pattern) {\n  var rootElement = this._canvas.getRootElement();\n\n  var elements = this._elementRegistry.filter(function(element) {\n    if (element.labelTarget) {\n      return false;\n    }\n    return true;\n  });\n\n  // do not include root element\n  elements = filter(elements, function(element) {\n    return element !== rootElement;\n  });\n\n  elements = map(elements, function(element) {\n    return {\n      primaryTokens: matchAndSplit(getLabel(element), pattern),\n      secondaryTokens: matchAndSplit(element.id, pattern),\n      element: element\n    };\n  });\n\n  // exclude non-matched elements\n  elements = filter(elements, function(element) {\n    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);\n  });\n\n  elements = sortBy(elements, function(element) {\n    return getLabel(element.element) + element.element.id;\n  });\n\n  return elements;\n};\n\n\nfunction hasMatched(tokens) {\n  var matched = filter(tokens, function(t) {\n    return !!t.matched;\n  });\n\n  return matched.length > 0;\n}\n\n\nfunction matchAndSplit(text, pattern) {\n  var tokens = [],\n      originalText = text;\n\n  if (!text) {\n    return tokens;\n  }\n\n  text = text.toLowerCase();\n  pattern = pattern.toLowerCase();\n\n  var i = text.indexOf(pattern);\n\n  if (i > -1) {\n    if (i !== 0) {\n      tokens.push({\n        normal: originalText.substr(0, i)\n      });\n    }\n\n    tokens.push({\n      matched: originalText.substr(i, pattern.length)\n    });\n\n    if (pattern.length + i < text.length) {\n      tokens.push({\n        normal: originalText.substr(pattern.length + i, text.length)\n      });\n    }\n  } else {\n    tokens.push({\n      normal: originalText\n    });\n  }\n\n  return tokens;\n}"]},"metadata":{},"sourceType":"module"}