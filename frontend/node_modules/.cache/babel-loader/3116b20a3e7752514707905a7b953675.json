{"ast":null,"code":"import { assign, forEach, bind } from 'min-dash';\nimport { isBuiltIn as isBuiltInType } from './types';\nimport DescriptorBuilder from './descriptor-builder';\nimport { parseName as parseNameNs } from './ns';\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\n\nexport default function Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n  this.packages = [];\n  this.properties = properties;\n  forEach(packages, bind(this.registerPackage, this));\n}\n\nRegistry.prototype.getPackage = function (uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function () {\n  return this.packages;\n};\n\nRegistry.prototype.registerPackage = function (pkg) {\n  // copy package\n  pkg = assign({}, pkg);\n  var pkgMap = this.packageMap;\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri'); // register types\n\n  forEach(pkg.types, bind(function (descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n/**\n * Register a type from a specific package with us\n */\n\n\nRegistry.prototype.registerType = function (type, pkg) {\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign(({}, type.meta || {}))\n  });\n  var ns = parseNameNs(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {}; // parse properties\n\n  forEach(type.properties, bind(function (p) {\n    // namespace property names\n    var propertyNs = parseNameNs(p.name, ns.prefix),\n        propertyName = propertyNs.name; // namespace property types\n\n    if (!isBuiltInType(p.type)) {\n      p.type = parseNameNs(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n    propertiesByName[propertyName] = p;\n  }, this)); // update ns + name\n\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n  forEach(type.extends, bind(function (extendsName) {\n    var extended = this.typeMap[extendsName];\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this)); // link to package\n\n  this.definePackage(type, pkg); // register\n\n  this.typeMap[name] = type;\n};\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\n\n\nRegistry.prototype.mapTypes = function (nsName, iterator, trait) {\n  var type = isBuiltInType(nsName.name) ? {\n    name: nsName.name\n  } : this.typeMap[nsName.name];\n  var self = this;\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n\n  function traverseTrait(cls) {\n    return traverseSuper(cls, true);\n  }\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n\n\n  function traverseSuper(cls, trait) {\n    var parentNs = parseNameNs(cls, isBuiltInType(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper); // call iterator with (type, inherited=!trait)\n\n  iterator(type, !trait);\n  forEach(type.traits, traverseTrait);\n};\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\n\n\nRegistry.prototype.getEffectiveDescriptor = function (name) {\n  var nsName = parseNameNs(name);\n  var builder = new DescriptorBuilder(nsName);\n  this.mapTypes(nsName, function (type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n  var descriptor = builder.build(); // define package link\n\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n  return descriptor;\n};\n\nRegistry.prototype.definePackage = function (target, pkg) {\n  this.properties.define(target, '$pkg', {\n    value: pkg\n  });\n}; ///////// helpers ////////////////////////////\n\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n  var value = pkg[identifierKey];\n\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/moddle/lib/registry.js"],"names":["assign","forEach","bind","isBuiltIn","isBuiltInType","DescriptorBuilder","parseName","parseNameNs","Registry","packages","properties","packageMap","typeMap","registerPackage","prototype","getPackage","uriOrPrefix","getPackages","pkg","pkgMap","ensureAvailable","types","descriptor","registerType","uri","prefix","push","type","superClass","slice","extends","meta","ns","name","propertiesByName","p","propertyNs","propertyName","extendsName","extended","traits","definePackage","mapTypes","nsName","iterator","trait","self","traverseTrait","cls","traverseSuper","parentNs","Error","getEffectiveDescriptor","builder","inherited","addTrait","build","allTypes","length","$pkg","target","define","value","identifierKey"],"mappings":"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","sourcesContent":["import {\n  assign,\n  forEach,\n  bind\n} from 'min-dash';\n\nimport {\n  isBuiltIn as isBuiltInType\n} from './types';\n\nimport DescriptorBuilder from './descriptor-builder';\n\nimport {\n  parseName as parseNameNs\n} from './ns';\n\n\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\nexport default function Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n\n  this.packages = [];\n\n  this.properties = properties;\n\n  forEach(packages, bind(this.registerPackage, this));\n}\n\n\nRegistry.prototype.getPackage = function(uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function() {\n  return this.packages;\n};\n\n\nRegistry.prototype.registerPackage = function(pkg) {\n\n  // copy package\n  pkg = assign({}, pkg);\n\n  var pkgMap = this.packageMap;\n\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri');\n\n  // register types\n  forEach(pkg.types, bind(function(descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function(type, pkg) {\n\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign(({}, type.meta || {}))\n  });\n\n  var ns = parseNameNs(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, bind(function(p) {\n\n    // namespace property names\n    var propertyNs = parseNameNs(p.name, ns.prefix),\n        propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltInType(p.type)) {\n      p.type = parseNameNs(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n\n    propertiesByName[propertyName] = p;\n  }, this));\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n\n  forEach(type.extends, bind(function(extendsName) {\n    var extended = this.typeMap[extendsName];\n\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this));\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n  var type = isBuiltInType(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n  var self = this;\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverseSuper(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverseSuper(cls, trait) {\n    var parentNs = parseNameNs(cls, isBuiltInType(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n\n  forEach(type.traits, traverseTrait);\n};\n\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function(name) {\n\n  var nsName = parseNameNs(name);\n\n  var builder = new DescriptorBuilder(nsName);\n\n  this.mapTypes(nsName, function(type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n  return descriptor;\n};\n\n\nRegistry.prototype.definePackage = function(target, pkg) {\n  this.properties.define(target, '$pkg', { value: pkg });\n};\n\n\n\n///////// helpers ////////////////////////////\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n\n  var value = pkg[identifierKey];\n\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}