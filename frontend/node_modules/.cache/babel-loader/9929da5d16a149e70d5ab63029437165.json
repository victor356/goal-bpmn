{"ast":null,"code":"import inherits from 'inherits';\nimport CommandInterceptor from '../../command/CommandInterceptor';\n/**\n * A basic provider that may be extended to implement modeling rules.\n *\n * Extensions should implement the init method to actually add their custom\n * modeling checks. Checks may be added via the #addRule(action, fn) method.\n *\n * @param {EventBus} eventBus\n */\n\nexport default function RuleProvider(eventBus) {\n  CommandInterceptor.call(this, eventBus);\n  this.init();\n}\nRuleProvider.$inject = ['eventBus'];\ninherits(RuleProvider, CommandInterceptor);\n/**\n * Adds a modeling rule for the given action, implemented through\n * a callback function.\n *\n * The function will receive the modeling specific action context\n * to perform its check. It must return `false` to disallow the\n * action from happening or `true` to allow the action.\n *\n * A rule provider may pass over the evaluation to lower priority\n * rules by returning return nothing (or <code>undefined</code>).\n *\n * @example\n *\n * ResizableRules.prototype.init = function() {\n *\n *   \\/**\n *    * Return `true`, `false` or nothing to denote\n *    * _allowed_, _not allowed_ and _continue evaluating_.\n *    *\\/\n *   this.addRule('shape.resize', function(context) {\n *\n *     var shape = context.shape;\n *\n *     if (!context.newBounds) {\n *       // check general resizability\n *       if (!shape.resizable) {\n *         return false;\n *       }\n *\n *       // not returning anything (read: undefined)\n *       // will continue the evaluation of other rules\n *       // (with lower priority)\n *       return;\n *     } else {\n *       // element must have minimum size of 10*10 points\n *       return context.newBounds.width > 10 && context.newBounds.height > 10;\n *     }\n *   });\n * };\n *\n * @param {String|Array<String>} actions the identifier for the modeling action to check\n * @param {Number} [priority] the priority at which this rule is being applied\n * @param {Function} fn the callback function that performs the actual check\n */\n\nRuleProvider.prototype.addRule = function (actions, priority, fn) {\n  var self = this;\n\n  if (typeof actions === 'string') {\n    actions = [actions];\n  }\n\n  actions.forEach(function (action) {\n    self.canExecute(action, priority, function (context, action, event) {\n      return fn(context);\n    }, true);\n  });\n};\n/**\n * Implement this method to add new rules during provider initialization.\n */\n\n\nRuleProvider.prototype.init = function () {};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/features/rules/RuleProvider.js"],"names":["inherits","CommandInterceptor","RuleProvider","eventBus","call","init","$inject","prototype","addRule","actions","priority","fn","self","forEach","action","canExecute","context","event"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,UAArB;AAEA,OAAOC,kBAAP,MAA+B,kCAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,YAAT,CAAsBC,QAAtB,EAAgC;AAC7CF,EAAAA,kBAAkB,CAACG,IAAnB,CAAwB,IAAxB,EAA8BD,QAA9B;AAEA,OAAKE,IAAL;AACD;AAEDH,YAAY,CAACI,OAAb,GAAuB,CAAE,UAAF,CAAvB;AAEAN,QAAQ,CAACE,YAAD,EAAeD,kBAAf,CAAR;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAC,YAAY,CAACK,SAAb,CAAuBC,OAAvB,GAAiC,UAASC,OAAT,EAAkBC,QAAlB,EAA4BC,EAA5B,EAAgC;AAE/D,MAAIC,IAAI,GAAG,IAAX;;AAEA,MAAI,OAAOH,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,IAAAA,OAAO,GAAG,CAAEA,OAAF,CAAV;AACD;;AAEDA,EAAAA,OAAO,CAACI,OAAR,CAAgB,UAASC,MAAT,EAAiB;AAE/BF,IAAAA,IAAI,CAACG,UAAL,CAAgBD,MAAhB,EAAwBJ,QAAxB,EAAkC,UAASM,OAAT,EAAkBF,MAAlB,EAA0BG,KAA1B,EAAiC;AACjE,aAAON,EAAE,CAACK,OAAD,CAAT;AACD,KAFD,EAEG,IAFH;AAGD,GALD;AAMD,CAdD;AAgBA;AACA;AACA;;;AACAd,YAAY,CAACK,SAAb,CAAuBF,IAAvB,GAA8B,YAAW,CAAE,CAA3C","sourcesContent":["import inherits from 'inherits';\n\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * A basic provider that may be extended to implement modeling rules.\n *\n * Extensions should implement the init method to actually add their custom\n * modeling checks. Checks may be added via the #addRule(action, fn) method.\n *\n * @param {EventBus} eventBus\n */\nexport default function RuleProvider(eventBus) {\n  CommandInterceptor.call(this, eventBus);\n\n  this.init();\n}\n\nRuleProvider.$inject = [ 'eventBus' ];\n\ninherits(RuleProvider, CommandInterceptor);\n\n\n/**\n * Adds a modeling rule for the given action, implemented through\n * a callback function.\n *\n * The function will receive the modeling specific action context\n * to perform its check. It must return `false` to disallow the\n * action from happening or `true` to allow the action.\n *\n * A rule provider may pass over the evaluation to lower priority\n * rules by returning return nothing (or <code>undefined</code>).\n *\n * @example\n *\n * ResizableRules.prototype.init = function() {\n *\n *   \\/**\n *    * Return `true`, `false` or nothing to denote\n *    * _allowed_, _not allowed_ and _continue evaluating_.\n *    *\\/\n *   this.addRule('shape.resize', function(context) {\n *\n *     var shape = context.shape;\n *\n *     if (!context.newBounds) {\n *       // check general resizability\n *       if (!shape.resizable) {\n *         return false;\n *       }\n *\n *       // not returning anything (read: undefined)\n *       // will continue the evaluation of other rules\n *       // (with lower priority)\n *       return;\n *     } else {\n *       // element must have minimum size of 10*10 points\n *       return context.newBounds.width > 10 && context.newBounds.height > 10;\n *     }\n *   });\n * };\n *\n * @param {String|Array<String>} actions the identifier for the modeling action to check\n * @param {Number} [priority] the priority at which this rule is being applied\n * @param {Function} fn the callback function that performs the actual check\n */\nRuleProvider.prototype.addRule = function(actions, priority, fn) {\n\n  var self = this;\n\n  if (typeof actions === 'string') {\n    actions = [ actions ];\n  }\n\n  actions.forEach(function(action) {\n\n    self.canExecute(action, priority, function(context, action, event) {\n      return fn(context);\n    }, true);\n  });\n};\n\n/**\n * Implement this method to add new rules during provider initialization.\n */\nRuleProvider.prototype.init = function() {};"]},"metadata":{},"sourceType":"module"}