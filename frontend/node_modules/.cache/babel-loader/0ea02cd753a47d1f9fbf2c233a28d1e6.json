{"ast":null,"code":"import { flatten, filter, forEach, groupBy, map, unionBy } from 'min-dash';\nimport { saveClear } from '../../util/Removal';\nimport { remove as collectionRemove } from '../../util/Collections';\nimport { getNewAttachShapeDelta } from '../../util/AttachUtil';\nimport inherits from 'inherits';\nvar LOW_PRIORITY = 251,\n    HIGH_PRIORITY = 1401;\nimport CommandInterceptor from '../../command/CommandInterceptor';\n/**\n * Adds the notion of attached elements to the modeler.\n *\n * Optionally depends on `diagram-js/lib/features/move` to render\n * the attached elements during move preview.\n *\n * Optionally depends on `diagram-js/lib/features/label-support`\n * to render attached labels during move preview.\n *\n * @param {didi.Injector} injector\n * @param {EventBus} eventBus\n * @param {Rules} rules\n * @param {Modeling} modeling\n */\n\nexport default function AttachSupport(injector, eventBus, rules, modeling) {\n  CommandInterceptor.call(this, eventBus);\n  var movePreview = injector.get('movePreview', false); // remove all the attached elements from the shapes to be validated\n  // add all the attached shapes to the overall list of moved shapes\n\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function (e) {\n    var context = e.context,\n        shapes = context.shapes,\n        validatedShapes = context.validatedShapes;\n    context.shapes = addAttached(shapes);\n    context.validatedShapes = removeAttached(validatedShapes);\n  }); // add attachers to the visual's group\n\n  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function (e) {\n    var context = e.context,\n        shapes = context.shapes,\n        attachers = getAttachers(shapes);\n    forEach(attachers, function (attacher) {\n      movePreview.makeDraggable(context, attacher, true);\n      forEach(attacher.labels, function (label) {\n        movePreview.makeDraggable(context, label, true);\n      });\n    });\n  }); // add all attachers to move closure\n\n  this.preExecuted('elements.move', HIGH_PRIORITY, function (e) {\n    var context = e.context,\n        closure = context.closure,\n        shapes = context.shapes,\n        attachers = getAttachers(shapes);\n    forEach(attachers, function (attacher) {\n      closure.add(attacher, closure.topLevel[attacher.host.id]);\n    });\n  }); // perform the attaching after shapes are done moving\n\n  this.postExecuted('elements.move', function (e) {\n    var context = e.context,\n        shapes = context.shapes,\n        newHost = context.newHost,\n        attachers; // we only support attachment / detachment of one element\n\n    if (shapes.length > 1) {\n      return;\n    }\n\n    if (newHost) {\n      attachers = shapes;\n    } else {\n      attachers = filter(shapes, function (s) {\n        return !!s.host;\n      });\n    }\n\n    forEach(attachers, function (attacher) {\n      modeling.updateAttachment(attacher, newHost);\n    });\n  }); // ensure invalid attachment connections are removed\n\n  this.postExecuted('elements.move', function (e) {\n    var shapes = e.context.shapes;\n    forEach(shapes, function (shape) {\n      forEach(shape.attachers, function (attacher) {\n        // remove invalid outgoing connections\n        forEach(attacher.outgoing.slice(), function (connection) {\n          var allowed = rules.allowed('connection.reconnectStart', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        }); // remove invalid incoming connections\n\n        forEach(attacher.incoming.slice(), function (connection) {\n          var allowed = rules.allowed('connection.reconnectEnd', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n      });\n    });\n  });\n  this.postExecute('shape.create', function (e) {\n    var context = e.context,\n        shape = context.shape,\n        host = context.host;\n\n    if (host) {\n      modeling.updateAttachment(shape, host);\n    }\n  }); // update attachments if the host is replaced\n\n  this.postExecute('shape.replace', function (e) {\n    var context = e.context,\n        oldShape = context.oldShape,\n        newShape = context.newShape; // move the attachers to the new host\n\n    saveClear(oldShape.attachers, function (attacher) {\n      var allowed = rules.allowed('elements.move', {\n        target: newShape,\n        shapes: [attacher]\n      });\n\n      if (allowed === 'attach') {\n        modeling.updateAttachment(attacher, newShape);\n      } else {\n        modeling.removeShape(attacher);\n      }\n    }); // move attachers if new host has different size\n\n    if (newShape.attachers.length) {\n      forEach(newShape.attachers, function (attacher) {\n        var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);\n        modeling.moveShape(attacher, delta, attacher.parent);\n      });\n    }\n  }); // move shape on host resize\n\n  this.postExecute('shape.resize', function (event) {\n    var context = event.context,\n        shape = context.shape,\n        oldBounds = context.oldBounds,\n        newBounds = context.newBounds,\n        attachers = shape.attachers;\n    forEach(attachers, function (attacher) {\n      var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);\n      modeling.moveShape(attacher, delta, attacher.parent);\n      forEach(attacher.labels, function (label) {\n        modeling.moveShape(label, delta, label.parent);\n      });\n    });\n  }); // remove attachments\n\n  this.preExecute('shape.delete', function (event) {\n    var shape = event.context.shape;\n    saveClear(shape.attachers, function (attacher) {\n      modeling.removeShape(attacher);\n    });\n\n    if (shape.host) {\n      modeling.updateAttachment(shape, null);\n    }\n  }); // Prevent attachers and their labels from moving, when the space tool is performed.\n  // Otherwise the attachers and their labels would be moved twice.\n\n  eventBus.on('spaceTool.move', function (event) {\n    var context = event.context,\n        initialized = context.initialized,\n        attachSupportInitialized = context.attachSupportInitialized;\n\n    if (!initialized || attachSupportInitialized) {\n      return;\n    }\n\n    var movingShapes = context.movingShapes; // collect attachers whose host is not being moved using the space tool\n\n    var staticAttachers = filter(movingShapes, function (shape) {\n      var host = shape.host;\n      return host && movingShapes.indexOf(host) === -1;\n    }); // remove attachers that are not going to be moved from moving shapes\n\n    forEach(staticAttachers, function (shape) {\n      collectionRemove(movingShapes, shape);\n      forEach(shape.labels, function (label) {\n        collectionRemove(movingShapes, shape.label);\n      });\n    });\n    context.attachSupportInitialized = true;\n  });\n}\ninherits(AttachSupport, CommandInterceptor);\nAttachSupport.$inject = ['injector', 'eventBus', 'rules', 'modeling'];\n/**\n * Return attachers of the given shapes\n *\n * @param {Array<djs.model.Base>} shapes\n * @return {Array<djs.model.Base>}\n */\n\nfunction getAttachers(shapes) {\n  return flatten(map(shapes, function (s) {\n    return s.attachers || [];\n  }));\n}\n/**\n * Return a combined list of elements and\n * attachers.\n *\n * @param {Array<djs.model.Base>} elements\n * @return {Array<djs.model.Base>} filtered\n */\n\n\nfunction addAttached(elements) {\n  var attachers = getAttachers(elements);\n  return unionBy('id', elements, attachers);\n}\n/**\n * Return a filtered list of elements that do not\n * contain attached elements with hosts being part\n * of the selection.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\n\n\nfunction removeAttached(elements) {\n  var ids = groupBy(elements, 'id');\n  return filter(elements, function (element) {\n    while (element) {\n      // host in selection\n      if (element.host && ids[element.host.id]) {\n        return false;\n      }\n\n      element = element.parent;\n    }\n\n    return true;\n  });\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/features/attach-support/AttachSupport.js"],"names":["flatten","filter","forEach","groupBy","map","unionBy","saveClear","remove","collectionRemove","getNewAttachShapeDelta","inherits","LOW_PRIORITY","HIGH_PRIORITY","CommandInterceptor","AttachSupport","injector","eventBus","rules","modeling","call","movePreview","get","on","e","context","shapes","validatedShapes","addAttached","removeAttached","attachers","getAttachers","attacher","makeDraggable","labels","label","preExecuted","closure","add","topLevel","host","id","postExecuted","newHost","length","s","updateAttachment","shape","outgoing","slice","connection","allowed","source","target","removeConnection","incoming","postExecute","oldShape","newShape","removeShape","delta","moveShape","parent","event","oldBounds","newBounds","preExecute","initialized","attachSupportInitialized","movingShapes","staticAttachers","indexOf","$inject","elements","ids","element"],"mappings":"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","sourcesContent":["import {\n  flatten,\n  filter,\n  forEach,\n  groupBy,\n  map,\n  unionBy\n} from 'min-dash';\n\nimport { saveClear } from '../../util/Removal';\n\nimport {\n  remove as collectionRemove\n} from '../../util/Collections';\n\nimport { getNewAttachShapeDelta } from '../../util/AttachUtil';\n\nimport inherits from 'inherits';\n\nvar LOW_PRIORITY = 251,\n    HIGH_PRIORITY = 1401;\n\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n\n/**\n * Adds the notion of attached elements to the modeler.\n *\n * Optionally depends on `diagram-js/lib/features/move` to render\n * the attached elements during move preview.\n *\n * Optionally depends on `diagram-js/lib/features/label-support`\n * to render attached labels during move preview.\n *\n * @param {didi.Injector} injector\n * @param {EventBus} eventBus\n * @param {Rules} rules\n * @param {Modeling} modeling\n */\nexport default function AttachSupport(injector, eventBus, rules, modeling) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  var movePreview = injector.get('movePreview', false);\n\n\n  // remove all the attached elements from the shapes to be validated\n  // add all the attached shapes to the overall list of moved shapes\n  eventBus.on('shape.move.start', HIGH_PRIORITY, function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        validatedShapes = context.validatedShapes;\n\n    context.shapes = addAttached(shapes);\n\n    context.validatedShapes = removeAttached(validatedShapes);\n  });\n\n  // add attachers to the visual's group\n  movePreview && eventBus.on('shape.move.start', LOW_PRIORITY, function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        attachers = getAttachers(shapes);\n\n    forEach(attachers, function(attacher) {\n      movePreview.makeDraggable(context, attacher, true);\n\n      forEach(attacher.labels, function(label) {\n        movePreview.makeDraggable(context, label, true);\n      });\n    });\n  });\n\n\n  // add all attachers to move closure\n  this.preExecuted('elements.move', HIGH_PRIORITY, function(e) {\n    var context = e.context,\n        closure = context.closure,\n        shapes = context.shapes,\n        attachers = getAttachers(shapes);\n\n    forEach(attachers, function(attacher) {\n      closure.add(attacher, closure.topLevel[attacher.host.id]);\n    });\n  });\n\n  // perform the attaching after shapes are done moving\n  this.postExecuted('elements.move', function(e) {\n\n    var context = e.context,\n        shapes = context.shapes,\n        newHost = context.newHost,\n        attachers;\n\n    // we only support attachment / detachment of one element\n    if (shapes.length > 1) {\n      return;\n    }\n\n    if (newHost) {\n\n      attachers = shapes;\n    } else {\n\n      attachers = filter(shapes, function(s) {\n        return !!s.host;\n      });\n    }\n\n    forEach(attachers, function(attacher) {\n      modeling.updateAttachment(attacher, newHost);\n    });\n  });\n\n  // ensure invalid attachment connections are removed\n  this.postExecuted('elements.move', function(e) {\n\n    var shapes = e.context.shapes;\n\n    forEach(shapes, function(shape) {\n\n      forEach(shape.attachers, function(attacher) {\n\n        // remove invalid outgoing connections\n        forEach(attacher.outgoing.slice(), function(connection) {\n          var allowed = rules.allowed('connection.reconnectStart', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n\n        // remove invalid incoming connections\n        forEach(attacher.incoming.slice(), function(connection) {\n          var allowed = rules.allowed('connection.reconnectEnd', {\n            connection: connection,\n            source: connection.source,\n            target: connection.target\n          });\n\n          if (!allowed) {\n            modeling.removeConnection(connection);\n          }\n        });\n      });\n    });\n  });\n\n  this.postExecute('shape.create', function(e) {\n    var context = e.context,\n        shape = context.shape,\n        host = context.host;\n\n    if (host) {\n      modeling.updateAttachment(shape, host);\n    }\n  });\n\n  // update attachments if the host is replaced\n  this.postExecute('shape.replace', function(e) {\n\n    var context = e.context,\n        oldShape = context.oldShape,\n        newShape = context.newShape;\n\n    // move the attachers to the new host\n    saveClear(oldShape.attachers, function(attacher) {\n      var allowed = rules.allowed('elements.move', {\n        target: newShape,\n        shapes: [attacher]\n      });\n\n      if (allowed === 'attach') {\n        modeling.updateAttachment(attacher, newShape);\n      } else {\n        modeling.removeShape(attacher);\n      }\n    });\n\n    // move attachers if new host has different size\n    if (newShape.attachers.length) {\n\n      forEach(newShape.attachers, function(attacher) {\n        var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);\n        modeling.moveShape(attacher, delta, attacher.parent);\n      });\n    }\n\n  });\n\n  // move shape on host resize\n  this.postExecute('shape.resize', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        oldBounds = context.oldBounds,\n        newBounds = context.newBounds,\n        attachers = shape.attachers;\n\n    forEach(attachers, function(attacher) {\n      var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);\n\n      modeling.moveShape(attacher, delta, attacher.parent);\n\n      forEach(attacher.labels, function(label) {\n        modeling.moveShape(label, delta, label.parent);\n      });\n    });\n  });\n\n  // remove attachments\n  this.preExecute('shape.delete', function(event) {\n\n    var shape = event.context.shape;\n\n    saveClear(shape.attachers, function(attacher) {\n      modeling.removeShape(attacher);\n    });\n\n    if (shape.host) {\n      modeling.updateAttachment(shape, null);\n    }\n  });\n\n\n  // Prevent attachers and their labels from moving, when the space tool is performed.\n  // Otherwise the attachers and their labels would be moved twice.\n  eventBus.on('spaceTool.move', function(event) {\n\n    var context = event.context,\n        initialized = context.initialized,\n        attachSupportInitialized = context.attachSupportInitialized;\n\n    if (!initialized || attachSupportInitialized) {\n      return;\n    }\n\n    var movingShapes = context.movingShapes;\n\n    // collect attachers whose host is not being moved using the space tool\n    var staticAttachers = filter(movingShapes, function(shape) {\n      var host = shape.host;\n\n      return host && movingShapes.indexOf(host) === -1;\n    });\n\n    // remove attachers that are not going to be moved from moving shapes\n    forEach(staticAttachers, function(shape) {\n      collectionRemove(movingShapes, shape);\n\n      forEach(shape.labels, function(label) {\n        collectionRemove(movingShapes, shape.label);\n      });\n    });\n\n    context.attachSupportInitialized = true;\n  });\n}\n\ninherits(AttachSupport, CommandInterceptor);\n\nAttachSupport.$inject = [\n  'injector',\n  'eventBus',\n  'rules',\n  'modeling'\n];\n\n\n/**\n * Return attachers of the given shapes\n *\n * @param {Array<djs.model.Base>} shapes\n * @return {Array<djs.model.Base>}\n */\nfunction getAttachers(shapes) {\n  return flatten(map(shapes, function(s) {\n    return s.attachers || [];\n  }));\n}\n\n/**\n * Return a combined list of elements and\n * attachers.\n *\n * @param {Array<djs.model.Base>} elements\n * @return {Array<djs.model.Base>} filtered\n */\nfunction addAttached(elements) {\n  var attachers = getAttachers(elements);\n\n  return unionBy('id', elements, attachers);\n}\n\n/**\n * Return a filtered list of elements that do not\n * contain attached elements with hosts being part\n * of the selection.\n *\n * @param  {Array<djs.model.Base>} elements\n *\n * @return {Array<djs.model.Base>} filtered\n */\nfunction removeAttached(elements) {\n\n  var ids = groupBy(elements, 'id');\n\n  return filter(elements, function(element) {\n    while (element) {\n\n      // host in selection\n      if (element.host && ids[element.host.id]) {\n        return false;\n      }\n\n      element = element.parent;\n    }\n\n    return true;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}