{"ast":null,"code":"import inherits from 'inherits';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { add as collectionAdd, remove as collectionRemove } from 'diagram-js/lib/util/Collections';\nimport { find } from 'min-dash';\nimport { is } from '../../../util/ModelUtil';\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\n/**\n * This behavior makes sure we always set a fake\n * DataInputAssociation#targetRef as demanded by the BPMN 2.0\n * XSD schema.\n *\n * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n * which is created on the fly and cleaned up afterwards if not needed\n * anymore.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n */\n\nexport default function DataInputAssociationBehavior(eventBus, bpmnFactory) {\n  CommandInterceptor.call(this, eventBus);\n  this.executed(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnectEnd'], ifDataInputAssociation(fixTargetRef));\n  this.reverted(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnectEnd'], ifDataInputAssociation(fixTargetRef));\n\n  function usesTargetRef(element, targetRef, removedConnection) {\n    var inputAssociations = element.get('dataInputAssociations');\n    return find(inputAssociations, function (association) {\n      return association !== removedConnection && association.targetRef === targetRef;\n    });\n  }\n\n  function getTargetRef(element, create) {\n    var properties = element.get('properties');\n    var targetRefProp = find(properties, function (p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n      collectionAdd(properties, targetRefProp);\n    }\n\n    return targetRefProp;\n  }\n\n  function cleanupTargetRef(element, connection) {\n    var targetRefProp = getTargetRef(element);\n\n    if (!targetRefProp) {\n      return;\n    }\n\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      collectionRemove(element.get('properties'), targetRefProp);\n    }\n  }\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n\n\n  function fixTargetRef(event) {\n    var context = event.context,\n        connection = context.connection,\n        connectionBo = connection.businessObject,\n        target = connection.target,\n        targetBo = target && target.businessObject,\n        newTarget = context.newTarget,\n        newTargetBo = newTarget && newTarget.businessObject,\n        oldTarget = context.oldTarget || context.target,\n        oldTargetBo = oldTarget && oldTarget.businessObject;\n    var dataAssociation = connection.businessObject,\n        targetRefProp;\n\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}\nDataInputAssociationBehavior.$inject = ['eventBus', 'bpmnFactory'];\ninherits(DataInputAssociationBehavior, CommandInterceptor);\n/**\n * Only call the given function when the event\n * touches a bpmn:DataInputAssociation.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nfunction ifDataInputAssociation(fn) {\n  return function (event) {\n    var context = event.context,\n        connection = context.connection;\n\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/modeling/behavior/DataInputAssociationBehavior.js"],"names":["inherits","CommandInterceptor","add","collectionAdd","remove","collectionRemove","find","is","TARGET_REF_PLACEHOLDER_NAME","DataInputAssociationBehavior","eventBus","bpmnFactory","call","executed","ifDataInputAssociation","fixTargetRef","reverted","usesTargetRef","element","targetRef","removedConnection","inputAssociations","get","association","getTargetRef","create","properties","targetRefProp","p","name","cleanupTargetRef","connection","event","context","connectionBo","businessObject","target","targetBo","newTarget","newTargetBo","oldTarget","oldTargetBo","dataAssociation","$inject","fn"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  find\n} from 'min-dash';\n\nimport {\n  is\n} from '../../../util/ModelUtil';\n\nvar TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';\n\n\n/**\n * This behavior makes sure we always set a fake\n * DataInputAssociation#targetRef as demanded by the BPMN 2.0\n * XSD schema.\n *\n * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }\n * which is created on the fly and cleaned up afterwards if not needed\n * anymore.\n *\n * @param {EventBus} eventBus\n * @param {BpmnFactory} bpmnFactory\n */\nexport default function DataInputAssociationBehavior(eventBus, bpmnFactory) {\n\n  CommandInterceptor.call(this, eventBus);\n\n\n  this.executed([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnectEnd'\n  ], ifDataInputAssociation(fixTargetRef));\n\n  this.reverted([\n    'connection.create',\n    'connection.delete',\n    'connection.move',\n    'connection.reconnectEnd'\n  ], ifDataInputAssociation(fixTargetRef));\n\n\n  function usesTargetRef(element, targetRef, removedConnection) {\n\n    var inputAssociations = element.get('dataInputAssociations');\n\n    return find(inputAssociations, function(association) {\n      return association !== removedConnection &&\n             association.targetRef === targetRef;\n    });\n  }\n\n  function getTargetRef(element, create) {\n\n    var properties = element.get('properties');\n\n    var targetRefProp = find(properties, function(p) {\n      return p.name === TARGET_REF_PLACEHOLDER_NAME;\n    });\n\n    if (!targetRefProp && create) {\n      targetRefProp = bpmnFactory.create('bpmn:Property', {\n        name: TARGET_REF_PLACEHOLDER_NAME\n      });\n\n      collectionAdd(properties, targetRefProp);\n    }\n\n    return targetRefProp;\n  }\n\n  function cleanupTargetRef(element, connection) {\n\n    var targetRefProp = getTargetRef(element);\n\n    if (!targetRefProp) {\n      return;\n    }\n\n    if (!usesTargetRef(element, targetRefProp, connection)) {\n      collectionRemove(element.get('properties'), targetRefProp);\n    }\n  }\n\n  /**\n   * Make sure targetRef is set to a valid property or\n   * `null` if the connection is detached.\n   *\n   * @param {Event} event\n   */\n  function fixTargetRef(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        connectionBo = connection.businessObject,\n        target = connection.target,\n        targetBo = target && target.businessObject,\n        newTarget = context.newTarget,\n        newTargetBo = newTarget && newTarget.businessObject,\n        oldTarget = context.oldTarget || context.target,\n        oldTargetBo = oldTarget && oldTarget.businessObject;\n\n    var dataAssociation = connection.businessObject,\n        targetRefProp;\n\n    if (oldTargetBo && oldTargetBo !== targetBo) {\n      cleanupTargetRef(oldTargetBo, connectionBo);\n    }\n\n    if (newTargetBo && newTargetBo !== targetBo) {\n      cleanupTargetRef(newTargetBo, connectionBo);\n    }\n\n    if (targetBo) {\n      targetRefProp = getTargetRef(targetBo, true);\n      dataAssociation.targetRef = targetRefProp;\n    } else {\n      dataAssociation.targetRef = null;\n    }\n  }\n}\n\nDataInputAssociationBehavior.$inject = [\n  'eventBus',\n  'bpmnFactory'\n];\n\ninherits(DataInputAssociationBehavior, CommandInterceptor);\n\n\n/**\n * Only call the given function when the event\n * touches a bpmn:DataInputAssociation.\n *\n * @param {Function} fn\n * @return {Function}\n */\nfunction ifDataInputAssociation(fn) {\n\n  return function(event) {\n    var context = event.context,\n        connection = context.connection;\n\n    if (is(connection, 'bpmn:DataInputAssociation')) {\n      return fn(event);\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}