{"ast":null,"code":"import { isFunction, isArray, isNumber, bind, assign } from 'min-dash';\nvar FN_REF = '__fn';\nvar DEFAULT_PRIORITY = 1000;\nvar slice = Array.prototype.slice;\n/**\n * A general purpose event bus.\n *\n * This component is used to communicate across a diagram instance.\n * Other parts of a diagram can use it to listen to and broadcast events.\n *\n *\n * ## Registering for Events\n *\n * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\n * methods to register for events. {@link EventBus#off} can be used to\n * remove event registrations. Listeners receive an instance of {@link Event}\n * as the first argument. It allows them to hook into the event execution.\n *\n * ```javascript\n *\n * // listen for event\n * eventBus.on('foo', function(event) {\n *\n *   // access event type\n *   event.type; // 'foo'\n *\n *   // stop propagation to other listeners\n *   event.stopPropagation();\n *\n *   // prevent event default\n *   event.preventDefault();\n * });\n *\n * // listen for event with custom payload\n * eventBus.on('bar', function(event, payload) {\n *   console.log(payload);\n * });\n *\n * // listen for event returning value\n * eventBus.on('foobar', function(event) {\n *\n *   // stop event propagation + prevent default\n *   return false;\n *\n *   // stop event propagation + return custom result\n *   return {\n *     complex: 'listening result'\n *   };\n * });\n *\n *\n * // listen with custom priority (default=1000, higher is better)\n * eventBus.on('priorityfoo', 1500, function(event) {\n *   console.log('invoked first!');\n * });\n *\n *\n * // listen for event and pass the context (`this`)\n * eventBus.on('foobar', function(event) {\n *   this.foo();\n * }, this);\n * ```\n *\n *\n * ## Emitting Events\n *\n * Events can be emitted via the event bus using {@link EventBus#fire}.\n *\n * ```javascript\n *\n * // false indicates that the default action\n * // was prevented by listeners\n * if (eventBus.fire('foo') === false) {\n *   console.log('default has been prevented!');\n * };\n *\n *\n * // custom args + return value listener\n * eventBus.on('sum', function(event, a, b) {\n *   return a + b;\n * });\n *\n * // you can pass custom arguments + retrieve result values.\n * var sum = eventBus.fire('sum', 1, 2);\n * console.log(sum); // 3\n * ```\n */\n\nexport default function EventBus() {\n  this._listeners = {}; // cleanup on destroy on lowest priority to allow\n  // message passing until the bitter end\n\n  this.on('diagram.destroy', 1, this._destroy, this);\n}\n/**\n * Register an event listener for events with the given name.\n *\n * The callback will be invoked with `event, ...additionalArguments`\n * that have been passed to {@link EventBus#fire}.\n *\n * Returning false from a listener will prevent the events default action\n * (if any is specified). To stop an event from being processed further in\n * other listeners execute {@link Event#stopPropagation}.\n *\n * Returning anything but `undefined` from a listener will stop the listener propagation.\n *\n * @param {String|Array<String>} events\n * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher\n * @param {Function} callback\n * @param {Object} [that] Pass context (`this`) to the callback\n */\n\nEventBus.prototype.on = function (events, priority, callback, that) {\n  events = isArray(events) ? events : [events];\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  var actualCallback = callback;\n\n  if (that) {\n    actualCallback = bind(callback, that); // make sure we remember and are able to remove\n    // bound callbacks via {@link #off} using the original\n    // callback\n\n    actualCallback[FN_REF] = callback[FN_REF] || callback;\n  }\n\n  var self = this;\n  events.forEach(function (e) {\n    self._addListener(e, {\n      priority: priority,\n      callback: actualCallback,\n      next: null\n    });\n  });\n};\n/**\n * Register an event listener that is executed only once.\n *\n * @param {String} event the event name to register for\n * @param {Function} callback the callback to execute\n * @param {Object} [that] Pass context (`this`) to the callback\n */\n\n\nEventBus.prototype.once = function (event, priority, callback, that) {\n  var self = this;\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  function wrappedCallback() {\n    var result = callback.apply(that, arguments);\n    self.off(event, wrappedCallback);\n    return result;\n  } // make sure we remember and are able to remove\n  // bound callbacks via {@link #off} using the original\n  // callback\n\n\n  wrappedCallback[FN_REF] = callback;\n  this.on(event, priority, wrappedCallback);\n};\n/**\n * Removes event listeners by event and callback.\n *\n * If no callback is given, all listeners for a given event name are being removed.\n *\n * @param {String|Array<String>} events\n * @param {Function} [callback]\n */\n\n\nEventBus.prototype.off = function (events, callback) {\n  events = isArray(events) ? events : [events];\n  var self = this;\n  events.forEach(function (event) {\n    self._removeListener(event, callback);\n  });\n};\n/**\n * Create an EventBus event.\n *\n * @param {Object} data\n *\n * @return {Object} event, recognized by the eventBus\n */\n\n\nEventBus.prototype.createEvent = function (data) {\n  var event = new InternalEvent();\n  event.init(data);\n  return event;\n};\n/**\n * Fires a named event.\n *\n * @example\n *\n * // fire event by name\n * events.fire('foo');\n *\n * // fire event object with nested type\n * var event = { type: 'foo' };\n * events.fire(event);\n *\n * // fire event with explicit type\n * var event = { x: 10, y: 20 };\n * events.fire('element.moved', event);\n *\n * // pass additional arguments to the event\n * events.on('foo', function(event, bar) {\n *   alert(bar);\n * });\n *\n * events.fire({ type: 'foo' }, 'I am bar!');\n *\n * @param {String} [name] the optional event name\n * @param {Object} [event] the event object\n * @param {...Object} additional arguments to be passed to the callback functions\n *\n * @return {Boolean} the events return value, if specified or false if the\n *                   default action was prevented by listeners\n */\n\n\nEventBus.prototype.fire = function (type, data) {\n  var event, firstListener, returnValue, args;\n  args = slice.call(arguments);\n\n  if (typeof type === 'object') {\n    event = type;\n    type = event.type;\n  }\n\n  if (!type) {\n    throw new Error('no event type specified');\n  }\n\n  firstListener = this._listeners[type];\n\n  if (!firstListener) {\n    return;\n  } // we make sure we fire instances of our home made\n  // events here. We wrap them only once, though\n\n\n  if (data instanceof InternalEvent) {\n    // we are fine, we alread have an event\n    event = data;\n  } else {\n    event = this.createEvent(data);\n  } // ensure we pass the event as the first parameter\n\n\n  args[0] = event; // original event type (in case we delegate)\n\n  var originalType = event.type; // update event type before delegation\n\n  if (type !== originalType) {\n    event.type = type;\n  }\n\n  try {\n    returnValue = this._invokeListeners(event, args, firstListener);\n  } finally {\n    // reset event type after delegation\n    if (type !== originalType) {\n      event.type = originalType;\n    }\n  } // set the return value to false if the event default\n  // got prevented and no other return value exists\n\n\n  if (returnValue === undefined && event.defaultPrevented) {\n    returnValue = false;\n  }\n\n  return returnValue;\n};\n\nEventBus.prototype.handleError = function (error) {\n  return this.fire('error', {\n    error: error\n  }) === false;\n};\n\nEventBus.prototype._destroy = function () {\n  this._listeners = {};\n};\n\nEventBus.prototype._invokeListeners = function (event, args, listener) {\n  var returnValue;\n\n  while (listener) {\n    // handle stopped propagation\n    if (event.cancelBubble) {\n      break;\n    }\n\n    returnValue = this._invokeListener(event, args, listener);\n    listener = listener.next;\n  }\n\n  return returnValue;\n};\n\nEventBus.prototype._invokeListener = function (event, args, listener) {\n  var returnValue;\n\n  try {\n    // returning false prevents the default action\n    returnValue = invokeFunction(listener.callback, args); // stop propagation on return value\n\n    if (returnValue !== undefined) {\n      event.returnValue = returnValue;\n      event.stopPropagation();\n    } // prevent default on return false\n\n\n    if (returnValue === false) {\n      event.preventDefault();\n    }\n  } catch (e) {\n    if (!this.handleError(e)) {\n      console.error('unhandled error in event listener');\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  return returnValue;\n};\n/*\n * Add new listener with a certain priority to the list\n * of listeners (for the given event).\n *\n * The semantics of listener registration / listener execution are\n * first register, first serve: New listeners will always be inserted\n * after existing listeners with the same priority.\n *\n * Example: Inserting two listeners with priority 1000 and 1300\n *\n *    * before: [ 1500, 1500, 1000, 1000 ]\n *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\n *\n * @param {String} event\n * @param {Object} listener { priority, callback }\n */\n\n\nEventBus.prototype._addListener = function (event, newListener) {\n  var listener = this._getListeners(event),\n      previousListener; // no prior listeners\n\n\n  if (!listener) {\n    this._setListeners(event, newListener);\n\n    return;\n  } // ensure we order listeners by priority from\n  // 0 (high) to n > 0 (low)\n\n\n  while (listener) {\n    if (listener.priority < newListener.priority) {\n      newListener.next = listener;\n\n      if (previousListener) {\n        previousListener.next = newListener;\n      } else {\n        this._setListeners(event, newListener);\n      }\n\n      return;\n    }\n\n    previousListener = listener;\n    listener = listener.next;\n  } // add new listener to back\n\n\n  previousListener.next = newListener;\n};\n\nEventBus.prototype._getListeners = function (name) {\n  return this._listeners[name];\n};\n\nEventBus.prototype._setListeners = function (name, listener) {\n  this._listeners[name] = listener;\n};\n\nEventBus.prototype._removeListener = function (event, callback) {\n  var listener = this._getListeners(event),\n      nextListener,\n      previousListener,\n      listenerCallback;\n\n  if (!callback) {\n    // clear listeners\n    this._setListeners(event, null);\n\n    return;\n  }\n\n  while (listener) {\n    nextListener = listener.next;\n    listenerCallback = listener.callback;\n\n    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\n      if (previousListener) {\n        previousListener.next = nextListener;\n      } else {\n        // new first listener\n        this._setListeners(event, nextListener);\n      }\n    }\n\n    previousListener = listener;\n    listener = nextListener;\n  }\n};\n/**\n * A event that is emitted via the event bus.\n */\n\n\nfunction InternalEvent() {}\n\nInternalEvent.prototype.stopPropagation = function () {\n  this.cancelBubble = true;\n};\n\nInternalEvent.prototype.preventDefault = function () {\n  this.defaultPrevented = true;\n};\n\nInternalEvent.prototype.init = function (data) {\n  assign(this, data || {});\n};\n/**\n * Invoke function. Be fast...\n *\n * @param {Function} fn\n * @param {Array<Object>} args\n *\n * @return {Any}\n */\n\n\nfunction invokeFunction(fn, args) {\n  return fn.apply(null, args);\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/core/EventBus.js"],"names":["isFunction","isArray","isNumber","bind","assign","FN_REF","DEFAULT_PRIORITY","slice","Array","prototype","EventBus","_listeners","on","_destroy","events","priority","callback","that","Error","actualCallback","self","forEach","e","_addListener","next","once","event","wrappedCallback","result","apply","arguments","off","_removeListener","createEvent","data","InternalEvent","init","fire","type","firstListener","returnValue","args","call","originalType","_invokeListeners","undefined","defaultPrevented","handleError","error","listener","cancelBubble","_invokeListener","invokeFunction","stopPropagation","preventDefault","console","stack","newListener","_getListeners","previousListener","_setListeners","name","nextListener","listenerCallback","fn"],"mappings":"AAAA,SACEA,UADF,EAEEC,OAFF,EAGEC,QAHF,EAIEC,IAJF,EAKEC,MALF,QAMO,UANP;AAQA,IAAIC,MAAM,GAAG,MAAb;AAEA,IAAIC,gBAAgB,GAAG,IAAvB;AAEA,IAAIC,KAAK,GAAGC,KAAK,CAACC,SAAN,CAAgBF,KAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASG,QAAT,GAAoB;AACjC,OAAKC,UAAL,GAAkB,EAAlB,CADiC,CAGjC;AACA;;AACA,OAAKC,EAAL,CAAQ,iBAAR,EAA2B,CAA3B,EAA8B,KAAKC,QAAnC,EAA6C,IAA7C;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAH,QAAQ,CAACD,SAAT,CAAmBG,EAAnB,GAAwB,UAASE,MAAT,EAAiBC,QAAjB,EAA2BC,QAA3B,EAAqCC,IAArC,EAA2C;AAEjEH,EAAAA,MAAM,GAAGb,OAAO,CAACa,MAAD,CAAP,GAAkBA,MAAlB,GAA2B,CAAEA,MAAF,CAApC;;AAEA,MAAId,UAAU,CAACe,QAAD,CAAd,EAA0B;AACxBE,IAAAA,IAAI,GAAGD,QAAP;AACAA,IAAAA,QAAQ,GAAGD,QAAX;AACAA,IAAAA,QAAQ,GAAGT,gBAAX;AACD;;AAED,MAAI,CAACJ,QAAQ,CAACa,QAAD,CAAb,EAAyB;AACvB,UAAM,IAAIG,KAAJ,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","sourcesContent":["import {\n  isFunction,\n  isArray,\n  isNumber,\n  bind,\n  assign\n} from 'min-dash';\n\nvar FN_REF = '__fn';\n\nvar DEFAULT_PRIORITY = 1000;\n\nvar slice = Array.prototype.slice;\n\n/**\n * A general purpose event bus.\n *\n * This component is used to communicate across a diagram instance.\n * Other parts of a diagram can use it to listen to and broadcast events.\n *\n *\n * ## Registering for Events\n *\n * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\n * methods to register for events. {@link EventBus#off} can be used to\n * remove event registrations. Listeners receive an instance of {@link Event}\n * as the first argument. It allows them to hook into the event execution.\n *\n * ```javascript\n *\n * // listen for event\n * eventBus.on('foo', function(event) {\n *\n *   // access event type\n *   event.type; // 'foo'\n *\n *   // stop propagation to other listeners\n *   event.stopPropagation();\n *\n *   // prevent event default\n *   event.preventDefault();\n * });\n *\n * // listen for event with custom payload\n * eventBus.on('bar', function(event, payload) {\n *   console.log(payload);\n * });\n *\n * // listen for event returning value\n * eventBus.on('foobar', function(event) {\n *\n *   // stop event propagation + prevent default\n *   return false;\n *\n *   // stop event propagation + return custom result\n *   return {\n *     complex: 'listening result'\n *   };\n * });\n *\n *\n * // listen with custom priority (default=1000, higher is better)\n * eventBus.on('priorityfoo', 1500, function(event) {\n *   console.log('invoked first!');\n * });\n *\n *\n * // listen for event and pass the context (`this`)\n * eventBus.on('foobar', function(event) {\n *   this.foo();\n * }, this);\n * ```\n *\n *\n * ## Emitting Events\n *\n * Events can be emitted via the event bus using {@link EventBus#fire}.\n *\n * ```javascript\n *\n * // false indicates that the default action\n * // was prevented by listeners\n * if (eventBus.fire('foo') === false) {\n *   console.log('default has been prevented!');\n * };\n *\n *\n * // custom args + return value listener\n * eventBus.on('sum', function(event, a, b) {\n *   return a + b;\n * });\n *\n * // you can pass custom arguments + retrieve result values.\n * var sum = eventBus.fire('sum', 1, 2);\n * console.log(sum); // 3\n * ```\n */\nexport default function EventBus() {\n  this._listeners = {};\n\n  // cleanup on destroy on lowest priority to allow\n  // message passing until the bitter end\n  this.on('diagram.destroy', 1, this._destroy, this);\n}\n\n\n/**\n * Register an event listener for events with the given name.\n *\n * The callback will be invoked with `event, ...additionalArguments`\n * that have been passed to {@link EventBus#fire}.\n *\n * Returning false from a listener will prevent the events default action\n * (if any is specified). To stop an event from being processed further in\n * other listeners execute {@link Event#stopPropagation}.\n *\n * Returning anything but `undefined` from a listener will stop the listener propagation.\n *\n * @param {String|Array<String>} events\n * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher\n * @param {Function} callback\n * @param {Object} [that] Pass context (`this`) to the callback\n */\nEventBus.prototype.on = function(events, priority, callback, that) {\n\n  events = isArray(events) ? events : [ events ];\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  var actualCallback = callback;\n\n  if (that) {\n    actualCallback = bind(callback, that);\n\n    // make sure we remember and are able to remove\n    // bound callbacks via {@link #off} using the original\n    // callback\n    actualCallback[FN_REF] = callback[FN_REF] || callback;\n  }\n\n  var self = this;\n\n  events.forEach(function(e) {\n    self._addListener(e, {\n      priority: priority,\n      callback: actualCallback,\n      next: null\n    });\n  });\n};\n\n\n/**\n * Register an event listener that is executed only once.\n *\n * @param {String} event the event name to register for\n * @param {Function} callback the callback to execute\n * @param {Object} [that] Pass context (`this`) to the callback\n */\nEventBus.prototype.once = function(event, priority, callback, that) {\n  var self = this;\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  function wrappedCallback() {\n    var result = callback.apply(that, arguments);\n\n    self.off(event, wrappedCallback);\n\n    return result;\n  }\n\n  // make sure we remember and are able to remove\n  // bound callbacks via {@link #off} using the original\n  // callback\n  wrappedCallback[FN_REF] = callback;\n\n  this.on(event, priority, wrappedCallback);\n};\n\n\n/**\n * Removes event listeners by event and callback.\n *\n * If no callback is given, all listeners for a given event name are being removed.\n *\n * @param {String|Array<String>} events\n * @param {Function} [callback]\n */\nEventBus.prototype.off = function(events, callback) {\n\n  events = isArray(events) ? events : [ events ];\n\n  var self = this;\n\n  events.forEach(function(event) {\n    self._removeListener(event, callback);\n  });\n\n};\n\n\n/**\n * Create an EventBus event.\n *\n * @param {Object} data\n *\n * @return {Object} event, recognized by the eventBus\n */\nEventBus.prototype.createEvent = function(data) {\n  var event = new InternalEvent();\n\n  event.init(data);\n\n  return event;\n};\n\n\n/**\n * Fires a named event.\n *\n * @example\n *\n * // fire event by name\n * events.fire('foo');\n *\n * // fire event object with nested type\n * var event = { type: 'foo' };\n * events.fire(event);\n *\n * // fire event with explicit type\n * var event = { x: 10, y: 20 };\n * events.fire('element.moved', event);\n *\n * // pass additional arguments to the event\n * events.on('foo', function(event, bar) {\n *   alert(bar);\n * });\n *\n * events.fire({ type: 'foo' }, 'I am bar!');\n *\n * @param {String} [name] the optional event name\n * @param {Object} [event] the event object\n * @param {...Object} additional arguments to be passed to the callback functions\n *\n * @return {Boolean} the events return value, if specified or false if the\n *                   default action was prevented by listeners\n */\nEventBus.prototype.fire = function(type, data) {\n\n  var event,\n      firstListener,\n      returnValue,\n      args;\n\n  args = slice.call(arguments);\n\n  if (typeof type === 'object') {\n    event = type;\n    type = event.type;\n  }\n\n  if (!type) {\n    throw new Error('no event type specified');\n  }\n\n  firstListener = this._listeners[type];\n\n  if (!firstListener) {\n    return;\n  }\n\n  // we make sure we fire instances of our home made\n  // events here. We wrap them only once, though\n  if (data instanceof InternalEvent) {\n    // we are fine, we alread have an event\n    event = data;\n  } else {\n    event = this.createEvent(data);\n  }\n\n  // ensure we pass the event as the first parameter\n  args[0] = event;\n\n  // original event type (in case we delegate)\n  var originalType = event.type;\n\n  // update event type before delegation\n  if (type !== originalType) {\n    event.type = type;\n  }\n\n  try {\n    returnValue = this._invokeListeners(event, args, firstListener);\n  } finally {\n    // reset event type after delegation\n    if (type !== originalType) {\n      event.type = originalType;\n    }\n  }\n\n  // set the return value to false if the event default\n  // got prevented and no other return value exists\n  if (returnValue === undefined && event.defaultPrevented) {\n    returnValue = false;\n  }\n\n  return returnValue;\n};\n\n\nEventBus.prototype.handleError = function(error) {\n  return this.fire('error', { error: error }) === false;\n};\n\n\nEventBus.prototype._destroy = function() {\n  this._listeners = {};\n};\n\nEventBus.prototype._invokeListeners = function(event, args, listener) {\n\n  var returnValue;\n\n  while (listener) {\n\n    // handle stopped propagation\n    if (event.cancelBubble) {\n      break;\n    }\n\n    returnValue = this._invokeListener(event, args, listener);\n\n    listener = listener.next;\n  }\n\n  return returnValue;\n};\n\nEventBus.prototype._invokeListener = function(event, args, listener) {\n\n  var returnValue;\n\n  try {\n    // returning false prevents the default action\n    returnValue = invokeFunction(listener.callback, args);\n\n    // stop propagation on return value\n    if (returnValue !== undefined) {\n      event.returnValue = returnValue;\n      event.stopPropagation();\n    }\n\n    // prevent default on return false\n    if (returnValue === false) {\n      event.preventDefault();\n    }\n  } catch (e) {\n    if (!this.handleError(e)) {\n      console.error('unhandled error in event listener');\n      console.error(e.stack);\n\n      throw e;\n    }\n  }\n\n  return returnValue;\n};\n\n/*\n * Add new listener with a certain priority to the list\n * of listeners (for the given event).\n *\n * The semantics of listener registration / listener execution are\n * first register, first serve: New listeners will always be inserted\n * after existing listeners with the same priority.\n *\n * Example: Inserting two listeners with priority 1000 and 1300\n *\n *    * before: [ 1500, 1500, 1000, 1000 ]\n *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\n *\n * @param {String} event\n * @param {Object} listener { priority, callback }\n */\nEventBus.prototype._addListener = function(event, newListener) {\n\n  var listener = this._getListeners(event),\n      previousListener;\n\n  // no prior listeners\n  if (!listener) {\n    this._setListeners(event, newListener);\n\n    return;\n  }\n\n  // ensure we order listeners by priority from\n  // 0 (high) to n > 0 (low)\n  while (listener) {\n\n    if (listener.priority < newListener.priority) {\n\n      newListener.next = listener;\n\n      if (previousListener) {\n        previousListener.next = newListener;\n      } else {\n        this._setListeners(event, newListener);\n      }\n\n      return;\n    }\n\n    previousListener = listener;\n    listener = listener.next;\n  }\n\n  // add new listener to back\n  previousListener.next = newListener;\n};\n\n\nEventBus.prototype._getListeners = function(name) {\n  return this._listeners[name];\n};\n\nEventBus.prototype._setListeners = function(name, listener) {\n  this._listeners[name] = listener;\n};\n\nEventBus.prototype._removeListener = function(event, callback) {\n\n  var listener = this._getListeners(event),\n      nextListener,\n      previousListener,\n      listenerCallback;\n\n  if (!callback) {\n    // clear listeners\n    this._setListeners(event, null);\n\n    return;\n  }\n\n  while (listener) {\n\n    nextListener = listener.next;\n\n    listenerCallback = listener.callback;\n\n    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\n      if (previousListener) {\n        previousListener.next = nextListener;\n      } else {\n        // new first listener\n        this._setListeners(event, nextListener);\n      }\n    }\n\n    previousListener = listener;\n    listener = nextListener;\n  }\n};\n\n/**\n * A event that is emitted via the event bus.\n */\nfunction InternalEvent() { }\n\nInternalEvent.prototype.stopPropagation = function() {\n  this.cancelBubble = true;\n};\n\nInternalEvent.prototype.preventDefault = function() {\n  this.defaultPrevented = true;\n};\n\nInternalEvent.prototype.init = function(data) {\n  assign(this, data || {});\n};\n\n\n/**\n * Invoke function. Be fast...\n *\n * @param {Function} fn\n * @param {Array<Object>} args\n *\n * @return {Any}\n */\nfunction invokeFunction(fn, args) {\n  return fn.apply(null, args);\n}\n"]},"metadata":{},"sourceType":"module"}