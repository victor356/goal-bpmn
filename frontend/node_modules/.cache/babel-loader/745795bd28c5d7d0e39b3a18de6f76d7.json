{"ast":null,"code":"import { assign, forEach } from 'min-dash';\nimport inherits from 'inherits';\nimport { remove as collectionRemove, add as collectionAdd } from 'diagram-js/lib/util/Collections';\nimport { Label } from 'diagram-js/lib/model';\nimport { getBusinessObject, is } from '../../util/ModelUtil';\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\n\nexport default function BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate) {\n  CommandInterceptor.call(this, eventBus);\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n  var self = this; // connection cropping //////////////////////\n  // crop connection ends during create/update\n\n  function cropConnection(e) {\n    var context = e.context,\n        connection;\n\n    if (!context.cropped) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed(['connection.layout', 'connection.create'], cropConnection);\n  this.reverted(['connection.layout'], function (e) {\n    delete e.context.cropped;\n  }); // BPMN + DI update //////////////////////\n  // update parent\n\n  function updateParent(e) {\n    var context = e.context;\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n    var element = context.shape || context.connection,\n        // oldParent is the (old) new parent, because we are undoing\n    oldParent = context.parent || context.newParent;\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(updateParent));\n  this.reverted(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(reverseUpdateParent));\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n    forEach(children, function (child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed(['canvas.updateRoot'], updateRoot);\n  this.reverted(['canvas.updateRoot'], updateRoot); // update bounds\n\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n  this.reverted(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  })); // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n\n  eventBus.on('shape.changed', function (event) {\n    if (event.element.type === 'label') {\n      updateBounds({\n        context: {\n          shape: event.element\n        }\n      });\n    }\n  }); // attach / detach connection\n\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnectEnd', 'connection.reconnectStart'], ifBpmn(updateConnection));\n  this.reverted(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnectEnd', 'connection.reconnectStart'], ifBpmn(updateConnection)); // update waypoints\n\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));\n  this.reverted(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints)); // update Default & Conditional flows\n\n  this.executed(['connection.reconnectEnd', 'connection.reconnectStart'], ifBpmn(function (e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        oldSource = getBusinessObject(context.oldSource),\n        oldTarget = getBusinessObject(context.oldTarget),\n        newSource = getBusinessObject(connection.source),\n        newTarget = getBusinessObject(connection.target);\n\n    if (oldSource === newSource || oldTarget === newTarget) {\n      return;\n    } // on reconnectStart -> default flow\n\n\n    if (oldSource && oldSource.default === businessObject) {\n      context.default = oldSource.default;\n      oldSource.default = undefined;\n    } // on reconnectEnd -> default flow\n\n\n    if (businessObject.sourceRef && businessObject.sourceRef.default && !(is(newTarget, 'bpmn:Activity') || is(newTarget, 'bpmn:EndEvent') || is(newTarget, 'bpmn:Gateway') || is(newTarget, 'bpmn:IntermediateThrowEvent'))) {\n      context.default = businessObject.sourceRef.default;\n      businessObject.sourceRef.default = undefined;\n    } // on reconnectStart -> conditional flow\n\n\n    if (oldSource && businessObject.conditionExpression && !(is(newSource, 'bpmn:Activity') || is(newSource, 'bpmn:Gateway'))) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    } // on reconnectEnd -> conditional flow\n\n\n    if (oldTarget && businessObject.conditionExpression && !(is(newTarget, 'bpmn:Activity') || is(newTarget, 'bpmn:EndEvent') || is(newTarget, 'bpmn:Gateway') || is(newTarget, 'bpmn:IntermediateThrowEvent'))) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n  }));\n  this.reverted(['connection.reconnectEnd', 'connection.reconnectStart'], ifBpmn(function (e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        newSource = getBusinessObject(connection.source); // default flow\n\n    if (context.default) {\n      if (is(newSource, 'bpmn:ExclusiveGateway') || is(newSource, 'bpmn:InclusiveGateway') || is(newSource, 'bpmn:Activity')) {\n        newSource.default = context.default;\n      }\n    } // conditional flow\n\n\n    if (context.conditionExpression && is(newSource, 'bpmn:Activity')) {\n      businessObject.conditionExpression = context.conditionExpression;\n    }\n  })); // update attachments\n\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed(['element.updateAttachment'], ifBpmn(updateAttachment));\n  this.reverted(['element.updateAttachment'], ifBpmn(updateAttachment));\n}\ninherits(BpmnUpdater, CommandInterceptor);\nBpmnUpdater.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking', 'translate']; // implementation //////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function (context) {\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\nBpmnUpdater.prototype.updateParent = function (element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Label) {\n    return;\n  } // data stores in collaborations are handled seperately by DataStoreBehavior\n\n\n  if (is(element, 'bpmn:DataStoreReference') && element.parent && is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n\n  var parentShape = element.parent;\n  var businessObject = element.businessObject,\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = parentBusinessObject && parentBusinessObject.di;\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(businessObject.di, parentDi);\n};\n\nBpmnUpdater.prototype.updateBounds = function (shape) {\n  var di = shape.businessObject.di;\n  var target = shape instanceof Label ? this._getLabel(di) : di;\n  var bounds = target.bounds;\n\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\nBpmnUpdater.prototype.updateFlowNodeRefs = function (businessObject, newContainment, oldContainment) {\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is(oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n}; // update existing sourceElement and targetElement di information\n\n\nBpmnUpdater.prototype.updateDiConnection = function (di, newSource, newTarget) {\n  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {\n    di.sourceElement = newSource && newSource.di;\n  }\n\n  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {\n    di.targetElement = newTarget && newTarget.di;\n  }\n};\n\nBpmnUpdater.prototype.updateDiParent = function (di, parentDi) {\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\nBpmnUpdater.prototype.getLaneSet = function (container) {\n  var laneSet, laneSets; // bpmn:Lane\n\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  } // bpmn:Participant\n\n\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  } // bpmn:FlowElementsContainer\n\n\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\nBpmnUpdater.prototype.updateSemanticParent = function (businessObject, newParent, visualParent) {\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    } // already in correct ioSpecification\n\n\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else if (is(businessObject, 'bpmn:FlowElement')) {\n    if (newParent) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n      }\n    }\n\n    containment = 'flowElements';\n  } else if (is(businessObject, 'bpmn:Artifact')) {\n    while (newParent && !is(newParent, 'bpmn:Process') && !is(newParent, 'bpmn:SubProcess') && !is(newParent, 'bpmn:Collaboration')) {\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n  } else if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants'; // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate('no parent for {element} in {parent}', {\n      element: businessObject.id,\n      parent: newParent.id\n    }));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n    collectionRemove(children, businessObject);\n\n    if (newParent) {\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\nBpmnUpdater.prototype.updateConnectionWaypoints = function (connection) {\n  connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\nBpmnUpdater.prototype.updateConnection = function (context) {\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = getBusinessObject(connection.source),\n      newTarget = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSource) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSource && newSource.get('outgoing')) {\n          newSource.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSource;\n    }\n\n    if (businessObject.targetRef !== newTarget) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTarget && newTarget.get('incoming')) {\n          newTarget.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTarget;\n    }\n  } else if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSource;\n    visualParent = context.parent || context.newParent || newTarget;\n    this.updateSemanticParent(businessObject, newTarget, parent.businessObject);\n  } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSource;\n    this.updateSemanticParent(businessObject, newSource, visualParent); // targetRef = new target\n\n    businessObject.targetRef = newTarget;\n  }\n\n  this.updateConnectionWaypoints(connection);\n  this.updateDiConnection(businessObject.di, newSource, newTarget);\n}; // helpers //////////////////////\n\n\nBpmnUpdater.prototype._getLabel = function (di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\n\n\nfunction ifBpmn(fn) {\n  return function (event) {\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js"],"names":["assign","forEach","inherits","remove","collectionRemove","add","collectionAdd","Label","getBusinessObject","is","CommandInterceptor","BpmnUpdater","eventBus","bpmnFactory","connectionDocking","translate","call","_bpmnFactory","_translate","self","cropConnection","e","context","connection","cropped","waypoints","getCroppedWaypoints","executed","reverted","updateParent","shape","oldParent","reverseUpdateParent","element","parent","newParent","ifBpmn","updateRoot","event","oldRoot","children","child","updateBounds","type","on","updateConnection","updateConnectionWaypoints","businessObject","oldSource","oldTarget","newSource","source","newTarget","target","default","undefined","sourceRef","conditionExpression","updateAttachment","$inject","prototype","host","attachedToRef","parentShape","parentBusinessObject","parentDi","di","updateFlowNodeRefs","updateSemanticParent","dataObjectRef","updateDiParent","_getLabel","bounds","createDiBounds","set","x","y","width","height","newContainment","oldContainment","oldRefs","newRefs","get","updateDiConnection","sourceElement","bpmnElement","targetElement","$parent","planeElements","push","getDefinitions","getLaneSet","container","laneSet","laneSets","childLaneSet","create","processRef","visualParent","containment","ioSpecification","process","definitions","Error","id","diChildren","createDiWaypoints","inverseSet","targetRef","label","createDiLabel","fn"],"mappings":"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","sourcesContent":["import {\n  assign,\n  forEach\n} from 'min-dash';\n\nimport inherits from 'inherits';\n\nimport {\n  remove as collectionRemove,\n  add as collectionAdd\n} from 'diagram-js/lib/util/Collections';\n\nimport {\n  Label\n} from 'diagram-js/lib/model';\n\nimport {\n  getBusinessObject,\n  is\n} from '../../util/ModelUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\n/**\n * A handler responsible for updating the underlying BPMN 2.0 XML + DI\n * once changes on the diagram happen\n */\nexport default function BpmnUpdater(\n    eventBus, bpmnFactory, connectionDocking,\n    translate) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._bpmnFactory = bpmnFactory;\n  this._translate = translate;\n\n  var self = this;\n\n\n\n  // connection cropping //////////////////////\n\n  // crop connection ends during create/update\n  function cropConnection(e) {\n    var context = e.context,\n        connection;\n\n    if (!context.cropped) {\n      connection = context.connection;\n      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);\n      context.cropped = true;\n    }\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.create'\n  ], cropConnection);\n\n  this.reverted([ 'connection.layout' ], function(e) {\n    delete e.context.cropped;\n  });\n\n\n\n  // BPMN + DI update //////////////////////\n\n\n  // update parent\n  function updateParent(e) {\n    var context = e.context;\n\n    self.updateParent(context.shape || context.connection, context.oldParent);\n  }\n\n  function reverseUpdateParent(e) {\n    var context = e.context;\n\n    var element = context.shape || context.connection,\n        // oldParent is the (old) new parent, because we are undoing\n        oldParent = context.parent || context.newParent;\n\n    self.updateParent(element, oldParent);\n  }\n\n  this.executed([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(updateParent));\n\n  this.reverted([\n    'shape.move',\n    'shape.create',\n    'shape.delete',\n    'connection.create',\n    'connection.move',\n    'connection.delete'\n  ], ifBpmn(reverseUpdateParent));\n\n  /*\n   * ## Updating Parent\n   *\n   * When morphing a Process into a Collaboration or vice-versa,\n   * make sure that both the *semantic* and *di* parent of each element\n   * is updated.\n   *\n   */\n  function updateRoot(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        children = oldRoot.children;\n\n    forEach(children, function(child) {\n      if (is(child, 'bpmn:BaseElement')) {\n        self.updateParent(child);\n      }\n    });\n  }\n\n  this.executed([ 'canvas.updateRoot' ], updateRoot);\n  this.reverted([ 'canvas.updateRoot' ], updateRoot);\n\n\n  // update bounds\n  function updateBounds(e) {\n    var shape = e.context.shape;\n\n    if (!is(shape, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    self.updateBounds(shape);\n  }\n\n  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {\n\n    // exclude labels because they're handled separately during shape.changed\n    if (event.context.shape.type === 'label') {\n      return;\n    }\n\n    updateBounds(event);\n  }));\n\n  // Handle labels separately. This is necessary, because the label bounds have to be updated\n  // every time its shape changes, not only on move, create and resize.\n  eventBus.on('shape.changed', function(event) {\n    if (event.element.type === 'label') {\n      updateBounds({ context: { shape: event.element } });\n    }\n  });\n\n  // attach / detach connection\n  function updateConnection(e) {\n    self.updateConnection(e.context);\n  }\n\n  this.executed([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnection));\n\n  this.reverted([\n    'connection.create',\n    'connection.move',\n    'connection.delete',\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(updateConnection));\n\n\n  // update waypoints\n  function updateConnectionWaypoints(e) {\n    self.updateConnectionWaypoints(e.context.connection);\n  }\n\n  this.executed([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n  this.reverted([\n    'connection.layout',\n    'connection.move',\n    'connection.updateWaypoints',\n  ], ifBpmn(updateConnectionWaypoints));\n\n\n  // update Default & Conditional flows\n  this.executed([\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(function(e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        oldSource = getBusinessObject(context.oldSource),\n        oldTarget = getBusinessObject(context.oldTarget),\n        newSource = getBusinessObject(connection.source),\n        newTarget = getBusinessObject(connection.target);\n\n    if (oldSource === newSource || oldTarget === newTarget) {\n      return;\n    }\n\n    // on reconnectStart -> default flow\n    if (oldSource && oldSource.default === businessObject) {\n      context.default = oldSource.default;\n      oldSource.default = undefined;\n    }\n\n    // on reconnectEnd -> default flow\n    if ((businessObject.sourceRef && businessObject.sourceRef.default) &&\n        !(is(newTarget, 'bpmn:Activity') ||\n          is(newTarget, 'bpmn:EndEvent') ||\n          is(newTarget, 'bpmn:Gateway') ||\n          is(newTarget, 'bpmn:IntermediateThrowEvent'))) {\n      context.default = businessObject.sourceRef.default;\n      businessObject.sourceRef.default = undefined;\n    }\n\n    // on reconnectStart -> conditional flow\n    if (oldSource && (businessObject.conditionExpression) &&\n      !(is(newSource, 'bpmn:Activity') ||\n        is(newSource, 'bpmn:Gateway'))) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n\n    // on reconnectEnd -> conditional flow\n    if (oldTarget && (businessObject.conditionExpression) &&\n        !(is(newTarget, 'bpmn:Activity') ||\n          is(newTarget, 'bpmn:EndEvent') ||\n          is(newTarget, 'bpmn:Gateway') ||\n          is(newTarget, 'bpmn:IntermediateThrowEvent'))) {\n      context.conditionExpression = businessObject.conditionExpression;\n      businessObject.conditionExpression = undefined;\n    }\n  }));\n\n  this.reverted([\n    'connection.reconnectEnd',\n    'connection.reconnectStart'\n  ], ifBpmn(function(e) {\n    var context = e.context,\n        connection = context.connection,\n        businessObject = getBusinessObject(connection),\n        newSource = getBusinessObject(connection.source);\n\n    // default flow\n    if (context.default) {\n      if (is(newSource, 'bpmn:ExclusiveGateway') || is(newSource, 'bpmn:InclusiveGateway') ||\n          is(newSource, 'bpmn:Activity')) {\n        newSource.default = context.default;\n      }\n    }\n\n    // conditional flow\n    if (context.conditionExpression && is(newSource, 'bpmn:Activity')) {\n      businessObject.conditionExpression = context.conditionExpression;\n    }\n  }));\n\n  // update attachments\n  function updateAttachment(e) {\n    self.updateAttachment(e.context);\n  }\n\n  this.executed([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n  this.reverted([ 'element.updateAttachment' ], ifBpmn(updateAttachment));\n}\n\ninherits(BpmnUpdater, CommandInterceptor);\n\nBpmnUpdater.$inject = [\n  'eventBus',\n  'bpmnFactory',\n  'connectionDocking',\n  'translate'\n];\n\n\n// implementation //////////////////////\n\nBpmnUpdater.prototype.updateAttachment = function(context) {\n\n  var shape = context.shape,\n      businessObject = shape.businessObject,\n      host = shape.host;\n\n  businessObject.attachedToRef = host && host.businessObject;\n};\n\nBpmnUpdater.prototype.updateParent = function(element, oldParent) {\n  // do not update BPMN 2.0 label parent\n  if (element instanceof Label) {\n    return;\n  }\n\n  // data stores in collaborations are handled seperately by DataStoreBehavior\n  if (is(element, 'bpmn:DataStoreReference') &&\n      element.parent &&\n      is(element.parent, 'bpmn:Collaboration')) {\n    return;\n  }\n\n  var parentShape = element.parent;\n\n  var businessObject = element.businessObject,\n      parentBusinessObject = parentShape && parentShape.businessObject,\n      parentDi = parentBusinessObject && parentBusinessObject.di;\n\n  if (is(element, 'bpmn:FlowNode')) {\n    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);\n  }\n\n  if (is(element, 'bpmn:DataOutputAssociation')) {\n    if (element.source) {\n      parentBusinessObject = element.source.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  if (is(element, 'bpmn:DataInputAssociation')) {\n    if (element.target) {\n      parentBusinessObject = element.target.businessObject;\n    } else {\n      parentBusinessObject = null;\n    }\n  }\n\n  this.updateSemanticParent(businessObject, parentBusinessObject);\n\n  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {\n    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);\n  }\n\n  this.updateDiParent(businessObject.di, parentDi);\n};\n\n\nBpmnUpdater.prototype.updateBounds = function(shape) {\n\n  var di = shape.businessObject.di;\n\n  var target = (shape instanceof Label) ? this._getLabel(di) : di;\n\n  var bounds = target.bounds;\n\n  if (!bounds) {\n    bounds = this._bpmnFactory.createDiBounds();\n    target.set('bounds', bounds);\n  }\n\n  assign(bounds, {\n    x: shape.x,\n    y: shape.y,\n    width: shape.width,\n    height: shape.height\n  });\n};\n\nBpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {\n\n  if (oldContainment === newContainment) {\n    return;\n  }\n\n  var oldRefs, newRefs;\n\n  if (is (oldContainment, 'bpmn:Lane')) {\n    oldRefs = oldContainment.get('flowNodeRef');\n    collectionRemove(oldRefs, businessObject);\n  }\n\n  if (is(newContainment, 'bpmn:Lane')) {\n    newRefs = newContainment.get('flowNodeRef');\n    collectionAdd(newRefs, businessObject);\n  }\n};\n\n\n// update existing sourceElement and targetElement di information\nBpmnUpdater.prototype.updateDiConnection = function(di, newSource, newTarget) {\n\n  if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {\n    di.sourceElement = newSource && newSource.di;\n  }\n\n  if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {\n    di.targetElement = newTarget && newTarget.di;\n  }\n\n};\n\n\nBpmnUpdater.prototype.updateDiParent = function(di, parentDi) {\n\n  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {\n    parentDi = parentDi.$parent;\n  }\n\n  if (di.$parent === parentDi) {\n    return;\n  }\n\n  var planeElements = (parentDi || di.$parent).get('planeElement');\n\n  if (parentDi) {\n    planeElements.push(di);\n    di.$parent = parentDi;\n  } else {\n    collectionRemove(planeElements, di);\n    di.$parent = null;\n  }\n};\n\nfunction getDefinitions(element) {\n  while (element && !is(element, 'bpmn:Definitions')) {\n    element = element.$parent;\n  }\n\n  return element;\n}\n\nBpmnUpdater.prototype.getLaneSet = function(container) {\n\n  var laneSet, laneSets;\n\n  // bpmn:Lane\n  if (is(container, 'bpmn:Lane')) {\n    laneSet = container.childLaneSet;\n\n    if (!laneSet) {\n      laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n      container.childLaneSet = laneSet;\n      laneSet.$parent = container;\n    }\n\n    return laneSet;\n  }\n\n  // bpmn:Participant\n  if (is(container, 'bpmn:Participant')) {\n    container = container.processRef;\n  }\n\n  // bpmn:FlowElementsContainer\n  laneSets = container.get('laneSets');\n  laneSet = laneSets[0];\n\n  if (!laneSet) {\n    laneSet = this._bpmnFactory.create('bpmn:LaneSet');\n    laneSet.$parent = container;\n    laneSets.push(laneSet);\n  }\n\n  return laneSet;\n};\n\nBpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {\n\n  var containment,\n      translate = this._translate;\n\n  if (businessObject.$parent === newParent) {\n    return;\n  }\n\n  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {\n\n    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {\n      newParent = newParent.processRef;\n    }\n\n    // already in correct ioSpecification\n    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {\n      return;\n    }\n  }\n\n  if (is(businessObject, 'bpmn:Lane')) {\n\n    if (newParent) {\n      newParent = this.getLaneSet(newParent);\n    }\n\n    containment = 'lanes';\n  } else\n\n  if (is(businessObject, 'bpmn:FlowElement')) {\n\n    if (newParent) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n      } else\n\n      if (is(newParent, 'bpmn:Lane')) {\n        do {\n          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)\n          newParent = newParent.$parent.$parent;\n        } while (is(newParent, 'bpmn:Lane'));\n\n      }\n    }\n\n    containment = 'flowElements';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Artifact')) {\n\n    while (newParent &&\n           !is(newParent, 'bpmn:Process') &&\n           !is(newParent, 'bpmn:SubProcess') &&\n           !is(newParent, 'bpmn:Collaboration')) {\n\n      if (is(newParent, 'bpmn:Participant')) {\n        newParent = newParent.processRef;\n        break;\n      } else {\n        newParent = newParent.$parent;\n      }\n    }\n\n    containment = 'artifacts';\n  } else\n\n  if (is(businessObject, 'bpmn:MessageFlow')) {\n    containment = 'messageFlows';\n\n  } else\n\n  if (is(businessObject, 'bpmn:Participant')) {\n    containment = 'participants';\n\n    // make sure the participants process is properly attached / detached\n    // from the XML document\n\n    var process = businessObject.processRef,\n        definitions;\n\n    if (process) {\n      definitions = getDefinitions(businessObject.$parent || newParent);\n\n      if (businessObject.$parent) {\n        collectionRemove(definitions.get('rootElements'), process);\n        process.$parent = null;\n      }\n\n      if (newParent) {\n        collectionAdd(definitions.get('rootElements'), process);\n        process.$parent = definitions;\n      }\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    containment = 'dataOutputAssociations';\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    containment = 'dataInputAssociations';\n  }\n\n  if (!containment) {\n    throw new Error(translate(\n      'no parent for {element} in {parent}',\n      {\n        element: businessObject.id,\n        parent: newParent.id\n      }\n    ));\n  }\n\n  var children;\n\n  if (businessObject.$parent) {\n    // remove from old parent\n    children = businessObject.$parent.get(containment);\n    collectionRemove(children, businessObject);\n  }\n\n  if (!newParent) {\n    businessObject.$parent = null;\n  } else {\n    // add to new parent\n    children = newParent.get(containment);\n    children.push(businessObject);\n    businessObject.$parent = newParent;\n  }\n\n  if (visualParent) {\n    var diChildren = visualParent.get(containment);\n\n    collectionRemove(children, businessObject);\n\n    if (newParent) {\n\n      if (!diChildren) {\n        diChildren = [];\n        newParent.set(containment, diChildren);\n      }\n\n      diChildren.push(businessObject);\n    }\n  }\n};\n\n\nBpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {\n  connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));\n};\n\n\nBpmnUpdater.prototype.updateConnection = function(context) {\n\n  var connection = context.connection,\n      businessObject = getBusinessObject(connection),\n      newSource = getBusinessObject(connection.source),\n      newTarget = getBusinessObject(connection.target),\n      visualParent;\n\n  if (!is(businessObject, 'bpmn:DataAssociation')) {\n\n    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');\n\n    if (businessObject.sourceRef !== newSource) {\n      if (inverseSet) {\n        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);\n\n        if (newSource && newSource.get('outgoing')) {\n          newSource.get('outgoing').push(businessObject);\n        }\n      }\n\n      businessObject.sourceRef = newSource;\n    }\n\n    if (businessObject.targetRef !== newTarget) {\n      if (inverseSet) {\n        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);\n\n        if (newTarget && newTarget.get('incoming')) {\n          newTarget.get('incoming').push(businessObject);\n        }\n      }\n\n      businessObject.targetRef = newTarget;\n    }\n  } else\n\n  if (is(businessObject, 'bpmn:DataInputAssociation')) {\n    // handle obnoxious isMsome sourceRef\n    businessObject.get('sourceRef')[0] = newSource;\n\n    visualParent = context.parent || context.newParent || newTarget;\n\n    this.updateSemanticParent(businessObject, newTarget, parent.businessObject);\n  } else\n\n  if (is(businessObject, 'bpmn:DataOutputAssociation')) {\n    visualParent = context.parent || context.newParent || newSource;\n\n    this.updateSemanticParent(businessObject, newSource, visualParent);\n\n    // targetRef = new target\n    businessObject.targetRef = newTarget;\n  }\n\n  this.updateConnectionWaypoints(connection);\n\n  this.updateDiConnection(businessObject.di, newSource, newTarget);\n};\n\n\n// helpers //////////////////////\n\nBpmnUpdater.prototype._getLabel = function(di) {\n  if (!di.label) {\n    di.label = this._bpmnFactory.createDiLabel();\n  }\n\n  return di.label;\n};\n\n\n/**\n * Make sure the event listener is only called\n * if the touched element is a BPMN element.\n *\n * @param  {Function} fn\n * @return {Function} guarded function\n */\nfunction ifBpmn(fn) {\n\n  return function(event) {\n\n    var context = event.context,\n        element = context.shape || context.connection;\n\n    if (is(element, 'bpmn:BaseElement')) {\n      fn(event);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}