{"ast":null,"code":"import { forEach, map, sortBy, assign } from 'min-dash';\n\nfunction removeProperties(element, properties) {\n  forEach(properties, function (prop) {\n    if (element[prop]) {\n      delete element[prop];\n    }\n  });\n}\n/**\n * A handler that implements pasting of elements onto the diagram.\n *\n * @param {eventBus} EventBus\n * @param {canvas} Canvas\n * @param {selection} Selection\n * @param {elementFactory} ElementFactory\n * @param {modeling} Modeling\n * @param {rules} Rules\n */\n\n\nexport default function PasteHandler(eventBus, canvas, selection, elementFactory, modeling, rules) {\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._selection = selection;\n  this._elementFactory = elementFactory;\n  this._modeling = modeling;\n  this._rules = rules;\n}\nPasteHandler.$inject = ['eventBus', 'canvas', 'selection', 'elementFactory', 'modeling', 'rules']; // api //////////////////////\n\n/**\n * Creates a new shape\n *\n * @param {Object} context\n * @param {Object} context.tree the new shape\n * @param {Element} context.topParent the paste target\n */\n\nPasteHandler.prototype.preExecute = function (context) {\n  var eventBus = this._eventBus,\n      self = this;\n  var tree = context.tree,\n      topParent = context.topParent,\n      position = context.position;\n  tree.createdElements = {};\n  tree.labels = [];\n  forEach(tree, function (elements, depthStr) {\n    var depth = parseInt(depthStr, 10);\n\n    if (isNaN(depth)) {\n      return;\n    } // set the parent on the top level elements\n\n\n    if (!depth) {\n      elements = map(elements, function (descriptor) {\n        descriptor.parent = topParent;\n        return descriptor;\n      });\n    } // Order by priority for element creation\n\n\n    elements = sortBy(elements, 'priority');\n    forEach(elements, function (descriptor) {\n      var id = descriptor.id,\n          parent = descriptor.parent,\n          hints = {},\n          newPosition;\n      var element = assign({}, descriptor);\n\n      if (depth) {\n        element.parent = self._getCreatedElement(parent, tree);\n      } // this happens when shapes have not been created due to rules\n\n\n      if (!parent) {\n        return;\n      }\n\n      eventBus.fire('element.paste', {\n        createdElements: tree.createdElements,\n        descriptor: element\n      }); // in case the parent changed during 'element.paste'\n\n      parent = element.parent;\n\n      if (element.waypoints) {\n        element = self._createConnection(element, parent, position, tree);\n\n        if (element) {\n          tree.createdElements[id] = {\n            element: element,\n            descriptor: descriptor\n          };\n        }\n\n        return;\n      } // supply not-root information as hint\n\n\n      if (element.parent !== topParent) {\n        hints.root = false;\n      } // set host\n\n\n      if (element.host) {\n        hints.attach = true;\n        parent = self._getCreatedElement(element.host, tree);\n      } // handle labels\n\n\n      if (element.labelTarget) {\n        return tree.labels.push(element);\n      }\n\n      newPosition = {\n        x: Math.round(position.x + element.delta.x + element.width / 2),\n        y: Math.round(position.y + element.delta.y + element.height / 2)\n      };\n      removeProperties(element, ['id', 'parent', 'delta', 'host', 'priority']);\n      element = self._createShape(element, parent, newPosition, hints);\n\n      if (element) {\n        tree.createdElements[id] = {\n          element: element,\n          descriptor: descriptor\n        };\n      }\n    });\n  });\n}; // move label's to their relative position\n\n\nPasteHandler.prototype.postExecute = function (context) {\n  var modeling = this._modeling,\n      selection = this._selection,\n      self = this;\n  var tree = context.tree,\n      labels = tree.labels,\n      topLevelElements = [];\n  forEach(labels, function (labelDescriptor) {\n    var labelTarget = self._getCreatedElement(labelDescriptor.labelTarget, tree),\n        labels,\n        labelTargetPos,\n        newPosition;\n\n    if (!labelTarget) {\n      return;\n    }\n\n    labels = labelTarget.labels;\n\n    if (!labels || !labels.length) {\n      return;\n    }\n\n    labelTargetPos = {\n      x: labelTarget.x,\n      y: labelTarget.y\n    };\n\n    if (labelTarget.waypoints) {\n      labelTargetPos = labelTarget.waypoints[0];\n    }\n\n    forEach(labels, function (label) {\n      newPosition = {\n        x: Math.round(labelTargetPos.x - label.x + labelDescriptor.delta.x),\n        y: Math.round(labelTargetPos.y - label.y + labelDescriptor.delta.y)\n      };\n      modeling.moveShape(label, newPosition, labelTarget.parent);\n    });\n  });\n  forEach(tree[0], function (descriptor) {\n    var id = descriptor.id,\n        toplevel = tree.createdElements[id];\n\n    if (toplevel) {\n      topLevelElements.push(toplevel.element);\n    }\n  });\n  selection.select(topLevelElements);\n};\n\nPasteHandler.prototype._createConnection = function (element, parent, parentCenter, tree) {\n  var modeling = this._modeling,\n      rules = this._rules;\n  var connection, source, target, canPaste;\n  element.waypoints = map(element.waypoints, function (waypoint, idx) {\n    return {\n      x: Math.round(parentCenter.x + element.delta[idx].x),\n      y: Math.round(parentCenter.y + element.delta[idx].y)\n    };\n  });\n  source = this._getCreatedElement(element.source, tree);\n  target = this._getCreatedElement(element.target, tree);\n\n  if (!source || !target) {\n    return null;\n  }\n\n  canPaste = rules.allowed('element.paste', {\n    source: source,\n    target: target\n  });\n\n  if (!canPaste) {\n    return null;\n  }\n\n  removeProperties(element, ['id', 'parent', 'delta', 'source', 'target', 'width', 'height', 'priority']);\n  connection = modeling.createConnection(source, target, element, parent);\n  return connection;\n};\n\nPasteHandler.prototype._createShape = function (element, parent, position, isAttach, hints) {\n  var modeling = this._modeling,\n      elementFactory = this._elementFactory,\n      rules = this._rules;\n  var canPaste = rules.allowed('element.paste', {\n    element: element,\n    position: position,\n    parent: parent\n  });\n\n  if (!canPaste) {\n    return null;\n  }\n\n  var shape = elementFactory.createShape(element);\n  modeling.createShape(shape, position, parent, isAttach, hints);\n  return shape;\n};\n\nPasteHandler.prototype._getCreatedElement = function (id, tree) {\n  return tree.createdElements[id] && tree.createdElements[id].element;\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/node_modules/diagram-js/lib/features/modeling/cmd/PasteHandler.js"],"names":["forEach","map","sortBy","assign","removeProperties","element","properties","prop","PasteHandler","eventBus","canvas","selection","elementFactory","modeling","rules","_eventBus","_canvas","_selection","_elementFactory","_modeling","_rules","$inject","prototype","preExecute","context","self","tree","topParent","position","createdElements","labels","elements","depthStr","depth","parseInt","isNaN","descriptor","parent","id","hints","newPosition","_getCreatedElement","fire","waypoints","_createConnection","root","host","attach","labelTarget","push","x","Math","round","delta","width","y","height","_createShape","postExecute","topLevelElements","labelDescriptor","labelTargetPos","length","label","moveShape","toplevel","select","parentCenter","connection","source","target","canPaste","waypoint","idx","allowed","createConnection","isAttach","shape","createShape"],"mappings":"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","sourcesContent":["import {\n  forEach,\n  map,\n  sortBy,\n  assign,\n} from 'min-dash';\n\nfunction removeProperties(element, properties) {\n  forEach(properties, function(prop) {\n    if (element[prop]) {\n      delete element[prop];\n    }\n  });\n}\n\n/**\n * A handler that implements pasting of elements onto the diagram.\n *\n * @param {eventBus} EventBus\n * @param {canvas} Canvas\n * @param {selection} Selection\n * @param {elementFactory} ElementFactory\n * @param {modeling} Modeling\n * @param {rules} Rules\n */\nexport default function PasteHandler(\n    eventBus, canvas, selection,\n    elementFactory, modeling, rules) {\n\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._selection = selection;\n  this._elementFactory = elementFactory;\n  this._modeling = modeling;\n  this._rules = rules;\n}\n\n\nPasteHandler.$inject = [\n  'eventBus',\n  'canvas',\n  'selection',\n  'elementFactory',\n  'modeling',\n  'rules'\n];\n\n\n// api //////////////////////\n\n/**\n * Creates a new shape\n *\n * @param {Object} context\n * @param {Object} context.tree the new shape\n * @param {Element} context.topParent the paste target\n */\nPasteHandler.prototype.preExecute = function(context) {\n  var eventBus = this._eventBus,\n      self = this;\n\n  var tree = context.tree,\n      topParent = context.topParent,\n      position = context.position;\n\n  tree.createdElements = {};\n\n  tree.labels = [];\n\n  forEach(tree, function(elements, depthStr) {\n    var depth = parseInt(depthStr, 10);\n\n    if (isNaN(depth)) {\n      return;\n    }\n\n    // set the parent on the top level elements\n    if (!depth) {\n      elements = map(elements, function(descriptor) {\n        descriptor.parent = topParent;\n\n        return descriptor;\n      });\n    }\n\n    // Order by priority for element creation\n    elements = sortBy(elements, 'priority');\n\n    forEach(elements, function(descriptor) {\n      var id = descriptor.id,\n          parent = descriptor.parent,\n          hints = {},\n          newPosition;\n\n      var element = assign({}, descriptor);\n\n      if (depth) {\n        element.parent = self._getCreatedElement(parent, tree);\n      }\n\n      // this happens when shapes have not been created due to rules\n      if (!parent) {\n        return;\n      }\n\n      eventBus.fire('element.paste', {\n        createdElements: tree.createdElements,\n        descriptor: element\n      });\n\n      // in case the parent changed during 'element.paste'\n      parent = element.parent;\n\n      if (element.waypoints) {\n        element = self._createConnection(element, parent, position, tree);\n\n        if (element) {\n          tree.createdElements[id] = {\n            element: element,\n            descriptor: descriptor\n          };\n        }\n\n        return;\n      }\n\n\n      // supply not-root information as hint\n      if (element.parent !== topParent) {\n        hints.root = false;\n      }\n\n      // set host\n      if (element.host) {\n        hints.attach = true;\n\n        parent = self._getCreatedElement(element.host, tree);\n      }\n\n      // handle labels\n      if (element.labelTarget) {\n        return tree.labels.push(element);\n      }\n\n      newPosition = {\n        x: Math.round(position.x + element.delta.x + (element.width / 2)),\n        y: Math.round(position.y + element.delta.y + (element.height / 2))\n      };\n\n      removeProperties(element, [\n        'id',\n        'parent',\n        'delta',\n        'host',\n        'priority'\n      ]);\n\n      element = self._createShape(element, parent, newPosition, hints);\n\n      if (element) {\n        tree.createdElements[id] = {\n          element: element,\n          descriptor: descriptor\n        };\n      }\n    });\n  });\n};\n\n// move label's to their relative position\nPasteHandler.prototype.postExecute = function(context) {\n  var modeling = this._modeling,\n      selection = this._selection,\n      self = this;\n\n  var tree = context.tree,\n      labels = tree.labels,\n      topLevelElements = [];\n\n  forEach(labels, function(labelDescriptor) {\n    var labelTarget = self._getCreatedElement(labelDescriptor.labelTarget, tree),\n        labels, labelTargetPos, newPosition;\n\n    if (!labelTarget) {\n      return;\n    }\n\n    labels = labelTarget.labels;\n\n    if (!labels || !labels.length) {\n      return;\n    }\n\n    labelTargetPos = {\n      x: labelTarget.x,\n      y: labelTarget.y\n    };\n\n    if (labelTarget.waypoints) {\n      labelTargetPos = labelTarget.waypoints[0];\n    }\n\n    forEach(labels, function(label) {\n      newPosition = {\n        x: Math.round((labelTargetPos.x - label.x) + labelDescriptor.delta.x),\n        y: Math.round((labelTargetPos.y - label.y) + labelDescriptor.delta.y)\n      };\n\n      modeling.moveShape(label, newPosition, labelTarget.parent);\n    });\n  });\n\n  forEach(tree[0], function(descriptor) {\n    var id = descriptor.id,\n        toplevel = tree.createdElements[id];\n\n    if (toplevel) {\n      topLevelElements.push(toplevel.element);\n    }\n  });\n\n  selection.select(topLevelElements);\n};\n\n\nPasteHandler.prototype._createConnection = function(element, parent, parentCenter, tree) {\n  var modeling = this._modeling,\n      rules = this._rules;\n\n  var connection, source, target, canPaste;\n\n  element.waypoints = map(element.waypoints, function(waypoint, idx) {\n    return {\n      x: Math.round(parentCenter.x + element.delta[idx].x),\n      y: Math.round(parentCenter.y + element.delta[idx].y)\n    };\n  });\n\n  source = this._getCreatedElement(element.source, tree);\n  target = this._getCreatedElement(element.target, tree);\n\n  if (!source || !target) {\n    return null;\n  }\n\n  canPaste = rules.allowed('element.paste', {\n    source: source,\n    target: target\n  });\n\n  if (!canPaste) {\n    return null;\n  }\n\n  removeProperties(element, [\n    'id',\n    'parent',\n    'delta',\n    'source',\n    'target',\n    'width',\n    'height',\n    'priority'\n  ]);\n\n  connection = modeling.createConnection(source, target, element, parent);\n\n  return connection;\n};\n\n\nPasteHandler.prototype._createShape = function(element, parent, position, isAttach, hints) {\n  var modeling = this._modeling,\n      elementFactory = this._elementFactory,\n      rules = this._rules;\n\n  var canPaste = rules.allowed('element.paste', {\n    element: element,\n    position: position,\n    parent: parent\n  });\n\n  if (!canPaste) {\n    return null;\n  }\n\n  var shape = elementFactory.createShape(element);\n\n  modeling.createShape(shape, position, parent, isAttach, hints);\n\n  return shape;\n};\n\n\nPasteHandler.prototype._getCreatedElement = function(id, tree) {\n  return tree.createdElements[id] && tree.createdElements[id].element;\n};\n"]},"metadata":{},"sourceType":"module"}