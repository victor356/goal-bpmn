{"ast":null,"code":"/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nexport default function Properties(model) {\n  this.model = model;\n}\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\n\nProperties.prototype.set = function (target, name, value) {\n  var property = this.model.getPropertyDescriptor(target, name);\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[name];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[name] = value;\n    }\n  }\n};\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\n\n\nProperties.prototype.get = function (target, name) {\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  if (!property) {\n    return target.$attrs[name];\n  }\n\n  var propertyName = property.name; // check if access to collection property and lazily initialize it\n\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\n\n\nProperties.prototype.define = function (target, name, options) {\n  Object.defineProperty(target, name, options);\n};\n/**\n * Define the descriptor for an element\n */\n\n\nProperties.prototype.defineDescriptor = function (target, descriptor) {\n  this.define(target, '$descriptor', {\n    value: descriptor\n  });\n};\n/**\n * Define the model for an element\n */\n\n\nProperties.prototype.defineModel = function (target, model) {\n  this.define(target, '$model', {\n    value: model\n  });\n};\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/moddle/lib/properties.js"],"names":["Properties","model","prototype","set","target","name","value","property","getPropertyDescriptor","propertyName","isUndefined","$attrs","defineProperty","get","isMany","define","options","Object","defineDescriptor","descriptor","defineModel","val","enumerable","isReference","writable","configurable"],"mappings":"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","sourcesContent":["/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nexport default function Properties(model) {\n  this.model = model;\n}\n\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function(target, name, value) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[name];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[name] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function(target, name) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  if (!property) {\n    return target.$attrs[name];\n  }\n\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function(target, name, options) {\n  Object.defineProperty(target, name, options);\n};\n\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function(target, descriptor) {\n  this.define(target, '$descriptor', { value: descriptor });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function(target, model) {\n  this.define(target, '$model', { value: model });\n};\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}"]},"metadata":{},"sourceType":"module"}