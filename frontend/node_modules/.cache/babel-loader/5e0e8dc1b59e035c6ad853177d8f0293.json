{"ast":null,"code":"import { getChildLanes, LANE_INDENTATION } from '../util/LaneUtil';\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if neccessary.\n *\n * @param {Modeling} modeling\n */\n\nexport default function SplitLaneHandler(modeling, translate) {\n  this._modeling = modeling;\n  this._translate = translate;\n}\nSplitLaneHandler.$inject = ['modeling', 'translate'];\n\nSplitLaneHandler.prototype.preExecute = function (context) {\n  var modeling = this._modeling,\n      translate = this._translate;\n  var shape = context.shape,\n      newLanesCount = context.count;\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(translate('more than {count} child lanes', {\n      count: newLanesCount\n    }));\n  }\n\n  var newLanesHeight = Math.round(shape.height / newLanesCount); // Iterate from top to bottom in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the bottom lane\n  // needs to take up all the remaining space.\n\n  var laneY, laneHeight, laneBounds, newLaneAttrs, idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n    laneY = shape.y + idx * newLanesHeight; // if bottom lane\n\n    if (idx === newLanesCount - 1) {\n      laneHeight = shape.height - newLanesHeight * idx;\n    } else {\n      laneHeight = newLanesHeight;\n    }\n\n    laneBounds = {\n      x: shape.x + LANE_INDENTATION,\n      y: laneY,\n      width: shape.width - LANE_INDENTATION,\n      height: laneHeight\n    };\n\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane'\n      };\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js"],"names":["getChildLanes","LANE_INDENTATION","SplitLaneHandler","modeling","translate","_modeling","_translate","$inject","prototype","preExecute","context","shape","newLanesCount","count","childLanes","existingLanesCount","length","Error","newLanesHeight","Math","round","height","laneY","laneHeight","laneBounds","newLaneAttrs","idx","y","x","width","resizeShape","type","createShape"],"mappings":"AAAA,SACEA,aADF,EAEEC,gBAFF,QAGO,kBAHP;AAMA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,gBAAT,CAA0BC,QAA1B,EAAoCC,SAApC,EAA+C;AAC5D,OAAKC,SAAL,GAAiBF,QAAjB;AACA,OAAKG,UAAL,GAAkBF,SAAlB;AACD;AAEDF,gBAAgB,CAACK,OAAjB,GAA2B,CACzB,UADyB,EAEzB,WAFyB,CAA3B;;AAMAL,gBAAgB,CAACM,SAAjB,CAA2BC,UAA3B,GAAwC,UAASC,OAAT,EAAkB;AAExD,MAAIP,QAAQ,GAAG,KAAKE,SAApB;AAAA,MACID,SAAS,GAAG,KAAKE,UADrB;AAGA,MAAIK,KAAK,GAAGD,OAAO,CAACC,KAApB;AAAA,MACIC,aAAa,GAAGF,OAAO,CAACG,KAD5B;AAGA,MAAIC,UAAU,GAAGd,aAAa,CAACW,KAAD,CAA9B;AAAA,MACII,kBAAkB,GAAGD,UAAU,CAACE,MADpC;;AAGA,MAAID,kBAAkB,GAAGH,aAAzB,EAAwC;AACtC,UAAM,IAAIK,KAAJ,CAAUb,SAAS,CAAC,+BAAD,EAAkC;AAAES,MAAAA,KAAK,EAAED;AAAT,KAAlC,CAAnB,CAAN;AACD;;AAED,MAAIM,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWT,KAAK,CAACU,MAAN,GAAeT,aAA1B,CAArB,CAfwD,CAiBxD;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIU,KAAJ,EACIC,UADJ,EAEIC,UAFJ,EAGIC,YAHJ,EAIIC,GAJJ;;AAMA,OAAKA,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGd,aAApB,EAAmCc,GAAG,EAAtC,EAA0C;AAExCJ,IAAAA,KAAK,GAAGX,KAAK,CAACgB,CAAN,GAAUD,GAAG,GAAGR,cAAxB,CAFwC,CAIxC;;AACA,QAAIQ,GAAG,KAAKd,aAAa,GAAG,CAA5B,EAA+B;AAC7BW,MAAAA,UAAU,GAAGZ,KAAK,CAACU,MAAN,GAAgBH,cAAc,GAAGQ,GAA9C;AACD,KAFD,MAEO;AACLH,MAAAA,UAAU,GAAGL,cAAb;AACD;;AAEDM,IAAAA,UAAU,GAAG;AACXI,MAAAA,CAAC,EAAEjB,KAAK,CAACiB,CAAN,GAAU3B,gBADF;AAEX0B,MAAAA,CAAC,EAAEL,KAFQ;AAGXO,MAAAA,KAAK,EAAElB,KAAK,CAACkB,KAAN,GAAc5B,gBAHV;AAIXoB,MAAAA,MAAM,EAAEE;AAJG,KAAb;;AAOA,QAAIG,GAAG,GAAGX,kBAAV,EAA8B;AAC5B;AACAZ,MAAAA,QAAQ,CAAC2B,WAAT,CAAqBhB,UAAU,CAACY,GAAD,CAA/B,EAAsCF,UAAtC;AACD,KAHD,MAGO;AACL;AACAC,MAAAA,YAAY,GAAG;AACbM,QAAAA,IAAI,EAAE;AADO,OAAf;AAIA5B,MAAAA,QAAQ,CAAC6B,WAAT,CAAqBP,YAArB,EAAmCD,UAAnC,EAA+Cb,KAA/C;AACD;AACF;AACF,CA3DD","sourcesContent":["import {\n  getChildLanes,\n  LANE_INDENTATION\n} from '../util/LaneUtil';\n\n\n/**\n * A handler that splits a lane into a number of sub-lanes,\n * creating new sub lanes, if neccessary.\n *\n * @param {Modeling} modeling\n */\nexport default function SplitLaneHandler(modeling, translate) {\n  this._modeling = modeling;\n  this._translate = translate;\n}\n\nSplitLaneHandler.$inject = [\n  'modeling',\n  'translate'\n];\n\n\nSplitLaneHandler.prototype.preExecute = function(context) {\n\n  var modeling = this._modeling,\n      translate = this._translate;\n\n  var shape = context.shape,\n      newLanesCount = context.count;\n\n  var childLanes = getChildLanes(shape),\n      existingLanesCount = childLanes.length;\n\n  if (existingLanesCount > newLanesCount) {\n    throw new Error(translate('more than {count} child lanes', { count: newLanesCount }));\n  }\n\n  var newLanesHeight = Math.round(shape.height / newLanesCount);\n\n  // Iterate from top to bottom in child lane order,\n  // resizing existing lanes and creating new ones\n  // so that they split the parent proportionally.\n  //\n  // Due to rounding related errors, the bottom lane\n  // needs to take up all the remaining space.\n  var laneY,\n      laneHeight,\n      laneBounds,\n      newLaneAttrs,\n      idx;\n\n  for (idx = 0; idx < newLanesCount; idx++) {\n\n    laneY = shape.y + idx * newLanesHeight;\n\n    // if bottom lane\n    if (idx === newLanesCount - 1) {\n      laneHeight = shape.height - (newLanesHeight * idx);\n    } else {\n      laneHeight = newLanesHeight;\n    }\n\n    laneBounds = {\n      x: shape.x + LANE_INDENTATION,\n      y: laneY,\n      width: shape.width - LANE_INDENTATION,\n      height: laneHeight\n    };\n\n    if (idx < existingLanesCount) {\n      // resize existing lane\n      modeling.resizeShape(childLanes[idx], laneBounds);\n    } else {\n      // create a new lane at position\n      newLaneAttrs = {\n        type: 'bpmn:Lane'\n      };\n\n      modeling.createShape(newLaneAttrs, laneBounds, shape);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}