{"ast":null,"code":"import inherits from 'inherits';\nimport OrderingProvider from 'diagram-js/lib/features/ordering/OrderingProvider';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { findIndex, find } from 'min-dash';\n/**\n * a simple ordering provider that makes sure:\n *\n * (0) labels are rendered always on top\n * (1) elements are ordered by a {level} property\n */\n\nexport default function BpmnOrderingProvider(eventBus, canvas, translate) {\n  OrderingProvider.call(this, eventBus);\n  var orders = [{\n    type: 'bpmn:SubProcess',\n    order: {\n      level: 6\n    }\n  }, {\n    type: 'bpmn:SequenceFlow',\n    order: {\n      level: 3,\n      containers: ['bpmn:Participant', 'bpmn:FlowElementsContainer']\n    }\n  }, // handle DataAssociation(s) like message flows and render them always on top\n  {\n    type: 'bpmn:DataAssociation',\n    order: {\n      level: 9,\n      containers: ['bpmn:Collaboration', 'bpmn:Process']\n    }\n  }, {\n    type: 'bpmn:MessageFlow',\n    order: {\n      level: 9,\n      containers: ['bpmn:Collaboration']\n    }\n  }, {\n    type: 'bpmn:Association',\n    order: {\n      level: 6,\n      containers: ['bpmn:Participant', 'bpmn:FlowElementsContainer', 'bpmn:Collaboration']\n    }\n  }, {\n    type: 'bpmn:BoundaryEvent',\n    order: {\n      level: 8\n    }\n  }, {\n    type: 'bpmn:FlowElement',\n    order: {\n      level: 5\n    }\n  }, {\n    type: 'bpmn:Participant',\n    order: {\n      level: -2\n    }\n  }, {\n    type: 'bpmn:Lane',\n    order: {\n      level: -1\n    }\n  }];\n\n  function computeOrder(element) {\n    if (element.labelTarget) {\n      return {\n        level: 10\n      };\n    }\n\n    var entry = find(orders, function (o) {\n      return isAny(element, [o.type]);\n    });\n    return entry && entry.order || {\n      level: 1\n    };\n  }\n\n  function getOrder(element) {\n    var order = element.order;\n\n    if (!order) {\n      element.order = order = computeOrder(element);\n    }\n\n    return order;\n  }\n\n  function findActualParent(element, newParent, containers) {\n    var actualParent = newParent;\n\n    while (actualParent) {\n      if (isAny(actualParent, containers)) {\n        break;\n      }\n\n      actualParent = actualParent.parent;\n    }\n\n    if (!actualParent) {\n      throw new Error(translate('no parent for {element} in {parent}', {\n        element: element.id,\n        parent: newParent.id\n      }));\n    }\n\n    return actualParent;\n  }\n\n  this.getOrdering = function (element, newParent) {\n    // render labels always on top\n    if (element.labelTarget) {\n      return {\n        parent: canvas.getRootElement(),\n        index: -1\n      };\n    }\n\n    var elementOrder = getOrder(element);\n\n    if (elementOrder.containers) {\n      newParent = findActualParent(element, newParent, elementOrder.containers);\n    }\n\n    var currentIndex = newParent.children.indexOf(element);\n    var insertIndex = findIndex(newParent.children, function (child) {\n      // do not compare with labels, they are created\n      // in the wrong order (right after elements) during import and\n      // mess up the positioning.\n      if (!element.labelTarget && child.labelTarget) {\n        return false;\n      }\n\n      return elementOrder.level < getOrder(child).level;\n    }); // if the element is already in the child list at\n    // a smaller index, we need to adjust the inser index.\n    // this takes into account that the element is being removed\n    // before being re-inserted\n\n    if (insertIndex !== -1) {\n      if (currentIndex !== -1 && currentIndex < insertIndex) {\n        insertIndex -= 1;\n      }\n    }\n\n    return {\n      index: insertIndex,\n      parent: newParent\n    };\n  };\n}\nBpmnOrderingProvider.$inject = ['eventBus', 'canvas', 'translate'];\ninherits(BpmnOrderingProvider, OrderingProvider);","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/ordering/BpmnOrderingProvider.js"],"names":["inherits","OrderingProvider","isAny","findIndex","find","BpmnOrderingProvider","eventBus","canvas","translate","call","orders","type","order","level","containers","computeOrder","element","labelTarget","entry","o","getOrder","findActualParent","newParent","actualParent","parent","Error","id","getOrdering","getRootElement","index","elementOrder","currentIndex","children","indexOf","insertIndex","child","$inject"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport OrderingProvider from 'diagram-js/lib/features/ordering/OrderingProvider';\n\nimport {\n  isAny\n} from '../modeling/util/ModelingUtil';\n\nimport {\n  findIndex,\n  find\n} from 'min-dash';\n\n\n/**\n * a simple ordering provider that makes sure:\n *\n * (0) labels are rendered always on top\n * (1) elements are ordered by a {level} property\n */\nexport default function BpmnOrderingProvider(eventBus, canvas, translate) {\n\n  OrderingProvider.call(this, eventBus);\n\n  var orders = [\n    { type: 'bpmn:SubProcess', order: { level: 6 } },\n    {\n      type: 'bpmn:SequenceFlow',\n      order: {\n        level: 3,\n        containers: [\n          'bpmn:Participant',\n          'bpmn:FlowElementsContainer'\n        ]\n      }\n    },\n    // handle DataAssociation(s) like message flows and render them always on top\n    {\n      type: 'bpmn:DataAssociation',\n      order: {\n        level: 9,\n        containers: [\n          'bpmn:Collaboration',\n          'bpmn:Process'\n        ]\n      }\n    },\n    {\n      type: 'bpmn:MessageFlow', order: {\n        level: 9,\n        containers: [ 'bpmn:Collaboration' ]\n      }\n    },\n    {\n      type: 'bpmn:Association',\n      order: {\n        level: 6,\n        containers: [\n          'bpmn:Participant',\n          'bpmn:FlowElementsContainer',\n          'bpmn:Collaboration'\n        ]\n      }\n    },\n    { type: 'bpmn:BoundaryEvent', order: { level: 8 } },\n    { type: 'bpmn:FlowElement', order: { level: 5 } },\n    { type: 'bpmn:Participant', order: { level: -2 } },\n    { type: 'bpmn:Lane', order: { level: -1 } }\n  ];\n\n  function computeOrder(element) {\n    if (element.labelTarget) {\n      return { level: 10 };\n    }\n\n    var entry = find(orders, function(o) {\n      return isAny(element, [ o.type ]);\n    });\n\n    return entry && entry.order || { level: 1 };\n  }\n\n  function getOrder(element) {\n\n    var order = element.order;\n\n    if (!order) {\n      element.order = order = computeOrder(element);\n    }\n\n    return order;\n  }\n\n  function findActualParent(element, newParent, containers) {\n\n    var actualParent = newParent;\n\n    while (actualParent) {\n\n      if (isAny(actualParent, containers)) {\n        break;\n      }\n\n      actualParent = actualParent.parent;\n    }\n\n    if (!actualParent) {\n      throw new Error(translate('no parent for {element} in {parent}', {\n        element: element.id,\n        parent: newParent.id\n      }));\n    }\n\n    return actualParent;\n  }\n\n  this.getOrdering = function(element, newParent) {\n\n    // render labels always on top\n    if (element.labelTarget) {\n      return {\n        parent: canvas.getRootElement(),\n        index: -1\n      };\n    }\n\n    var elementOrder = getOrder(element);\n\n\n    if (elementOrder.containers) {\n      newParent = findActualParent(element, newParent, elementOrder.containers);\n    }\n\n\n    var currentIndex = newParent.children.indexOf(element);\n\n    var insertIndex = findIndex(newParent.children, function(child) {\n\n      // do not compare with labels, they are created\n      // in the wrong order (right after elements) during import and\n      // mess up the positioning.\n      if (!element.labelTarget && child.labelTarget) {\n        return false;\n      }\n\n      return elementOrder.level < getOrder(child).level;\n    });\n\n\n    // if the element is already in the child list at\n    // a smaller index, we need to adjust the inser index.\n    // this takes into account that the element is being removed\n    // before being re-inserted\n    if (insertIndex !== -1) {\n      if (currentIndex !== -1 && currentIndex < insertIndex) {\n        insertIndex -= 1;\n      }\n    }\n\n    return {\n      index: insertIndex,\n      parent: newParent\n    };\n  };\n}\n\nBpmnOrderingProvider.$inject = [ 'eventBus', 'canvas', 'translate' ];\n\ninherits(BpmnOrderingProvider, OrderingProvider);"]},"metadata":{},"sourceType":"module"}