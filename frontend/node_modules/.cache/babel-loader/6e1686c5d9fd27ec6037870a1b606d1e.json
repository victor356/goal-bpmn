{"ast":null,"code":"import { assign, forEach } from 'min-dash';\nimport { getResizedSourceAnchor, getResizedTargetAnchor } from './helper/AnchorsHelper';\n/**\n * A handler that implements reversible resizing of shapes.\n *\n * @param {Modeling} modeling\n */\n\nexport default function ResizeShapeHandler(modeling) {\n  this._modeling = modeling;\n}\nResizeShapeHandler.$inject = ['modeling'];\n/**\n * {\n *   shape: {....}\n *   newBounds: {\n *     width:  20,\n *     height: 40,\n *     x:       5,\n *     y:      10\n *   }\n *\n * }\n */\n\nResizeShapeHandler.prototype.execute = function (context) {\n  var shape = context.shape,\n      newBounds = context.newBounds,\n      minBounds = context.minBounds;\n\n  if (newBounds.x === undefined || newBounds.y === undefined || newBounds.width === undefined || newBounds.height === undefined) {\n    throw new Error('newBounds must have {x, y, width, height} properties');\n  }\n\n  if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {\n    throw new Error('width and height cannot be less than minimum height and width');\n  } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {\n    throw new Error('width and height cannot be less than 10px');\n  } // save old bbox in context\n\n\n  context.oldBounds = {\n    width: shape.width,\n    height: shape.height,\n    x: shape.x,\n    y: shape.y\n  }; // update shape\n\n  assign(shape, {\n    width: newBounds.width,\n    height: newBounds.height,\n    x: newBounds.x,\n    y: newBounds.y\n  });\n  return shape;\n};\n\nResizeShapeHandler.prototype.postExecute = function (context) {\n  var shape = context.shape,\n      oldBounds = context.oldBounds;\n  var modeling = this._modeling;\n  forEach(shape.incoming, function (c) {\n    modeling.layoutConnection(c, {\n      connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)\n    });\n  });\n  forEach(shape.outgoing, function (c) {\n    modeling.layoutConnection(c, {\n      connectionStart: getResizedSourceAnchor(c, shape, oldBounds)\n    });\n  });\n};\n\nResizeShapeHandler.prototype.revert = function (context) {\n  var shape = context.shape,\n      oldBounds = context.oldBounds; // restore previous bbox\n\n  assign(shape, {\n    width: oldBounds.width,\n    height: oldBounds.height,\n    x: oldBounds.x,\n    y: oldBounds.y\n  });\n  return shape;\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js"],"names":["assign","forEach","getResizedSourceAnchor","getResizedTargetAnchor","ResizeShapeHandler","modeling","_modeling","$inject","prototype","execute","context","shape","newBounds","minBounds","x","undefined","y","width","height","Error","oldBounds","postExecute","incoming","c","layoutConnection","connectionEnd","outgoing","connectionStart","revert"],"mappings":"AAAA,SACEA,MADF,EAEEC,OAFF,QAGO,UAHP;AAKA,SACEC,sBADF,EAEEC,sBAFF,QAGO,wBAHP;AAMA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,kBAAT,CAA4BC,QAA5B,EAAsC;AACnD,OAAKC,SAAL,GAAiBD,QAAjB;AACD;AAEDD,kBAAkB,CAACG,OAAnB,GAA6B,CAAE,UAAF,CAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAH,kBAAkB,CAACI,SAAnB,CAA6BC,OAA7B,GAAuC,UAASC,OAAT,EAAkB;AACvD,MAAIC,KAAK,GAAGD,OAAO,CAACC,KAApB;AAAA,MACIC,SAAS,GAAGF,OAAO,CAACE,SADxB;AAAA,MAEIC,SAAS,GAAGH,OAAO,CAACG,SAFxB;;AAIA,MAAID,SAAS,CAACE,CAAV,KAAgBC,SAAhB,IAA6BH,SAAS,CAACI,CAAV,KAAgBD,SAA7C,IACAH,SAAS,CAACK,KAAV,KAAoBF,SADpB,IACiCH,SAAS,CAACM,MAAV,KAAqBH,SAD1D,EACqE;AACnE,UAAM,IAAII,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,MAAIN,SAAS,KAAKD,SAAS,CAACK,KAAV,GAAkBJ,SAAS,CAACI,KAA5B,IACbL,SAAS,CAACM,MAAV,GAAmBL,SAAS,CAACK,MADrB,CAAb,EAC2C;AACzC,UAAM,IAAIC,KAAJ,CAAU,+DAAV,CAAN;AACD,GAHD,MAGO,IAAI,CAACN,SAAD,IACND,SAAS,CAACK,KAAV,GAAkB,EADZ,IACkBL,SAAS,CAACM,MAAV,GAAmB,EADzC,EAC6C;AAClD,UAAM,IAAIC,KAAJ,CAAU,2CAAV,CAAN;AACD,GAhBsD,CAkBvD;;;AACAT,EAAAA,OAAO,CAACU,SAAR,GAAoB;AAClBH,IAAAA,KAAK,EAAGN,KAAK,CAACM,KADI;AAElBC,IAAAA,MAAM,EAAEP,KAAK,CAACO,MAFI;AAGlBJ,IAAAA,CAAC,EAAOH,KAAK,CAACG,CAHI;AAIlBE,IAAAA,CAAC,EAAOL,KAAK,CAACK;AAJI,GAApB,CAnBuD,CA0BvD;;AACAhB,EAAAA,MAAM,CAACW,KAAD,EAAQ;AACZM,IAAAA,KAAK,EAAGL,SAAS,CAACK,KADN;AAEZC,IAAAA,MAAM,EAAEN,SAAS,CAACM,MAFN;AAGZJ,IAAAA,CAAC,EAAOF,SAAS,CAACE,CAHN;AAIZE,IAAAA,CAAC,EAAOJ,SAAS,CAACI;AAJN,GAAR,CAAN;AAOA,SAAOL,KAAP;AACD,CAnCD;;AAqCAP,kBAAkB,CAACI,SAAnB,CAA6Ba,WAA7B,GAA2C,UAASX,OAAT,EAAkB;AAE3D,MAAIC,KAAK,GAAGD,OAAO,CAACC,KAApB;AAAA,MACIS,SAAS,GAAGV,OAAO,CAACU,SADxB;AAGA,MAAIf,QAAQ,GAAG,KAAKC,SAApB;AAEAL,EAAAA,OAAO,CAACU,KAAK,CAACW,QAAP,EAAiB,UAASC,CAAT,EAAY;AAClClB,IAAAA,QAAQ,CAACmB,gBAAT,CAA0BD,CAA1B,EAA6B;AAC3BE,MAAAA,aAAa,EAAEtB,sBAAsB,CAACoB,CAAD,EAAIZ,KAAJ,EAAWS,SAAX;AADV,KAA7B;AAGD,GAJM,CAAP;AAMAnB,EAAAA,OAAO,CAACU,KAAK,CAACe,QAAP,EAAiB,UAASH,CAAT,EAAY;AAClClB,IAAAA,QAAQ,CAACmB,gBAAT,CAA0BD,CAA1B,EAA6B;AAC3BI,MAAAA,eAAe,EAAEzB,sBAAsB,CAACqB,CAAD,EAAIZ,KAAJ,EAAWS,SAAX;AADZ,KAA7B;AAGD,GAJM,CAAP;AAMD,CAnBD;;AAqBAhB,kBAAkB,CAACI,SAAnB,CAA6BoB,MAA7B,GAAsC,UAASlB,OAAT,EAAkB;AAEtD,MAAIC,KAAK,GAAGD,OAAO,CAACC,KAApB;AAAA,MACIS,SAAS,GAAGV,OAAO,CAACU,SADxB,CAFsD,CAKtD;;AACApB,EAAAA,MAAM,CAACW,KAAD,EAAQ;AACZM,IAAAA,KAAK,EAAGG,SAAS,CAACH,KADN;AAEZC,IAAAA,MAAM,EAAEE,SAAS,CAACF,MAFN;AAGZJ,IAAAA,CAAC,EAAOM,SAAS,CAACN,CAHN;AAIZE,IAAAA,CAAC,EAAOI,SAAS,CAACJ;AAJN,GAAR,CAAN;AAOA,SAAOL,KAAP;AACD,CAdD","sourcesContent":["import {\n  assign,\n  forEach\n} from 'min-dash';\n\nimport {\n  getResizedSourceAnchor,\n  getResizedTargetAnchor\n} from './helper/AnchorsHelper';\n\n\n/**\n * A handler that implements reversible resizing of shapes.\n *\n * @param {Modeling} modeling\n */\nexport default function ResizeShapeHandler(modeling) {\n  this._modeling = modeling;\n}\n\nResizeShapeHandler.$inject = [ 'modeling' ];\n\n/**\n * {\n *   shape: {....}\n *   newBounds: {\n *     width:  20,\n *     height: 40,\n *     x:       5,\n *     y:      10\n *   }\n *\n * }\n */\nResizeShapeHandler.prototype.execute = function(context) {\n  var shape = context.shape,\n      newBounds = context.newBounds,\n      minBounds = context.minBounds;\n\n  if (newBounds.x === undefined || newBounds.y === undefined ||\n      newBounds.width === undefined || newBounds.height === undefined) {\n    throw new Error('newBounds must have {x, y, width, height} properties');\n  }\n\n  if (minBounds && (newBounds.width < minBounds.width\n    || newBounds.height < minBounds.height)) {\n    throw new Error('width and height cannot be less than minimum height and width');\n  } else if (!minBounds\n    && newBounds.width < 10 || newBounds.height < 10) {\n    throw new Error('width and height cannot be less than 10px');\n  }\n\n  // save old bbox in context\n  context.oldBounds = {\n    width:  shape.width,\n    height: shape.height,\n    x:      shape.x,\n    y:      shape.y\n  };\n\n  // update shape\n  assign(shape, {\n    width:  newBounds.width,\n    height: newBounds.height,\n    x:      newBounds.x,\n    y:      newBounds.y\n  });\n\n  return shape;\n};\n\nResizeShapeHandler.prototype.postExecute = function(context) {\n\n  var shape = context.shape,\n      oldBounds = context.oldBounds;\n\n  var modeling = this._modeling;\n\n  forEach(shape.incoming, function(c) {\n    modeling.layoutConnection(c, {\n      connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)\n    });\n  });\n\n  forEach(shape.outgoing, function(c) {\n    modeling.layoutConnection(c, {\n      connectionStart: getResizedSourceAnchor(c, shape, oldBounds)\n    });\n  });\n\n};\n\nResizeShapeHandler.prototype.revert = function(context) {\n\n  var shape = context.shape,\n      oldBounds = context.oldBounds;\n\n  // restore previous bbox\n  assign(shape, {\n    width:  oldBounds.width,\n    height: oldBounds.height,\n    x:      oldBounds.x,\n    y:      oldBounds.y\n  });\n\n  return shape;\n};\n"]},"metadata":{},"sourceType":"module"}