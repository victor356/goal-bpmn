{"ast":null,"code":"import { forEach } from 'min-dash';\nimport { getMovedSourceAnchor, getMovedTargetAnchor } from './AnchorsHelper';\nimport MoveClosure from './MoveClosure';\n/**\n * A helper that is able to carry out serialized move\n * operations on multiple elements.\n *\n * @param {Modeling} modeling\n */\n\nexport default function MoveHelper(modeling) {\n  this._modeling = modeling;\n}\n/**\n * Move the specified elements and all children by the given delta.\n *\n * This moves all enclosed connections, too and layouts all affected\n * external connections.\n *\n * @param  {Array<djs.model.Base>} elements\n * @param  {Point} delta\n * @param  {djs.model.Base} newParent applied to the first level of shapes\n *\n * @return {Array<djs.model.Base>} list of touched elements\n */\n\nMoveHelper.prototype.moveRecursive = function (elements, delta, newParent) {\n  if (!elements) {\n    return [];\n  } else {\n    return this.moveClosure(this.getClosure(elements), delta, newParent);\n  }\n};\n/**\n * Move the given closure of elmements.\n *\n * @param {Object} closure\n * @param {Point} delta\n * @param {djs.model.Base} [newParent]\n * @param {djs.model.Base} [newHost]\n */\n\n\nMoveHelper.prototype.moveClosure = function (closure, delta, newParent, newHost, primaryShape) {\n  var modeling = this._modeling;\n  var allShapes = closure.allShapes,\n      allConnections = closure.allConnections,\n      enclosedConnections = closure.enclosedConnections,\n      topLevel = closure.topLevel,\n      keepParent = false;\n\n  if (primaryShape && primaryShape.parent === newParent) {\n    keepParent = true;\n  } // move all shapes\n\n\n  forEach(allShapes, function (shape) {\n    // move the element according to the given delta\n    modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {\n      recurse: false,\n      layout: false\n    });\n  }); // move all child connections / layout external connections\n\n  forEach(allConnections, function (c) {\n    var sourceMoved = !!allShapes[c.source.id],\n        targetMoved = !!allShapes[c.target.id];\n\n    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {\n      modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);\n    } else {\n      modeling.layoutConnection(c, {\n        connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),\n        connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)\n      });\n    }\n  });\n};\n/**\n * Returns the closure for the selected elements\n *\n * @param  {Array<djs.model.Base>} elements\n * @return {MoveClosure} closure\n */\n\n\nMoveHelper.prototype.getClosure = function (elements) {\n  return new MoveClosure().addAll(elements, true);\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js"],"names":["forEach","getMovedSourceAnchor","getMovedTargetAnchor","MoveClosure","MoveHelper","modeling","_modeling","prototype","moveRecursive","elements","delta","newParent","moveClosure","getClosure","closure","newHost","primaryShape","allShapes","allConnections","enclosedConnections","topLevel","keepParent","parent","shape","moveShape","id","recurse","layout","c","sourceMoved","source","targetMoved","target","moveConnection","layoutConnection","connectionStart","connectionEnd","addAll"],"mappings":"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","sourcesContent":["import {\n  forEach\n} from 'min-dash';\n\nimport {\n  getMovedSourceAnchor,\n  getMovedTargetAnchor\n} from './AnchorsHelper';\n\nimport MoveClosure from './MoveClosure';\n\n\n/**\n * A helper that is able to carry out serialized move\n * operations on multiple elements.\n *\n * @param {Modeling} modeling\n */\nexport default function MoveHelper(modeling) {\n  this._modeling = modeling;\n}\n\n/**\n * Move the specified elements and all children by the given delta.\n *\n * This moves all enclosed connections, too and layouts all affected\n * external connections.\n *\n * @param  {Array<djs.model.Base>} elements\n * @param  {Point} delta\n * @param  {djs.model.Base} newParent applied to the first level of shapes\n *\n * @return {Array<djs.model.Base>} list of touched elements\n */\nMoveHelper.prototype.moveRecursive = function(elements, delta, newParent) {\n  if (!elements) {\n    return [];\n  } else {\n    return this.moveClosure(this.getClosure(elements), delta, newParent);\n  }\n};\n\n/**\n * Move the given closure of elmements.\n *\n * @param {Object} closure\n * @param {Point} delta\n * @param {djs.model.Base} [newParent]\n * @param {djs.model.Base} [newHost]\n */\nMoveHelper.prototype.moveClosure = function(closure, delta, newParent, newHost, primaryShape) {\n  var modeling = this._modeling;\n\n  var allShapes = closure.allShapes,\n      allConnections = closure.allConnections,\n      enclosedConnections = closure.enclosedConnections,\n      topLevel = closure.topLevel,\n      keepParent = false;\n\n  if (primaryShape && primaryShape.parent === newParent) {\n    keepParent = true;\n  }\n\n  // move all shapes\n  forEach(allShapes, function(shape) {\n\n    // move the element according to the given delta\n    modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {\n      recurse: false,\n      layout: false\n    });\n  });\n\n  // move all child connections / layout external connections\n  forEach(allConnections, function(c) {\n\n    var sourceMoved = !!allShapes[c.source.id],\n        targetMoved = !!allShapes[c.target.id];\n\n    if (enclosedConnections[c.id] && sourceMoved && targetMoved) {\n      modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);\n    } else {\n      modeling.layoutConnection(c, {\n        connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),\n        connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)\n      });\n    }\n  });\n};\n\n/**\n * Returns the closure for the selected elements\n *\n * @param  {Array<djs.model.Base>} elements\n * @return {MoveClosure} closure\n */\nMoveHelper.prototype.getClosure = function(elements) {\n  return new MoveClosure().addAll(elements, true);\n};"]},"metadata":{},"sourceType":"module"}