{"ast":null,"code":"import { isObject, assign, forEach, reduce } from 'min-dash';\nimport { append as svgAppend, attr as svgAttr, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nvar DEFAULT_BOX_PADDING = 0;\nvar DEFAULT_LABEL_SIZE = {\n  width: 150,\n  height: 50\n};\n\nfunction parseAlign(align) {\n  var parts = align.split('-');\n  return {\n    horizontal: parts[0] || 'center',\n    vertical: parts[1] || 'top'\n  };\n}\n\nfunction parsePadding(padding) {\n  if (isObject(padding)) {\n    return assign({\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    }, padding);\n  } else {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding\n    };\n  }\n}\n\nfunction getTextBBox(text, fakeText) {\n  fakeText.textContent = text;\n  var textBBox;\n\n  try {\n    var bbox,\n        emptyLine = text === ''; // add dummy text, when line is empty to\n    // determine correct height\n\n    fakeText.textContent = emptyLine ? 'dummy' : text;\n    textBBox = fakeText.getBBox(); // take text rendering related horizontal\n    // padding into account\n\n    bbox = {\n      width: textBBox.width + textBBox.x * 2,\n      height: textBBox.height\n    };\n\n    if (emptyLine) {\n      // correct width\n      bbox.width = 0;\n    }\n\n    return bbox;\n  } catch (e) {\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n}\n/**\n * Layout the next line and return the layouted element.\n *\n * Alters the lines passed.\n *\n * @param  {Array<String>} lines\n * @return {Object} the line descriptor, an object { width, height, text }\n */\n\n\nfunction layoutNext(lines, maxWidth, fakeText) {\n  var originalLine = lines.shift(),\n      fitLine = originalLine;\n  var textBBox;\n\n  for (;;) {\n    textBBox = getTextBBox(fitLine, fakeText);\n    textBBox.width = fitLine ? textBBox.width : 0; // try to fit\n\n    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {\n      return fit(lines, fitLine, originalLine, textBBox);\n    }\n\n    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\n  }\n}\n\nfunction fit(lines, fitLine, originalLine, textBBox) {\n  if (fitLine.length < originalLine.length) {\n    var remainder = originalLine.slice(fitLine.length).trim();\n    lines.unshift(remainder);\n  }\n\n  return {\n    width: textBBox.width,\n    height: textBBox.height,\n    text: fitLine\n  };\n}\n/**\n * Shortens a line based on spacing and hyphens.\n * Returns the shortened result on success.\n *\n * @param  {String} line\n * @param  {Number} maxLength the maximum characters of the string\n * @return {String} the shortened string\n */\n\n\nfunction semanticShorten(line, maxLength) {\n  var parts = line.split(/(\\s|-)/g),\n      part,\n      shortenedParts = [],\n      length = 0; // try to shorten via spaces + hyphens\n\n  if (parts.length > 1) {\n    while (part = parts.shift()) {\n      if (part.length + length < maxLength) {\n        shortenedParts.push(part);\n        length += part.length;\n      } else {\n        // remove previous part, too if hyphen does not fit anymore\n        if (part === '-') {\n          shortenedParts.pop();\n        }\n\n        break;\n      }\n    }\n  }\n\n  return shortenedParts.join('');\n}\n\nfunction shortenLine(line, width, maxWidth) {\n  var length = Math.max(line.length * (maxWidth / width), 1); // try to shorten semantically (i.e. based on spaces and hyphens)\n\n  var shortenedLine = semanticShorten(line, length);\n\n  if (!shortenedLine) {\n    // force shorten by cutting the long word\n    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\n  }\n\n  return shortenedLine;\n}\n\nfunction getHelperSvg() {\n  var helperSvg = document.getElementById('helper-svg');\n\n  if (!helperSvg) {\n    helperSvg = svgCreate('svg');\n    svgAttr(helperSvg, {\n      id: 'helper-svg',\n      width: 0,\n      height: 0,\n      style: 'visibility: hidden; position: fixed'\n    });\n    document.body.appendChild(helperSvg);\n  }\n\n  return helperSvg;\n}\n/**\n * Creates a new label utility\n *\n * @param {Object} config\n * @param {Dimensions} config.size\n * @param {Number} config.padding\n * @param {Object} config.style\n * @param {String} config.align\n */\n\n\nexport default function Text(config) {\n  this._config = assign({}, {\n    size: DEFAULT_LABEL_SIZE,\n    padding: DEFAULT_BOX_PADDING,\n    style: {},\n    align: 'center-top'\n  }, config || {});\n}\n/**\n * Returns the layouted text as an SVG element.\n *\n * @param {String} text\n * @param {Object} options\n *\n * @return {SVGElement}\n */\n\nText.prototype.createText = function (text, options) {\n  return this.layoutText(text, options).element;\n};\n/**\n * Returns a labels layouted dimensions.\n *\n * @param {String} text to layout\n * @param {Object} options\n *\n * @return {Dimensions}\n */\n\n\nText.prototype.getDimensions = function (text, options) {\n  return this.layoutText(text, options).dimensions;\n};\n/**\n * Creates and returns a label and its bounding box.\n *\n * @method Text#createText\n *\n * @param {String} text the text to render on the label\n * @param {Object} options\n * @param {String} options.align how to align in the bounding box.\n *                               Any of { 'center-middle', 'center-top' },\n *                               defaults to 'center-top'.\n * @param {String} options.style style to be applied to the text\n * @param {boolean} options.fitBox indicates if box will be recalculated to\n *                                 fit text\n *\n * @return {Object} { element, dimensions }\n */\n\n\nText.prototype.layoutText = function (text, options) {\n  var box = assign({}, this._config.size, options.box),\n      style = assign({}, this._config.style, options.style),\n      align = parseAlign(options.align || this._config.align),\n      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),\n      fitBox = options.fitBox || false;\n  var lineHeight = getLineHeight(style);\n  var lines = text.split(/\\r?\\n/g),\n      layouted = [];\n  var maxWidth = box.width - padding.left - padding.right; // ensure correct rendering by attaching helper text node to invisible SVG\n\n  var helperText = svgCreate('text');\n  svgAttr(helperText, {\n    x: 0,\n    y: 0\n  });\n  svgAttr(helperText, style);\n  var helperSvg = getHelperSvg();\n  svgAppend(helperSvg, helperText);\n\n  while (lines.length) {\n    layouted.push(layoutNext(lines, maxWidth, helperText));\n  }\n\n  if (align.vertical === 'middle') {\n    padding.top = padding.bottom = 0;\n  }\n\n  var totalHeight = reduce(layouted, function (sum, line, idx) {\n    return sum + (lineHeight || line.height);\n  }, 0) + padding.top + padding.bottom;\n  var maxLineWidth = reduce(layouted, function (sum, line, idx) {\n    return line.width > sum ? line.width : sum;\n  }, 0); // the y position of the next line\n\n  var y = padding.top;\n\n  if (align.vertical === 'middle') {\n    y += (box.height - totalHeight) / 2;\n  } // magic number initial offset\n\n\n  y -= (lineHeight || layouted[0].height) / 4;\n  var textElement = svgCreate('text');\n  svgAttr(textElement, style); // layout each line taking into account that parent\n  // shape might resize to fit text size\n\n  forEach(layouted, function (line) {\n    var x;\n    y += lineHeight || line.height;\n\n    switch (align.horizontal) {\n      case 'left':\n        x = padding.left;\n        break;\n\n      case 'right':\n        x = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;\n        break;\n\n      default:\n        // aka center\n        x = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);\n    }\n\n    var tspan = svgCreate('tspan');\n    svgAttr(tspan, {\n      x: x,\n      y: y\n    });\n    tspan.textContent = line.text;\n    svgAppend(textElement, tspan);\n  });\n  svgRemove(helperText);\n  var dimensions = {\n    width: maxLineWidth,\n    height: totalHeight\n  };\n  return {\n    dimensions: dimensions,\n    element: textElement\n  };\n};\n\nfunction getLineHeight(style) {\n  if ('fontSize' in style && 'lineHeight' in style) {\n    return style.lineHeight * parseInt(style.fontSize, 10);\n  }\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/node_modules/diagram-js/lib/util/Text.js"],"names":["isObject","assign","forEach","reduce","append","svgAppend","attr","svgAttr","create","svgCreate","remove","svgRemove","DEFAULT_BOX_PADDING","DEFAULT_LABEL_SIZE","width","height","parseAlign","align","parts","split","horizontal","vertical","parsePadding","padding","top","left","right","bottom","getTextBBox","text","fakeText","textContent","textBBox","bbox","emptyLine","getBBox","x","e","layoutNext","lines","maxWidth","originalLine","shift","fitLine","Math","round","length","fit","shortenLine","remainder","slice","trim","unshift","semanticShorten","line","maxLength","part","shortenedParts","push","pop","join","max","shortenedLine","getHelperSvg","helperSvg","document","getElementById","id","style","body","appendChild","Text","config","_config","size","prototype","createText","options","layoutText","element","getDimensions","dimensions","box","undefined","fitBox","lineHeight","getLineHeight","layouted","helperText","y","totalHeight","sum","idx","maxLineWidth","textElement","tspan","parseInt","fontSize"],"mappings":"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","sourcesContent":["import {\n  isObject,\n  assign,\n  forEach,\n  reduce\n} from 'min-dash';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  create as svgCreate,\n  remove as svgRemove\n} from 'tiny-svg';\n\nvar DEFAULT_BOX_PADDING = 0;\n\nvar DEFAULT_LABEL_SIZE = {\n  width: 150,\n  height: 50\n};\n\n\nfunction parseAlign(align) {\n\n  var parts = align.split('-');\n\n  return {\n    horizontal: parts[0] || 'center',\n    vertical: parts[1] || 'top'\n  };\n}\n\nfunction parsePadding(padding) {\n\n  if (isObject(padding)) {\n    return assign({ top: 0, left: 0, right: 0, bottom: 0 }, padding);\n  } else {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding\n    };\n  }\n}\n\nfunction getTextBBox(text, fakeText) {\n\n  fakeText.textContent = text;\n\n  var textBBox;\n\n  try {\n    var bbox,\n        emptyLine = text === '';\n\n    // add dummy text, when line is empty to\n    // determine correct height\n    fakeText.textContent = emptyLine ? 'dummy' : text;\n\n    textBBox = fakeText.getBBox();\n\n    // take text rendering related horizontal\n    // padding into account\n    bbox = {\n      width: textBBox.width + textBBox.x * 2,\n      height: textBBox.height\n    };\n\n    if (emptyLine) {\n      // correct width\n      bbox.width = 0;\n    }\n\n    return bbox;\n  } catch (e) {\n    return { width: 0, height: 0 };\n  }\n}\n\n\n/**\n * Layout the next line and return the layouted element.\n *\n * Alters the lines passed.\n *\n * @param  {Array<String>} lines\n * @return {Object} the line descriptor, an object { width, height, text }\n */\nfunction layoutNext(lines, maxWidth, fakeText) {\n\n  var originalLine = lines.shift(),\n      fitLine = originalLine;\n\n  var textBBox;\n\n  for (;;) {\n    textBBox = getTextBBox(fitLine, fakeText);\n\n    textBBox.width = fitLine ? textBBox.width : 0;\n\n    // try to fit\n    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {\n      return fit(lines, fitLine, originalLine, textBBox);\n    }\n\n    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\n  }\n}\n\nfunction fit(lines, fitLine, originalLine, textBBox) {\n  if (fitLine.length < originalLine.length) {\n    var remainder = originalLine.slice(fitLine.length).trim();\n\n    lines.unshift(remainder);\n  }\n\n  return {\n    width: textBBox.width,\n    height: textBBox.height,\n    text: fitLine\n  };\n}\n\n\n/**\n * Shortens a line based on spacing and hyphens.\n * Returns the shortened result on success.\n *\n * @param  {String} line\n * @param  {Number} maxLength the maximum characters of the string\n * @return {String} the shortened string\n */\nfunction semanticShorten(line, maxLength) {\n  var parts = line.split(/(\\s|-)/g),\n      part,\n      shortenedParts = [],\n      length = 0;\n\n  // try to shorten via spaces + hyphens\n  if (parts.length > 1) {\n    while ((part = parts.shift())) {\n      if (part.length + length < maxLength) {\n        shortenedParts.push(part);\n        length += part.length;\n      } else {\n        // remove previous part, too if hyphen does not fit anymore\n        if (part === '-') {\n          shortenedParts.pop();\n        }\n\n        break;\n      }\n    }\n  }\n\n  return shortenedParts.join('');\n}\n\n\nfunction shortenLine(line, width, maxWidth) {\n  var length = Math.max(line.length * (maxWidth / width), 1);\n\n  // try to shorten semantically (i.e. based on spaces and hyphens)\n  var shortenedLine = semanticShorten(line, length);\n\n  if (!shortenedLine) {\n\n    // force shorten by cutting the long word\n    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\n  }\n\n  return shortenedLine;\n}\n\n\nfunction getHelperSvg() {\n  var helperSvg = document.getElementById('helper-svg');\n\n  if (!helperSvg) {\n    helperSvg = svgCreate('svg');\n\n    svgAttr(helperSvg, {\n      id: 'helper-svg',\n      width: 0,\n      height: 0,\n      style: 'visibility: hidden; position: fixed'\n    });\n\n    document.body.appendChild(helperSvg);\n  }\n\n  return helperSvg;\n}\n\n\n/**\n * Creates a new label utility\n *\n * @param {Object} config\n * @param {Dimensions} config.size\n * @param {Number} config.padding\n * @param {Object} config.style\n * @param {String} config.align\n */\nexport default function Text(config) {\n\n  this._config = assign({}, {\n    size: DEFAULT_LABEL_SIZE,\n    padding: DEFAULT_BOX_PADDING,\n    style: {},\n    align: 'center-top'\n  }, config || {});\n}\n\n/**\n * Returns the layouted text as an SVG element.\n *\n * @param {String} text\n * @param {Object} options\n *\n * @return {SVGElement}\n */\nText.prototype.createText = function(text, options) {\n  return this.layoutText(text, options).element;\n};\n\n/**\n * Returns a labels layouted dimensions.\n *\n * @param {String} text to layout\n * @param {Object} options\n *\n * @return {Dimensions}\n */\nText.prototype.getDimensions = function(text, options) {\n  return this.layoutText(text, options).dimensions;\n};\n\n/**\n * Creates and returns a label and its bounding box.\n *\n * @method Text#createText\n *\n * @param {String} text the text to render on the label\n * @param {Object} options\n * @param {String} options.align how to align in the bounding box.\n *                               Any of { 'center-middle', 'center-top' },\n *                               defaults to 'center-top'.\n * @param {String} options.style style to be applied to the text\n * @param {boolean} options.fitBox indicates if box will be recalculated to\n *                                 fit text\n *\n * @return {Object} { element, dimensions }\n */\nText.prototype.layoutText = function(text, options) {\n  var box = assign({}, this._config.size, options.box),\n      style = assign({}, this._config.style, options.style),\n      align = parseAlign(options.align || this._config.align),\n      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),\n      fitBox = options.fitBox || false;\n\n  var lineHeight = getLineHeight(style);\n\n  var lines = text.split(/\\r?\\n/g),\n      layouted = [];\n\n  var maxWidth = box.width - padding.left - padding.right;\n\n  // ensure correct rendering by attaching helper text node to invisible SVG\n  var helperText = svgCreate('text');\n  svgAttr(helperText, { x: 0, y: 0 });\n  svgAttr(helperText, style);\n\n  var helperSvg = getHelperSvg();\n\n  svgAppend(helperSvg, helperText);\n\n  while (lines.length) {\n    layouted.push(layoutNext(lines, maxWidth, helperText));\n  }\n\n  if (align.vertical === 'middle') {\n    padding.top = padding.bottom = 0;\n  }\n\n  var totalHeight = reduce(layouted, function(sum, line, idx) {\n    return sum + (lineHeight || line.height);\n  }, 0) + padding.top + padding.bottom;\n\n  var maxLineWidth = reduce(layouted, function(sum, line, idx) {\n    return line.width > sum ? line.width : sum;\n  }, 0);\n\n  // the y position of the next line\n  var y = padding.top;\n\n  if (align.vertical === 'middle') {\n    y += (box.height - totalHeight) / 2;\n  }\n\n  // magic number initial offset\n  y -= (lineHeight || layouted[0].height) / 4;\n\n\n  var textElement = svgCreate('text');\n\n  svgAttr(textElement, style);\n\n  // layout each line taking into account that parent\n  // shape might resize to fit text size\n  forEach(layouted, function(line) {\n\n    var x;\n\n    y += (lineHeight || line.height);\n\n    switch (align.horizontal) {\n    case 'left':\n      x = padding.left;\n      break;\n\n    case 'right':\n      x = ((fitBox ? maxLineWidth : maxWidth)\n        - padding.right - line.width);\n      break;\n\n    default:\n      // aka center\n      x = Math.max((((fitBox ? maxLineWidth : maxWidth)\n        - line.width) / 2 + padding.left), 0);\n    }\n\n    var tspan = svgCreate('tspan');\n    svgAttr(tspan, { x: x, y: y });\n\n    tspan.textContent = line.text;\n\n    svgAppend(textElement, tspan);\n  });\n\n  svgRemove(helperText);\n\n  var dimensions = {\n    width: maxLineWidth,\n    height: totalHeight\n  };\n\n  return {\n    dimensions: dimensions,\n    element: textElement\n  };\n};\n\n\nfunction getLineHeight(style) {\n  if ('fontSize' in style && 'lineHeight' in style) {\n    return style.lineHeight * parseInt(style.fontSize, 10);\n  }\n}"]},"metadata":{},"sourceType":"module"}