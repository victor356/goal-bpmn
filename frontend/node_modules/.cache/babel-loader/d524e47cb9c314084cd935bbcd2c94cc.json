{"ast":null,"code":"var CLASS_PATTERN = /^class /;\n\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n  fn.$inject = args;\n  return fn;\n} // Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^function\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\nfunction parse(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS); // may parse class without constructor\n\n  if (!match) {\n    return [];\n  }\n\n  return match[1] && match[1].split(',').map(function (arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n}\n\nfunction Module() {\n  var providers = [];\n\n  this.factory = function (name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n\n  this.value = function (name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n\n  this.type = function (name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n\n  this.forEach = function (iterator) {\n    providers.forEach(iterator);\n  };\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function get(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n  var self = instances.injector = this;\n\n  var error = function error(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n\n\n  var get = function get(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (hasProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  };\n\n  var fnDef = function fnDef(fn) {\n    var locals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject || parse(fn);\n    var dependencies = inject.map(function (dep) {\n      if (hasProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  };\n\n  var instantiate = function instantiate(Type) {\n    var _fnDef = fnDef(Type),\n        dependencies = _fnDef.dependencies,\n        fn = _fnDef.fn;\n\n    return new (Function.prototype.bind.apply(fn, [null].concat(_toConsumableArray(dependencies))))();\n  };\n\n  var invoke = function invoke(func, context, locals) {\n    var _fnDef2 = fnDef(func, locals),\n        dependencies = _fnDef2.dependencies,\n        fn = _fnDef2.fn;\n\n    return fn.call.apply(fn, [context].concat(_toConsumableArray(dependencies)));\n  };\n\n  var createPrivateInjectorFactory = function createPrivateInjectorFactory(privateChildInjector) {\n    return annotate(function (key) {\n      return privateChildInjector.get(key);\n    });\n  };\n\n  var createChild = function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function (scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function (scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function value(_value) {\n      return _value;\n    }\n  };\n  modules.forEach(function (module) {\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n\n      return value;\n    } // TODO(vojta): handle wrong inputs (modules)\n\n\n    if (module instanceof Module) {\n      module.forEach(function (provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function (m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n\n          return m;\n        }, Object.create(null));\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function (key) {\n          return privateInjector.get(key);\n        });\n\n        module.__exports__.forEach(function (key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function (name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n\n          var type = module[name][0];\n          var value = module[name][1];\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  }); // public API\n\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n} // helpers /////////////////\n\n\nfunction hasProp(obj, prop) {\n  return Object.hasOwnProperty.call(obj, prop);\n}\n\nexport { annotate, Module, Injector };","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/didi/dist/index.esm.js"],"names":["CLASS_PATTERN","isClass","fn","test","toString","isArray","obj","Object","prototype","call","annotate","args","Array","slice","arguments","length","pop","$inject","CONSTRUCTOR_ARGS","FN_ARGS","FN_ARG","parse","Error","match","split","map","arg","trim","Module","providers","factory","name","push","value","type","forEach","iterator","_typeof","Symbol","constructor","_toConsumableArray","arr","i","arr2","from","Injector","modules","parent","get","strict","currentlyResolving","error","_providers","create","instances","_instances","self","injector","msg","stack","join","indexOf","parts","pivot","shift","hasProp","fnDef","locals","undefined","inject","dependencies","dep","instantiate","Type","_fnDef","Function","bind","apply","concat","invoke","func","context","_fnDef2","createPrivateInjectorFactory","privateChildInjector","key","createChild","forceNewInstances","fromParentModule","matchedScopes","privateInjectorsCache","privateChildInjectors","privateChildFactories","provider","cacheIdx","privateChildInjectorFactory","$scope","scope","unshift","factoryMap","_value","module","arrayUnwrap","__exports__","clonedModule","keys","reduce","m","substring","privateInjector","__modules__","getFromPrivateInjector","prop","hasOwnProperty"],"mappings":"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","sourcesContent":["var CLASS_PATTERN = /^class /;\n\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^function\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\nfunction parse(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  return match[1] && match[1].split(',').map(function (arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n}\n\nfunction Module() {\n  var providers = [];\n\n  this.factory = function (name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n\n  this.value = function (name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n\n  this.type = function (name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n\n  this.forEach = function (iterator) {\n    providers.forEach(iterator);\n  };\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function get(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  var self = instances.injector = this;\n\n  var error = function error(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n  var get = function get(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (hasProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  };\n\n  var fnDef = function fnDef(fn) {\n    var locals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject || parse(fn);\n    var dependencies = inject.map(function (dep) {\n      if (hasProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  };\n\n  var instantiate = function instantiate(Type) {\n    var _fnDef = fnDef(Type),\n        dependencies = _fnDef.dependencies,\n        fn = _fnDef.fn;\n\n    return new (Function.prototype.bind.apply(fn, [null].concat(_toConsumableArray(dependencies))))();\n  };\n\n  var invoke = function invoke(func, context, locals) {\n    var _fnDef2 = fnDef(func, locals),\n        dependencies = _fnDef2.dependencies,\n        fn = _fnDef2.fn;\n\n    return fn.call.apply(fn, [context].concat(_toConsumableArray(dependencies)));\n  };\n\n  var createPrivateInjectorFactory = function createPrivateInjectorFactory(privateChildInjector) {\n    return annotate(function (key) {\n      return privateChildInjector.get(key);\n    });\n  };\n\n  var createChild = function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function (scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function (scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function value(_value) {\n      return _value;\n    }\n  };\n\n  modules.forEach(function (module) {\n\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n\n      return value;\n    }\n\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function (provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function (m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n          return m;\n        }, Object.create(null));\n\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function (key) {\n          return privateInjector.get(key);\n        });\n        module.__exports__.forEach(function (key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function (name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n\n          var type = module[name][0];\n          var value = module[name][1];\n\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n}\n\n// helpers /////////////////\n\nfunction hasProp(obj, prop) {\n  return Object.hasOwnProperty.call(obj, prop);\n}\n\nexport { annotate, Module, Injector };\n"]},"metadata":{},"sourceType":"module"}