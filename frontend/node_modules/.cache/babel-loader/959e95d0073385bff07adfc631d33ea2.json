{"ast":null,"code":"/* global TouchEvent */\nvar round = Math.round;\nimport { assign } from 'min-dash';\nimport { event as domEvent } from 'min-dom';\nimport { getOriginal, toPoint, stopPropagation } from '../../util/Event';\nimport { set as cursorSet, unset as cursorUnset } from '../../util/Cursor';\nimport { install as installClickTrap } from '../../util/ClickTrap';\nimport { delta as deltaPos } from '../../util/PositionUtil';\nvar DRAG_ACTIVE_CLS = 'djs-drag-active';\n\nfunction preventDefault(event) {\n  event.preventDefault();\n}\n\nfunction isTouchEvent(event) {\n  // check for TouchEvent being available first\n  // (i.e. not available on desktop Firefox)\n  return typeof TouchEvent !== 'undefined' && event instanceof TouchEvent;\n}\n\nfunction getLength(point) {\n  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n}\n/**\n * A helper that fires canvas localized drag events and realizes\n * the general \"drag-and-drop\" look and feel.\n *\n * Calling {@link Dragging#activate} activates dragging on a canvas.\n *\n * It provides the following:\n *\n *   * emits life cycle events, namespaced with a prefix assigned\n *     during dragging activation\n *   * sets and restores the cursor\n *   * sets and restores the selection\n *   * ensures there can be only one drag operation active at a time\n *\n * Dragging may be canceled manually by calling {@link Dragging#cancel}\n * or by pressing ESC.\n *\n *\n * ## Life-cycle events\n *\n * Dragging can be in three different states, off, initialized\n * and active.\n *\n * (1) off: no dragging operation is in progress\n * (2) initialized: a new drag operation got initialized but not yet\n *                  started (i.e. because of no initial move)\n * (3) started: dragging is in progress\n *\n * Eventually dragging will be off again after a drag operation has\n * been ended or canceled via user click or ESC key press.\n *\n * To indicate transitions between these states dragging emits generic\n * life-cycle events with the `drag.` prefix _and_ events namespaced\n * to a prefix choosen by a user during drag initialization.\n *\n * The following events are emitted (appropriately prefixed) via\n * the {@link EventBus}.\n *\n * * `init`\n * * `start`\n * * `move`\n * * `end`\n * * `ended` (dragging already in off state)\n * * `cancel` (only if previously started)\n * * `canceled` (dragging already in off state, only if previously started)\n * * `cleanup`\n *\n *\n * @example\n *\n * function MyDragComponent(eventBus, dragging) {\n *\n *   eventBus.on('mydrag.start', function(event) {\n *     console.log('yes, we start dragging');\n *   });\n *\n *   eventBus.on('mydrag.move', function(event) {\n *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);\n *\n *     // local drag data is passed with the event\n *     event.context.foo; // \"BAR\"\n *\n *     // the original mouse event, too\n *     event.originalEvent; // MouseEvent(...)\n *   });\n *\n *   eventBus.on('element.click', function(event) {\n *     dragging.init(event, 'mydrag', {\n *       cursor: 'grabbing',\n *       data: {\n *         context: {\n *           foo: \"BAR\"\n *         }\n *       }\n *     });\n *   });\n * }\n */\n\n\nexport default function Dragging(eventBus, canvas, selection) {\n  var defaultOptions = {\n    threshold: 5,\n    trapClick: true\n  }; // the currently active drag operation\n  // dragging is active as soon as this context exists.\n  //\n  // it is visually _active_ only when a context.active flag is set to true.\n\n  var context;\n  /* convert a global event into local coordinates */\n\n  function toLocalPoint(globalPosition) {\n    var viewbox = canvas.viewbox();\n\n    var clientRect = canvas._container.getBoundingClientRect();\n\n    return {\n      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,\n      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale\n    };\n  } // helpers\n\n\n  function fire(type, dragContext) {\n    dragContext = dragContext || context;\n    var event = eventBus.createEvent(assign({}, dragContext.payload, dragContext.data, {\n      isTouch: dragContext.isTouch\n    })); // default integration\n\n    if (eventBus.fire('drag.' + type, event) === false) {\n      return false;\n    }\n\n    return eventBus.fire(dragContext.prefix + '.' + type, event);\n  } // event listeners\n\n\n  function move(event, activate) {\n    var payload = context.payload,\n        displacement = context.displacement;\n    var globalStart = context.globalStart,\n        globalCurrent = toPoint(event),\n        globalDelta = deltaPos(globalCurrent, globalStart);\n    var localStart = context.localStart,\n        localCurrent = toLocalPoint(globalCurrent),\n        localDelta = deltaPos(localCurrent, localStart); // activate context explicitly or once threshold is reached\n\n    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {\n      // fire start event with original\n      // starting coordinates\n      assign(payload, {\n        x: round(localStart.x + displacement.x),\n        y: round(localStart.y + displacement.y),\n        dx: 0,\n        dy: 0\n      }, {\n        originalEvent: event\n      });\n\n      if (false === fire('start')) {\n        return cancel();\n      }\n\n      context.active = true; // unset selection and remember old selection\n      // the previous (old) selection will always passed\n      // with the event via the event.previousSelection property\n\n      if (!context.keepSelection) {\n        payload.previousSelection = selection.get();\n        selection.select(null);\n      } // allow custom cursor\n\n\n      if (context.cursor) {\n        cursorSet(context.cursor);\n      } // indicate dragging via marker on root element\n\n\n      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n    }\n\n    stopPropagation(event);\n\n    if (context.active) {\n      // update payload with actual coordinates\n      assign(payload, {\n        x: round(localCurrent.x + displacement.x),\n        y: round(localCurrent.y + displacement.y),\n        dx: round(localDelta.x),\n        dy: round(localDelta.y)\n      }, {\n        originalEvent: event\n      }); // emit move event\n\n      fire('move');\n    }\n  }\n\n  function end(event) {\n    var previousContext,\n        returnValue = true;\n\n    if (context.active) {\n      if (event) {\n        context.payload.originalEvent = event; // suppress original event (click, ...)\n        // because we just ended a drag operation\n\n        stopPropagation(event);\n      } // implementations may stop restoring the\n      // original state (selections, ...) by preventing the\n      // end events default action\n\n\n      returnValue = fire('end');\n    }\n\n    if (returnValue === false) {\n      fire('rejected');\n    }\n\n    previousContext = cleanup(returnValue !== true); // last event to be fired when all drag operations are done\n    // at this point in time no drag operation is in progress anymore\n\n    fire('ended', previousContext);\n  } // cancel active drag operation if the user presses\n  // the ESC key on the keyboard\n\n\n  function checkCancel(event) {\n    if (event.which === 27) {\n      preventDefault(event);\n      cancel();\n    }\n  } // prevent ghost click that might occur after a finished\n  // drag and drop session\n\n\n  function trapClickAndEnd(event) {\n    var untrap; // trap the click in case we are part of an active\n    // drag operation. This will effectively prevent\n    // the ghost click that cannot be canceled otherwise.\n\n    if (context.active) {\n      untrap = installClickTrap(eventBus); // remove trap after minimal delay\n\n      setTimeout(untrap, 400); // prevent default action (click)\n\n      preventDefault(event);\n    }\n\n    end(event);\n  }\n\n  function trapTouch(event) {\n    move(event);\n  } // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)\n  // properties during hover and out and fire {prefix}.hover and {prefix}.out properties\n  // respectively\n\n\n  function hover(event) {\n    var payload = context.payload;\n    payload.hoverGfx = event.gfx;\n    payload.hover = event.element;\n    fire('hover');\n  }\n\n  function out(event) {\n    fire('out');\n    var payload = context.payload;\n    payload.hoverGfx = null;\n    payload.hover = null;\n  } // life-cycle methods\n\n\n  function cancel(restore) {\n    var previousContext;\n\n    if (!context) {\n      return;\n    }\n\n    var wasActive = context.active;\n\n    if (wasActive) {\n      fire('cancel');\n    }\n\n    previousContext = cleanup(restore);\n\n    if (wasActive) {\n      // last event to be fired when all drag operations are done\n      // at this point in time no drag operation is in progress anymore\n      fire('canceled', previousContext);\n    }\n  }\n\n  function cleanup(restore) {\n    var previousContext, endDrag;\n    fire('cleanup'); // reset cursor\n\n    cursorUnset();\n\n    if (context.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    } // reset dom listeners\n\n\n    domEvent.unbind(document, 'mousemove', move);\n    domEvent.unbind(document, 'dragstart', preventDefault);\n    domEvent.unbind(document, 'selectstart', preventDefault);\n    domEvent.unbind(document, 'mousedown', endDrag, true);\n    domEvent.unbind(document, 'mouseup', endDrag, true);\n    domEvent.unbind(document, 'keyup', checkCancel);\n    domEvent.unbind(document, 'touchstart', trapTouch, true);\n    domEvent.unbind(document, 'touchcancel', cancel, true);\n    domEvent.unbind(document, 'touchmove', move, true);\n    domEvent.unbind(document, 'touchend', end, true);\n    eventBus.off('element.hover', hover);\n    eventBus.off('element.out', out); // remove drag marker on root element\n\n    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS); // restore selection, unless it has changed\n\n    var previousSelection = context.payload.previousSelection;\n\n    if (restore !== false && previousSelection && !selection.get().length) {\n      selection.select(previousSelection);\n    }\n\n    previousContext = context;\n    context = null;\n    return previousContext;\n  }\n  /**\n   * Initialize a drag operation.\n   *\n   * If `localPosition` is given, drag events will be emitted\n   * relative to it.\n   *\n   * @param {MouseEvent|TouchEvent} [event]\n   * @param {Point} [localPosition] actual diagram local position this drag operation should start at\n   * @param {String} prefix\n   * @param {Object} [options]\n   */\n\n\n  function init(event, relativeTo, prefix, options) {\n    // only one drag operation may be active, at a time\n    if (context) {\n      cancel(false);\n    }\n\n    if (typeof relativeTo === 'string') {\n      options = prefix;\n      prefix = relativeTo;\n      relativeTo = null;\n    }\n\n    options = assign({}, defaultOptions, options || {});\n    var data = options.data || {},\n        originalEvent,\n        globalStart,\n        localStart,\n        endDrag,\n        isTouch;\n\n    if (options.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n\n    if (event) {\n      originalEvent = getOriginal(event) || event;\n      globalStart = toPoint(event);\n      stopPropagation(event); // prevent default browser dragging behavior\n\n      if (originalEvent.type === 'dragstart') {\n        preventDefault(originalEvent);\n      }\n    } else {\n      originalEvent = null;\n      globalStart = {\n        x: 0,\n        y: 0\n      };\n    }\n\n    localStart = toLocalPoint(globalStart);\n\n    if (!relativeTo) {\n      relativeTo = localStart;\n    }\n\n    isTouch = isTouchEvent(originalEvent);\n    context = assign({\n      prefix: prefix,\n      data: data,\n      payload: {},\n      globalStart: globalStart,\n      displacement: deltaPos(relativeTo, localStart),\n      localStart: localStart,\n      isTouch: isTouch\n    }, options); // skip dom registration if trigger\n    // is set to manual (during testing)\n\n    if (!options.manual) {\n      // add dom listeners\n      if (isTouch) {\n        domEvent.bind(document, 'touchstart', trapTouch, true);\n        domEvent.bind(document, 'touchcancel', cancel, true);\n        domEvent.bind(document, 'touchmove', move, true);\n        domEvent.bind(document, 'touchend', end, true);\n      } else {\n        // assume we use the mouse to interact per default\n        domEvent.bind(document, 'mousemove', move); // prevent default browser drag and text selection behavior\n\n        domEvent.bind(document, 'dragstart', preventDefault);\n        domEvent.bind(document, 'selectstart', preventDefault);\n        domEvent.bind(document, 'mousedown', endDrag, true);\n        domEvent.bind(document, 'mouseup', endDrag, true);\n      }\n\n      domEvent.bind(document, 'keyup', checkCancel);\n      eventBus.on('element.hover', hover);\n      eventBus.on('element.out', out);\n    }\n\n    fire('init');\n\n    if (options.autoActivate) {\n      move(event, true);\n    }\n  } // cancel on diagram destruction\n\n\n  eventBus.on('diagram.destroy', cancel); // API\n\n  this.init = init;\n  this.move = move;\n  this.hover = hover;\n  this.out = out;\n  this.end = end;\n  this.cancel = cancel; // for introspection\n\n  this.context = function () {\n    return context;\n  };\n\n  this.setOptions = function (options) {\n    assign(defaultOptions, options);\n  };\n}\nDragging.$inject = ['eventBus', 'canvas', 'selection'];","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/features/dragging/Dragging.js"],"names":["round","Math","assign","event","domEvent","getOriginal","toPoint","stopPropagation","set","cursorSet","unset","cursorUnset","install","installClickTrap","delta","deltaPos","DRAG_ACTIVE_CLS","preventDefault","isTouchEvent","TouchEvent","getLength","point","sqrt","pow","x","y","Dragging","eventBus","canvas","selection","defaultOptions","threshold","trapClick","context","toLocalPoint","globalPosition","viewbox","clientRect","_container","getBoundingClientRect","left","scale","top","fire","type","dragContext","createEvent","payload","data","isTouch","prefix","move","activate","displacement","globalStart","globalCurrent","globalDelta","localStart","localCurrent","localDelta","active","dx","dy","originalEvent","cancel","keepSelection","previousSelection","get","select","cursor","addMarker","getRootElement","end","previousContext","returnValue","cleanup","checkCancel","which","trapClickAndEnd","untrap","setTimeout","trapTouch","hover","hoverGfx","gfx","element","out","restore","wasActive","endDrag","unbind","document","off","removeMarker","length","init","relativeTo","options","manual","bind","on","autoActivate","setOptions","$inject"],"mappings":"AAAA;AAEA,IAAIA,KAAK,GAAGC,IAAI,CAACD,KAAjB;AAEA,SAASE,MAAT,QAAuB,UAAvB;AAEA,SACEC,KAAK,IAAIC,QADX,QAEO,SAFP;AAIA,SACEC,WADF,EAEEC,OAFF,EAGEC,eAHF,QAIO,kBAJP;AAMA,SACEC,GAAG,IAAIC,SADT,EAEEC,KAAK,IAAIC,WAFX,QAGO,mBAHP;AAKA,SACEC,OAAO,IAAIC,gBADb,QAEO,sBAFP;AAIA,SACEC,KAAK,IAAIC,QADX,QAEO,yBAFP;AAIA,IAAIC,eAAe,GAAG,iBAAtB;;AAGA,SAASC,cAAT,CAAwBd,KAAxB,EAA+B;AAC7BA,EAAAA,KAAK,CAACc,cAAN;AACD;;AAED,SAASC,YAAT,CAAsBf,KAAtB,EAA6B;AAC3B;AACA;AACA,SAAO,OAAOgB,UAAP,KAAsB,WAAtB,IAAqChB,KAAK,YAAYgB,UAA7D;AACD;;AAED,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,SAAOpB,IAAI,CAACqB,IAAL,CAAUrB,IAAI,CAACsB,GAAL,CAASF,KAAK,CAACG,CAAf,EAAkB,CAAlB,IAAuBvB,IAAI,CAACsB,GAAL,CAASF,KAAK,CAACI,CAAf,EAAkB,CAAlB,CAAjC,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe,SAASC,QAAT,CAAkBC,QAAlB,EAA4BC,MAA5B,EAAoCC,SAApC,EAA+C;AAE5D,MAAIC,cAAc,GAAG;AACnBC,IAAAA,SAA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","sourcesContent":["/* global TouchEvent */\n\nvar round = Math.round;\n\nimport { assign } from 'min-dash';\n\nimport {\n  event as domEvent\n} from 'min-dom';\n\nimport {\n  getOriginal,\n  toPoint,\n  stopPropagation\n} from '../../util/Event';\n\nimport {\n  set as cursorSet,\n  unset as cursorUnset\n} from '../../util/Cursor';\n\nimport {\n  install as installClickTrap\n} from '../../util/ClickTrap';\n\nimport {\n  delta as deltaPos\n} from '../../util/PositionUtil';\n\nvar DRAG_ACTIVE_CLS = 'djs-drag-active';\n\n\nfunction preventDefault(event) {\n  event.preventDefault();\n}\n\nfunction isTouchEvent(event) {\n  // check for TouchEvent being available first\n  // (i.e. not available on desktop Firefox)\n  return typeof TouchEvent !== 'undefined' && event instanceof TouchEvent;\n}\n\nfunction getLength(point) {\n  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n}\n\n/**\n * A helper that fires canvas localized drag events and realizes\n * the general \"drag-and-drop\" look and feel.\n *\n * Calling {@link Dragging#activate} activates dragging on a canvas.\n *\n * It provides the following:\n *\n *   * emits life cycle events, namespaced with a prefix assigned\n *     during dragging activation\n *   * sets and restores the cursor\n *   * sets and restores the selection\n *   * ensures there can be only one drag operation active at a time\n *\n * Dragging may be canceled manually by calling {@link Dragging#cancel}\n * or by pressing ESC.\n *\n *\n * ## Life-cycle events\n *\n * Dragging can be in three different states, off, initialized\n * and active.\n *\n * (1) off: no dragging operation is in progress\n * (2) initialized: a new drag operation got initialized but not yet\n *                  started (i.e. because of no initial move)\n * (3) started: dragging is in progress\n *\n * Eventually dragging will be off again after a drag operation has\n * been ended or canceled via user click or ESC key press.\n *\n * To indicate transitions between these states dragging emits generic\n * life-cycle events with the `drag.` prefix _and_ events namespaced\n * to a prefix choosen by a user during drag initialization.\n *\n * The following events are emitted (appropriately prefixed) via\n * the {@link EventBus}.\n *\n * * `init`\n * * `start`\n * * `move`\n * * `end`\n * * `ended` (dragging already in off state)\n * * `cancel` (only if previously started)\n * * `canceled` (dragging already in off state, only if previously started)\n * * `cleanup`\n *\n *\n * @example\n *\n * function MyDragComponent(eventBus, dragging) {\n *\n *   eventBus.on('mydrag.start', function(event) {\n *     console.log('yes, we start dragging');\n *   });\n *\n *   eventBus.on('mydrag.move', function(event) {\n *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);\n *\n *     // local drag data is passed with the event\n *     event.context.foo; // \"BAR\"\n *\n *     // the original mouse event, too\n *     event.originalEvent; // MouseEvent(...)\n *   });\n *\n *   eventBus.on('element.click', function(event) {\n *     dragging.init(event, 'mydrag', {\n *       cursor: 'grabbing',\n *       data: {\n *         context: {\n *           foo: \"BAR\"\n *         }\n *       }\n *     });\n *   });\n * }\n */\nexport default function Dragging(eventBus, canvas, selection) {\n\n  var defaultOptions = {\n    threshold: 5,\n    trapClick: true\n  };\n\n  // the currently active drag operation\n  // dragging is active as soon as this context exists.\n  //\n  // it is visually _active_ only when a context.active flag is set to true.\n  var context;\n\n  /* convert a global event into local coordinates */\n  function toLocalPoint(globalPosition) {\n\n    var viewbox = canvas.viewbox();\n\n    var clientRect = canvas._container.getBoundingClientRect();\n\n    return {\n      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,\n      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale\n    };\n  }\n\n  // helpers\n\n  function fire(type, dragContext) {\n    dragContext = dragContext || context;\n\n    var event = eventBus.createEvent(\n      assign(\n        {},\n        dragContext.payload,\n        dragContext.data,\n        { isTouch: dragContext.isTouch }\n      )\n    );\n\n    // default integration\n    if (eventBus.fire('drag.' + type, event) === false) {\n      return false;\n    }\n\n    return eventBus.fire(dragContext.prefix + '.' + type, event);\n  }\n\n  // event listeners\n\n  function move(event, activate) {\n    var payload = context.payload,\n        displacement = context.displacement;\n\n    var globalStart = context.globalStart,\n        globalCurrent = toPoint(event),\n        globalDelta = deltaPos(globalCurrent, globalStart);\n\n    var localStart = context.localStart,\n        localCurrent = toLocalPoint(globalCurrent),\n        localDelta = deltaPos(localCurrent, localStart);\n\n\n    // activate context explicitly or once threshold is reached\n    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {\n\n      // fire start event with original\n      // starting coordinates\n\n      assign(payload, {\n        x: round(localStart.x + displacement.x),\n        y: round(localStart.y + displacement.y),\n        dx: 0,\n        dy: 0\n      }, { originalEvent: event });\n\n      if (false === fire('start')) {\n        return cancel();\n      }\n\n      context.active = true;\n\n      // unset selection and remember old selection\n      // the previous (old) selection will always passed\n      // with the event via the event.previousSelection property\n      if (!context.keepSelection) {\n        payload.previousSelection = selection.get();\n        selection.select(null);\n      }\n\n      // allow custom cursor\n      if (context.cursor) {\n        cursorSet(context.cursor);\n      }\n\n      // indicate dragging via marker on root element\n      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n    }\n\n    stopPropagation(event);\n\n    if (context.active) {\n\n      // update payload with actual coordinates\n      assign(payload, {\n        x: round(localCurrent.x + displacement.x),\n        y: round(localCurrent.y + displacement.y),\n        dx: round(localDelta.x),\n        dy: round(localDelta.y)\n      }, { originalEvent: event });\n\n      // emit move event\n      fire('move');\n    }\n  }\n\n  function end(event) {\n    var previousContext,\n        returnValue = true;\n\n    if (context.active) {\n\n      if (event) {\n        context.payload.originalEvent = event;\n\n        // suppress original event (click, ...)\n        // because we just ended a drag operation\n        stopPropagation(event);\n      }\n\n      // implementations may stop restoring the\n      // original state (selections, ...) by preventing the\n      // end events default action\n      returnValue = fire('end');\n    }\n\n    if (returnValue === false) {\n      fire('rejected');\n    }\n\n    previousContext = cleanup(returnValue !== true);\n\n    // last event to be fired when all drag operations are done\n    // at this point in time no drag operation is in progress anymore\n    fire('ended', previousContext);\n  }\n\n\n  // cancel active drag operation if the user presses\n  // the ESC key on the keyboard\n\n  function checkCancel(event) {\n\n    if (event.which === 27) {\n      preventDefault(event);\n\n      cancel();\n    }\n  }\n\n\n  // prevent ghost click that might occur after a finished\n  // drag and drop session\n\n  function trapClickAndEnd(event) {\n\n    var untrap;\n\n    // trap the click in case we are part of an active\n    // drag operation. This will effectively prevent\n    // the ghost click that cannot be canceled otherwise.\n    if (context.active) {\n\n      untrap = installClickTrap(eventBus);\n\n      // remove trap after minimal delay\n      setTimeout(untrap, 400);\n\n      // prevent default action (click)\n      preventDefault(event);\n    }\n\n    end(event);\n  }\n\n  function trapTouch(event) {\n    move(event);\n  }\n\n  // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)\n  // properties during hover and out and fire {prefix}.hover and {prefix}.out properties\n  // respectively\n\n  function hover(event) {\n    var payload = context.payload;\n\n    payload.hoverGfx = event.gfx;\n    payload.hover = event.element;\n\n    fire('hover');\n  }\n\n  function out(event) {\n    fire('out');\n\n    var payload = context.payload;\n\n    payload.hoverGfx = null;\n    payload.hover = null;\n  }\n\n\n  // life-cycle methods\n\n  function cancel(restore) {\n    var previousContext;\n\n    if (!context) {\n      return;\n    }\n\n    var wasActive = context.active;\n\n    if (wasActive) {\n      fire('cancel');\n    }\n\n    previousContext = cleanup(restore);\n\n    if (wasActive) {\n      // last event to be fired when all drag operations are done\n      // at this point in time no drag operation is in progress anymore\n      fire('canceled', previousContext);\n    }\n  }\n\n  function cleanup(restore) {\n    var previousContext,\n        endDrag;\n\n    fire('cleanup');\n\n    // reset cursor\n    cursorUnset();\n\n    if (context.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n\n    // reset dom listeners\n    domEvent.unbind(document, 'mousemove', move);\n\n    domEvent.unbind(document, 'dragstart', preventDefault);\n    domEvent.unbind(document, 'selectstart', preventDefault);\n\n    domEvent.unbind(document, 'mousedown', endDrag, true);\n    domEvent.unbind(document, 'mouseup', endDrag, true);\n\n    domEvent.unbind(document, 'keyup', checkCancel);\n\n    domEvent.unbind(document, 'touchstart', trapTouch, true);\n    domEvent.unbind(document, 'touchcancel', cancel, true);\n    domEvent.unbind(document, 'touchmove', move, true);\n    domEvent.unbind(document, 'touchend', end, true);\n\n    eventBus.off('element.hover', hover);\n    eventBus.off('element.out', out);\n\n    // remove drag marker on root element\n    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);\n\n    // restore selection, unless it has changed\n    var previousSelection = context.payload.previousSelection;\n\n    if (restore !== false && previousSelection && !selection.get().length) {\n      selection.select(previousSelection);\n    }\n\n    previousContext = context;\n\n    context = null;\n\n    return previousContext;\n  }\n\n  /**\n   * Initialize a drag operation.\n   *\n   * If `localPosition` is given, drag events will be emitted\n   * relative to it.\n   *\n   * @param {MouseEvent|TouchEvent} [event]\n   * @param {Point} [localPosition] actual diagram local position this drag operation should start at\n   * @param {String} prefix\n   * @param {Object} [options]\n   */\n  function init(event, relativeTo, prefix, options) {\n\n    // only one drag operation may be active, at a time\n    if (context) {\n      cancel(false);\n    }\n\n    if (typeof relativeTo === 'string') {\n      options = prefix;\n      prefix = relativeTo;\n      relativeTo = null;\n    }\n\n    options = assign({}, defaultOptions, options || {});\n\n    var data = options.data || {},\n        originalEvent,\n        globalStart,\n        localStart,\n        endDrag,\n        isTouch;\n\n    if (options.trapClick) {\n      endDrag = trapClickAndEnd;\n    } else {\n      endDrag = end;\n    }\n\n    if (event) {\n      originalEvent = getOriginal(event) || event;\n      globalStart = toPoint(event);\n\n      stopPropagation(event);\n\n      // prevent default browser dragging behavior\n      if (originalEvent.type === 'dragstart') {\n        preventDefault(originalEvent);\n      }\n    } else {\n      originalEvent = null;\n      globalStart = { x: 0, y: 0 };\n    }\n\n    localStart = toLocalPoint(globalStart);\n\n    if (!relativeTo) {\n      relativeTo = localStart;\n    }\n\n    isTouch = isTouchEvent(originalEvent);\n\n    context = assign({\n      prefix: prefix,\n      data: data,\n      payload: {},\n      globalStart: globalStart,\n      displacement: deltaPos(relativeTo, localStart),\n      localStart: localStart,\n      isTouch: isTouch\n    }, options);\n\n    // skip dom registration if trigger\n    // is set to manual (during testing)\n    if (!options.manual) {\n\n      // add dom listeners\n\n      if (isTouch) {\n        domEvent.bind(document, 'touchstart', trapTouch, true);\n        domEvent.bind(document, 'touchcancel', cancel, true);\n        domEvent.bind(document, 'touchmove', move, true);\n        domEvent.bind(document, 'touchend', end, true);\n      } else {\n        // assume we use the mouse to interact per default\n        domEvent.bind(document, 'mousemove', move);\n\n        // prevent default browser drag and text selection behavior\n        domEvent.bind(document, 'dragstart', preventDefault);\n        domEvent.bind(document, 'selectstart', preventDefault);\n\n        domEvent.bind(document, 'mousedown', endDrag, true);\n        domEvent.bind(document, 'mouseup', endDrag, true);\n      }\n\n      domEvent.bind(document, 'keyup', checkCancel);\n\n      eventBus.on('element.hover', hover);\n      eventBus.on('element.out', out);\n    }\n\n    fire('init');\n\n    if (options.autoActivate) {\n      move(event, true);\n    }\n  }\n\n  // cancel on diagram destruction\n  eventBus.on('diagram.destroy', cancel);\n\n\n  // API\n\n  this.init = init;\n  this.move = move;\n  this.hover = hover;\n  this.out = out;\n  this.end = end;\n\n  this.cancel = cancel;\n\n  // for introspection\n\n  this.context = function() {\n    return context;\n  };\n\n  this.setOptions = function(options) {\n    assign(defaultOptions, options);\n  };\n}\n\nDragging.$inject = [\n  'eventBus',\n  'canvas',\n  'selection'\n];\n"]},"metadata":{},"sourceType":"module"}