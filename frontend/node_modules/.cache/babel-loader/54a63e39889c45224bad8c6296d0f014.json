{"ast":null,"code":"var abs = Math.abs,\n    round = Math.round;\n/**\n * Snap value to a collection of reference values.\n *\n * @param  {Number} value\n * @param  {Array<Number>} values\n * @param  {Number} [tolerance=10]\n *\n * @return {Number} the value we snapped to or null, if none snapped\n */\n\nexport function snapTo(value, values, tolerance) {\n  tolerance = tolerance === undefined ? 10 : tolerance;\n  var idx, snapValue;\n\n  for (idx = 0; idx < values.length; idx++) {\n    snapValue = values[idx];\n\n    if (abs(snapValue - value) <= tolerance) {\n      return snapValue;\n    }\n  }\n}\nexport function topLeft(bounds) {\n  return {\n    x: bounds.x,\n    y: bounds.y\n  };\n}\nexport function mid(bounds, defaultValue) {\n  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {\n    return defaultValue;\n  }\n\n  return {\n    x: round(bounds.x + bounds.width / 2),\n    y: round(bounds.y + bounds.height / 2)\n  };\n}\nexport function bottomRight(bounds) {\n  return {\n    x: bounds.x + bounds.width,\n    y: bounds.y + bounds.height\n  };\n}\n/**\n * Retrieve the snap state of the given event.\n *\n * @param  {Event} event\n * @param  {String} axis\n *\n * @return {Boolean} the snapped state\n *\n */\n\nexport function isSnapped(event, axis) {\n  var snapped = event.snapped;\n\n  if (!snapped) {\n    return false;\n  }\n\n  if (typeof axis === 'string') {\n    return snapped[axis];\n  }\n\n  return snapped.x && snapped.y;\n}\n/**\n * Set the given event as snapped.\n *\n * This method may change the x and/or y position of the shape\n * from the given event!\n *\n * @param {Event} event\n * @param {String} axis\n * @param {Number|Boolean} value\n *\n * @return {Number} old value\n */\n\nexport function setSnapped(event, axis, value) {\n  if (typeof axis !== 'string') {\n    throw new Error('axis must be in [x, y]');\n  }\n\n  if (typeof value !== 'number' && value !== false) {\n    throw new Error('value must be Number or false');\n  }\n\n  var delta,\n      previousValue = event[axis];\n  var snapped = event.snapped = event.snapped || {};\n\n  if (value === false) {\n    snapped[axis] = false;\n  } else {\n    snapped[axis] = true;\n    delta = value - previousValue;\n    event[axis] += delta;\n    event['d' + axis] += delta;\n  }\n\n  return previousValue;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/features/snapping/SnapUtil.js"],"names":["abs","Math","round","snapTo","value","values","tolerance","undefined","idx","snapValue","length","topLeft","bounds","x","y","mid","defaultValue","isNaN","width","height","bottomRight","isSnapped","event","axis","snapped","setSnapped","Error","delta","previousValue"],"mappings":"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","sourcesContent":["var abs = Math.abs,\n    round = Math.round;\n\n\n/**\n * Snap value to a collection of reference values.\n *\n * @param  {Number} value\n * @param  {Array<Number>} values\n * @param  {Number} [tolerance=10]\n *\n * @return {Number} the value we snapped to or null, if none snapped\n */\nexport function snapTo(value, values, tolerance) {\n  tolerance = tolerance === undefined ? 10 : tolerance;\n\n  var idx, snapValue;\n\n  for (idx = 0; idx < values.length; idx++) {\n    snapValue = values[idx];\n\n    if (abs(snapValue - value) <= tolerance) {\n      return snapValue;\n    }\n  }\n}\n\n\nexport function topLeft(bounds) {\n  return {\n    x: bounds.x,\n    y: bounds.y\n  };\n}\n\n\nexport function mid(bounds, defaultValue) {\n\n  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {\n    return defaultValue;\n  }\n\n  return {\n    x: round(bounds.x + bounds.width / 2),\n    y: round(bounds.y + bounds.height / 2)\n  };\n}\n\n\nexport function bottomRight(bounds) {\n  return {\n    x: bounds.x + bounds.width,\n    y: bounds.y + bounds.height\n  };\n}\n\n\n/**\n * Retrieve the snap state of the given event.\n *\n * @param  {Event} event\n * @param  {String} axis\n *\n * @return {Boolean} the snapped state\n *\n */\nexport function isSnapped(event, axis) {\n  var snapped = event.snapped;\n\n  if (!snapped) {\n    return false;\n  }\n\n  if (typeof axis === 'string') {\n    return snapped[axis];\n  }\n\n  return snapped.x && snapped.y;\n}\n\n\n/**\n * Set the given event as snapped.\n *\n * This method may change the x and/or y position of the shape\n * from the given event!\n *\n * @param {Event} event\n * @param {String} axis\n * @param {Number|Boolean} value\n *\n * @return {Number} old value\n */\nexport function setSnapped(event, axis, value) {\n  if (typeof axis !== 'string') {\n    throw new Error('axis must be in [x, y]');\n  }\n\n  if (typeof value !== 'number' && value !== false) {\n    throw new Error('value must be Number or false');\n  }\n\n  var delta,\n      previousValue = event[axis];\n\n  var snapped = event.snapped = (event.snapped || {});\n\n\n  if (value === false) {\n    snapped[axis] = false;\n  } else {\n    snapped[axis] = true;\n\n    delta = value - previousValue;\n\n    event[axis] += delta;\n    event['d' + axis] += delta;\n  }\n\n  return previousValue;\n}"]},"metadata":{},"sourceType":"module"}