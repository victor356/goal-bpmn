{"ast":null,"code":"import { getDirection } from './SpaceUtil';\nimport { set as cursorSet } from '../../util/Cursor';\nimport { hasPrimaryModifier } from '../../util/Mouse';\nvar abs = Math.abs,\n    round = Math.round;\nvar HIGH_PRIORITY = 1500,\n    SPACE_TOOL_CURSOR = 'crosshair';\nvar AXIS_TO_DIMENSION = {\n  x: 'width',\n  y: 'height'\n},\n    AXIS_INVERTED = {\n  x: 'y',\n  y: 'x'\n};\nimport { selfAndAllChildren as getAllChildren } from '../../util/Elements';\nimport { assign, forEach } from 'min-dash';\n/**\n * A tool that allows users to create and remove space in a diagram.\n *\n * The tool needs to be activated manually via {@link SpaceTool#activate(MouseEvent)}.\n */\n\nexport default function SpaceTool(eventBus, dragging, canvas, modeling, rules, toolManager) {\n  this._canvas = canvas;\n  this._dragging = dragging;\n  this._modeling = modeling;\n  this._rules = rules;\n  this._toolManager = toolManager;\n  var self = this;\n  toolManager.registerTool('space', {\n    tool: 'spaceTool.selection',\n    dragging: 'spaceTool'\n  });\n  eventBus.on('spaceTool.selection.end', function (event) {\n    var target = event.originalEvent.target; // only reactive on diagram click\n    // on some occasions, event.hover is not set and we have to check if the target is an svg\n\n    if (!event.hover && !(target instanceof SVGElement)) {\n      return;\n    }\n\n    eventBus.once('spaceTool.selection.ended', function () {\n      self.activateMakeSpace(event.originalEvent);\n    });\n  });\n  eventBus.on('spaceTool.move', HIGH_PRIORITY, function (event) {\n    var context = event.context;\n\n    if (!context.initialized) {\n      context.initialized = self.initializeMakeSpace(event, context);\n    }\n  });\n  eventBus.on('spaceTool.end', function (event) {\n    var context = event.context,\n        axis = context.axis,\n        direction = context.direction,\n        movingShapes = context.movingShapes,\n        resizingShapes = context.resizingShapes; // skip if create space has not been initialized yet\n\n    if (!context.initialized) {\n      return;\n    }\n\n    var delta = {\n      x: round(event.dx),\n      y: round(event.dy)\n    };\n    delta[AXIS_INVERTED[axis]] = 0;\n    var insideBounds = true; // check if the space tool cursor is inside of bounds of\n    // any of the shapes that would be resized.\n\n    forEach(resizingShapes, function (shape) {\n      if (direction === 'w' && event.x > shape.x + shape.width || direction === 'e' && event.x < shape.x || direction === 'n' && event.y > shape.y + shape.height || direction === 's' && event.y < shape.y) {\n        insideBounds = false;\n        return;\n      }\n    });\n\n    if (insideBounds) {\n      // make space only if the cursor is inside bounds\n      self.makeSpace(movingShapes, resizingShapes, delta, direction);\n    }\n\n    eventBus.once('spaceTool.ended', function (event) {\n      // reactivate space tool after usage\n      self.activateSelection(event.originalEvent, true, true);\n    });\n  });\n}\nSpaceTool.$inject = ['eventBus', 'dragging', 'canvas', 'modeling', 'rules', 'toolManager'];\n/**\n * Activate space tool selection\n *\n * @param  {MouseEvent} event\n * @param  {Boolean} autoActivate\n */\n\nSpaceTool.prototype.activateSelection = function (event, autoActivate, reactivate) {\n  this._dragging.init(event, 'spaceTool.selection', {\n    trapClick: false,\n    cursor: SPACE_TOOL_CURSOR,\n    autoActivate: autoActivate,\n    data: {\n      context: {\n        reactivate: reactivate\n      }\n    }\n  });\n};\n/**\n * Activate make space\n *\n * @param  {MouseEvent} event\n */\n\n\nSpaceTool.prototype.activateMakeSpace = function (event) {\n  this._dragging.init(event, 'spaceTool', {\n    autoActivate: true,\n    cursor: SPACE_TOOL_CURSOR,\n    data: {\n      context: {}\n    }\n  });\n};\n/**\n * Actually make space on the diagram\n *\n * @param  {Array<djs.model.Shape>} movingShapes\n * @param  {Array<djs.model.Shape>} resizingShapes\n * @param  {Point} delta\n * @param  {String} direction\n */\n\n\nSpaceTool.prototype.makeSpace = function (movingShapes, resizingShapes, delta, direction) {\n  return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction);\n};\n/**\n * Initialize make space and return true if that was successful.\n *\n * @param {Event} event\n * @param {Object} context\n *\n * @return {Boolean} true, if successful\n */\n\n\nSpaceTool.prototype.initializeMakeSpace = function (event, context) {\n  var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',\n      offset = event['d' + axis],\n      // start point of create space operation\n  spacePos = event[axis] - offset;\n\n  if (abs(offset) < 5) {\n    return false;\n  } // invert the offset in order to remove space when moving left\n\n\n  if (offset < 0) {\n    offset *= -1;\n  } // inverts the offset to choose the shapes\n  // on the opposite side of the resizer if\n  // a key modifier is pressed\n\n\n  if (hasPrimaryModifier(event)) {\n    offset *= -1;\n  }\n\n  var rootShape = this._canvas.getRootElement();\n\n  var allShapes = getAllChildren(rootShape, true);\n  var adjustments = this.calculateAdjustments(allShapes, axis, offset, spacePos); // store data in context\n\n  assign(context, adjustments, {\n    axis: axis,\n    direction: getDirection(axis, offset)\n  });\n  cursorSet('resize-' + (axis === 'x' ? 'ew' : 'ns'));\n  return true;\n};\n/**\n * Calculate adjustments needed when making space\n *\n * @param  {Array<djs.model.Shape>} elements\n * @param  {String} axis\n * @param  {Number} offset\n * @param  {Number} spacePos\n *\n * @return {Object}\n */\n\n\nSpaceTool.prototype.calculateAdjustments = function (elements, axis, offset, spacePos) {\n  var movingShapes = [],\n      resizingShapes = [];\n  var rules = this._rules; // collect all elements that need to be moved _AND_\n  // resized given on the initial create space position\n\n  elements.forEach(function (shape) {\n    var shapeStart = shape[axis],\n        shapeEnd = shapeStart + shape[AXIS_TO_DIMENSION[axis]]; // checking if it's root\n\n    if (!shape.parent) {\n      return;\n    } // checking if it's a shape\n\n\n    if (shape.waypoints) {\n      return;\n    } // shape after spacePos\n\n\n    if (offset > 0 && shapeStart > spacePos) {\n      return movingShapes.push(shape);\n    } // shape before spacePos\n\n\n    if (offset < 0 && shapeEnd < spacePos) {\n      return movingShapes.push(shape);\n    } // shape on top of spacePos, resize only if allowed\n\n\n    if (shapeStart < spacePos && shapeEnd > spacePos && rules.allowed('shape.resize', {\n      shape: shape\n    })) {\n      return resizingShapes.push(shape);\n    }\n  });\n  return {\n    movingShapes: movingShapes,\n    resizingShapes: resizingShapes\n  };\n};\n\nSpaceTool.prototype.toggle = function () {\n  if (this.isActive()) {\n    this._dragging.cancel();\n  } else {\n    this.activateSelection();\n  }\n};\n\nSpaceTool.prototype.isActive = function () {\n  var context = this._dragging.context();\n\n  return context && /^spaceTool/.test(context.prefix);\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/diagram-js/lib/features/space-tool/SpaceTool.js"],"names":["getDirection","set","cursorSet","hasPrimaryModifier","abs","Math","round","HIGH_PRIORITY","SPACE_TOOL_CURSOR","AXIS_TO_DIMENSION","x","y","AXIS_INVERTED","selfAndAllChildren","getAllChildren","assign","forEach","SpaceTool","eventBus","dragging","canvas","modeling","rules","toolManager","_canvas","_dragging","_modeling","_rules","_toolManager","self","registerTool","tool","on","event","target","originalEvent","hover","SVGElement","once","activateMakeSpace","context","initialized","initializeMakeSpace","axis","direction","movingShapes","resizingShapes","delta","dx","dy","insideBounds","shape","width","height","makeSpace","activateSelection","$inject","prototype","autoActivate","reactivate","init","trapClick","cursor","data","createSpace","offset","spacePos","rootShape","getRootElement","allShapes","adjustments","calculateAdjustments","elements","shapeStart","shapeEnd","parent","waypoints","push","allowed","toggle","isActive","cancel","test","prefix"],"mappings":"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","sourcesContent":["import {\n  getDirection\n} from './SpaceUtil';\n\nimport {\n  set as cursorSet\n} from '../../util/Cursor';\n\nimport {\n  hasPrimaryModifier\n} from '../../util/Mouse';\n\nvar abs = Math.abs,\n    round = Math.round;\n\nvar HIGH_PRIORITY = 1500,\n    SPACE_TOOL_CURSOR = 'crosshair';\n\nvar AXIS_TO_DIMENSION = { x: 'width', y: 'height' },\n    AXIS_INVERTED = { x: 'y', y: 'x' };\n\nimport {\n  selfAndAllChildren as getAllChildren\n} from '../../util/Elements';\n\nimport {\n  assign,\n  forEach\n} from 'min-dash';\n\n\n/**\n * A tool that allows users to create and remove space in a diagram.\n *\n * The tool needs to be activated manually via {@link SpaceTool#activate(MouseEvent)}.\n */\nexport default function SpaceTool(\n    eventBus, dragging, canvas,\n    modeling, rules, toolManager) {\n\n  this._canvas = canvas;\n  this._dragging = dragging;\n  this._modeling = modeling;\n  this._rules = rules;\n  this._toolManager = toolManager;\n\n  var self = this;\n\n  toolManager.registerTool('space', {\n    tool: 'spaceTool.selection',\n    dragging: 'spaceTool'\n  });\n\n  eventBus.on('spaceTool.selection.end', function(event) {\n    var target = event.originalEvent.target;\n\n    // only reactive on diagram click\n    // on some occasions, event.hover is not set and we have to check if the target is an svg\n    if (!event.hover && !(target instanceof SVGElement)) {\n      return;\n    }\n\n    eventBus.once('spaceTool.selection.ended', function() {\n      self.activateMakeSpace(event.originalEvent);\n    });\n  });\n\n\n  eventBus.on('spaceTool.move', HIGH_PRIORITY , function(event) {\n\n    var context = event.context;\n\n    if (!context.initialized) {\n      context.initialized = self.initializeMakeSpace(event, context);\n    }\n  });\n\n\n  eventBus.on('spaceTool.end', function(event) {\n\n    var context = event.context,\n        axis = context.axis,\n        direction = context.direction,\n        movingShapes = context.movingShapes,\n        resizingShapes = context.resizingShapes;\n\n    // skip if create space has not been initialized yet\n    if (!context.initialized) {\n      return;\n    }\n\n    var delta = { x: round(event.dx), y: round(event.dy) };\n    delta[ AXIS_INVERTED[ axis ] ] = 0;\n\n    var insideBounds = true;\n\n    // check if the space tool cursor is inside of bounds of\n    // any of the shapes that would be resized.\n    forEach(resizingShapes, function(shape) {\n\n      if ((direction === 'w' && event.x > shape.x + shape.width) ||\n          (direction === 'e' && event.x < shape.x) ||\n          (direction === 'n' && event.y > shape.y + shape.height) ||\n          (direction === 's' && event.y < shape.y)) {\n\n        insideBounds = false;\n        return;\n      }\n    });\n\n    if (insideBounds) {\n      // make space only if the cursor is inside bounds\n      self.makeSpace(movingShapes, resizingShapes, delta, direction);\n    }\n\n    eventBus.once('spaceTool.ended', function(event) {\n      // reactivate space tool after usage\n      self.activateSelection(event.originalEvent, true, true);\n    });\n\n  });\n}\n\nSpaceTool.$inject = [\n  'eventBus',\n  'dragging',\n  'canvas',\n  'modeling',\n  'rules',\n  'toolManager'\n];\n\n\n/**\n * Activate space tool selection\n *\n * @param  {MouseEvent} event\n * @param  {Boolean} autoActivate\n */\nSpaceTool.prototype.activateSelection = function(event, autoActivate, reactivate) {\n  this._dragging.init(event, 'spaceTool.selection', {\n    trapClick: false,\n    cursor: SPACE_TOOL_CURSOR,\n    autoActivate: autoActivate,\n    data: {\n      context: {\n        reactivate: reactivate\n      }\n    }\n  });\n};\n\n/**\n * Activate make space\n *\n * @param  {MouseEvent} event\n */\nSpaceTool.prototype.activateMakeSpace = function(event) {\n  this._dragging.init(event, 'spaceTool', {\n    autoActivate: true,\n    cursor: SPACE_TOOL_CURSOR,\n    data: {\n      context: {}\n    }\n  });\n};\n\n/**\n * Actually make space on the diagram\n *\n * @param  {Array<djs.model.Shape>} movingShapes\n * @param  {Array<djs.model.Shape>} resizingShapes\n * @param  {Point} delta\n * @param  {String} direction\n */\nSpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta, direction) {\n  return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction);\n};\n\n/**\n * Initialize make space and return true if that was successful.\n *\n * @param {Event} event\n * @param {Object} context\n *\n * @return {Boolean} true, if successful\n */\nSpaceTool.prototype.initializeMakeSpace = function(event, context) {\n\n  var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',\n      offset = event['d' + axis],\n      // start point of create space operation\n      spacePos = event[axis] - offset;\n\n  if (abs(offset) < 5) {\n    return false;\n  }\n\n  // invert the offset in order to remove space when moving left\n  if (offset < 0) {\n    offset *= -1;\n  }\n\n  // inverts the offset to choose the shapes\n  // on the opposite side of the resizer if\n  // a key modifier is pressed\n  if (hasPrimaryModifier(event)) {\n    offset *= -1;\n  }\n\n  var rootShape = this._canvas.getRootElement();\n\n  var allShapes = getAllChildren(rootShape, true);\n\n  var adjustments = this.calculateAdjustments(allShapes, axis, offset, spacePos);\n\n  // store data in context\n  assign(context, adjustments, {\n    axis: axis,\n    direction: getDirection(axis, offset)\n  });\n\n  cursorSet('resize-' + (axis === 'x' ? 'ew' : 'ns'));\n\n  return true;\n};\n\n/**\n * Calculate adjustments needed when making space\n *\n * @param  {Array<djs.model.Shape>} elements\n * @param  {String} axis\n * @param  {Number} offset\n * @param  {Number} spacePos\n *\n * @return {Object}\n */\nSpaceTool.prototype.calculateAdjustments = function(elements, axis, offset, spacePos) {\n\n  var movingShapes = [],\n      resizingShapes = [];\n\n  var rules = this._rules;\n\n  // collect all elements that need to be moved _AND_\n  // resized given on the initial create space position\n  elements.forEach(function(shape) {\n\n    var shapeStart = shape[axis],\n        shapeEnd = shapeStart + shape[AXIS_TO_DIMENSION[axis]];\n\n    // checking if it's root\n    if (!shape.parent) {\n      return;\n    }\n\n    // checking if it's a shape\n    if (shape.waypoints) {\n      return;\n    }\n\n    // shape after spacePos\n    if (offset > 0 && shapeStart > spacePos) {\n      return movingShapes.push(shape);\n    }\n\n    // shape before spacePos\n    if (offset < 0 && shapeEnd < spacePos) {\n      return movingShapes.push(shape);\n    }\n\n    // shape on top of spacePos, resize only if allowed\n    if (shapeStart < spacePos &&\n        shapeEnd > spacePos &&\n        rules.allowed('shape.resize', { shape: shape })) {\n\n      return resizingShapes.push(shape);\n    }\n  });\n\n  return {\n    movingShapes: movingShapes,\n    resizingShapes: resizingShapes\n  };\n};\n\nSpaceTool.prototype.toggle = function() {\n  if (this.isActive()) {\n    this._dragging.cancel();\n  } else {\n    this.activateSelection();\n  }\n};\n\nSpaceTool.prototype.isActive = function() {\n  var context = this._dragging.context();\n\n  return context && /^spaceTool/.test(context.prefix);\n};\n"]},"metadata":{},"sourceType":"module"}