{"ast":null,"code":"import { isObject, sortBy } from 'min-dash';\nimport { pointDistance } from '../util/Geometry';\nimport intersectPaths from 'path-intersection';\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\nexport function roundPoint(point) {\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Object}\n */\n\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {Object} trbl\n *\n * @return {Bounds}\n */\n\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Point}\n */\n\nexport function getMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n} // orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Bounds} rect\n * @param {Bounds} reference\n * @param {Point|Number} padding\n *\n * @return {String} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\n\nexport function getOrientation(rect, reference, padding) {\n  padding = padding || 0; // make sure we can use an object, too\n  // for individual { x, y } padding\n\n  if (!isObject(padding)) {\n    padding = {\n      x: padding,\n      y: padding\n    };\n  }\n\n  var rectOrientation = asTRBL(rect),\n      referenceOrientation = asTRBL(reference);\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\n  var vertical = top ? 'top' : bottom ? 'bottom' : null,\n      horizontal = left ? 'left' : right ? 'right' : null;\n\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n} // intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {PathDef} elementPath\n * @param {PathDef} linePath\n * @param {Boolean} cropStart crop from start or end\n *\n * @return {Point}\n */\n\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n  var intersections = getIntersections(elementPath, linePath); // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function (i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n      distance = 100 - distance;\n      distance = (distance < 10 ? '0' : '') + distance; // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n\n      return i.segment2 + '#' + distance;\n    });\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n\n  return null;\n}\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/node_modules/diagram-js/lib/layout/LayoutUtil.js"],"names":["isObject","sortBy","pointDistance","intersectPaths","roundBounds","bounds","x","Math","round","y","width","height","roundPoint","point","asTRBL","top","right","bottom","left","asBounds","trbl","getMid","getOrientation","rect","reference","padding","rectOrientation","referenceOrientation","vertical","horizontal","getElementLineIntersection","elementPath","linePath","cropStart","intersections","getIntersections","length","i","distance","floor","t2","segment2","a","b"],"mappings":"AAAA,SACEA,QADF,EAEEC,MAFF,QAGO,UAHP;AAKA,SACEC,aADF,QAEO,kBAFP;AAIA,OAAOC,cAAP,MAA2B,mBAA3B;AAGA,OAAO,SAASC,WAAT,CAAqBC,MAArB,EAA6B;AAClC,SAAO;AACLC,IAAAA,CAAC,EAAEC,IAAI,CAACC,KAAL,CAAWH,MAAM,CAACC,CAAlB,CADE;AAELG,IAAAA,CAAC,EAAEF,IAAI,CAACC,KAAL,CAAWH,MAAM,CAACI,CAAlB,CAFE;AAGLC,IAAAA,KAAK,EAAEH,IAAI,CAACC,KAAL,CAAWH,MAAM,CAACK,KAAlB,CAHF;AAILC,IAAAA,MAAM,EAAEJ,IAAI,CAACC,KAAL,CAAWH,MAAM,CAACM,MAAlB;AAJH,GAAP;AAMD;AAGD,OAAO,SAASC,UAAT,CAAoBC,KAApB,EAA2B;AAEhC,SAAO;AACLP,IAAAA,CAAC,EAAEC,IAAI,CAACC,KAAL,CAAWK,KAAK,CAACP,CAAjB,CADE;AAELG,IAAAA,CAAC,EAAEF,IAAI,CAACC,KAAL,CAAWK,KAAK,CAACJ,CAAjB;AAFE,GAAP;AAID;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,MAAT,CAAgBT,MAAhB,EAAwB;AAC7B,SAAO;AACLU,IAAAA,GAAG,EAAEV,MAAM,CAACI,CADP;AAELO,IAAAA,KAAK,EAAEX,MAAM,CAACC,CAAP,IAAYD,MAAM,CAACK,KAAP,IAAgB,CAA5B,CAFF;AAGLO,IAAAA,MAAM,EAAEZ,MAAM,CAACI,CAAP,IAAYJ,MAAM,CAACM,MAAP,IAAiB,CAA7B,CAHH;AAILO,IAAAA,IAAI,EAAEb,MAAM,CAACC;AAJR,GAAP;AAMD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASa,QAAT,CAAkBC,IAAlB,EAAwB;AAC7B,SAAO;AACLd,IAAAA,CAAC,EAAEc,IAAI,CAACF,IADH;AAELT,IAAAA,CAAC,EAAEW,IAAI,CAACL,GAFH;AAGLL,IAAAA,KAAK,EAAEU,IAAI,CAACJ,KAAL,GAAaI,IAAI,CAACF,IAHpB;AAILP,IAAAA,MAAM,EAAES,IAAI,CAACH,MAAL,GAAcG,IAAI,CAACL;AAJtB,GAAP;AAMD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,MAAT,CAAgBhB,MAAhB,EAAwB;AAC7B,SAAOO,UAAU,CAAC;AAChBN,IAAAA,CAAC,EAAED,MAAM,CAACC,CAAP,GAAW,CAACD,MAAM,CAACK,KAAP,IAAgB,CAAjB,IAAsB,CADpB;AAEhBD,IAAAA,CAAC,EAAEJ,MAAM,CAACI,CAAP,GAAW,CAACJ,MAAM,CAACM,MAAP,IAAiB,CAAlB,IAAuB;AAFrB,GAAD,CAAjB;AAID,C,CAGD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASW,cAAT,CAAwBC,IAAxB,EAA8BC,SAA9B,EAAyCC,OAAzC,EAAkD;AAEvDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,CAArB,CAFuD,CAIvD;AACA;;AACA,MAAI,CAACzB,QAAQ,CAACyB,OAAD,CAAb,EAAwB;AACtBA,IAAAA,OAAO,GAAG;AAAEnB,MAAAA,CAAC,EAAEmB,OAAL;AAAchB,MAAAA,CAAC,EAAEgB;AAAjB,KAAV;AACD;;AAGD,MAAIC,eAAe,GAAGZ,MAAM,CAACS,IAAD,CAA5B;AAAA,MACII,oBAAoB,GAAGb,MAAM,CAACU,SAAD,CADjC;AAGA,MAAIT,GAAG,GAAGW,eAAe,CAACT,MAAhB,GAAyBQ,OAAO,CAAChB,CAAjC,IAAsCkB,oBAAoB,CAACZ,GAArE;AAAA,MACIC,KAAK,GAAGU,eAAe,CAACR,IAAhB,GAAuBO,OAAO,CAACnB,CAA/B,IAAoCqB,oBAAoB,CAACX,KADrE;AAAA,MAEIC,MAAM,GAAGS,eAAe,CAACX,GAAhB,GAAsBU,OAAO,CAAChB,CAA9B,IAAmCkB,oBAAoB,CAACV,MAFrE;AAAA,MAGIC,IAAI,GAAGQ,eAAe,CAACV,KAAhB,GAAwBS,OAAO,CAACnB,CAAhC,IAAqCqB,oBAAoB,CAACT,IAHrE;AAKA,MAAIU,QAAQ,GAAGb,GAAG,GAAG,KAAH,GAAYE,MAAM,GAAG,QAAH,GAAc,IAAlD;AAAA,MACIY,UAAU,GAAGX,IAAI,GAAG,MAAH,GAAaF,KAAK,GAAG,OAAH,GAAa,IADpD;;AAGA,MAAIa,UAAU,IAAID,QAAlB,EAA4B;AAC1B,WAAOA,QAAQ,GAAG,GAAX,GAAiBC,UAAxB;AACD,GAFD,MAEO;AACL,WAAOA,UAAU,IAAID,QAAd,IAA0B,WAAjC;AACD;AACF,C,CAGD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,0BAAT,CAAoCC,WAApC,EAAiDC,QAAjD,EAA2DC,SAA3D,EAAsE;AAE3E,MAAIC,aAAa,GAAGC,gBAAgB,CAACJ,WAAD,EAAcC,QAAd,CAApC,CAF2E,CAI3E;AACA;AACA;AACA;AACA;;AACA,MAAIE,aAAa,CAACE,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,WAAOxB,UAAU,CAACsB,aAAa,CAAC,CAAD,CAAd,CAAjB;AACD,GAFD,MAEO,IAAIA,aAAa,CAACE,MAAd,KAAyB,CAAzB,IAA8BlC,aAAa,CAACgC,aAAa,CAAC,CAAD,CAAd,EAAmBA,aAAa,CAAC,CAAD,CAAhC,CAAb,GAAoD,CAAtF,EAAyF;AAC9F,WAAOtB,UAAU,CAACsB,aAAa,CAAC,CAAD,CAAd,CAAjB;AACD,GAFM,MAEA,IAAIA,aAAa,CAACE,MAAd,GAAuB,CAA3B,EAA8B;AAEnC;AACA;AACAF,IAAAA,aAAa,GAAGjC,MAAM,CAACiC,aAAD,EAAgB,UAASG,CAAT,EAAY;AAChD,UAAIC,QAAQ,GAAG/B,IAAI,CAACgC,KAAL,CAAWF,CAAC,CAACG,EAAF,GAAO,GAAlB,KAA0B,CAAzC;AAEAF,MAAAA,QAAQ,GAAG,MAAMA,QAAjB;AAEAA,MAAAA,QAAQ,GAAG,CAACA,QAAQ,GAAG,EAAX,GAAgB,GAAhB,GAAsB,EAAvB,IAA6BA,QAAxC,CALgD,CAOhD;AACA;AACA;;AACA,aAAOD,CAAC,CAACI,QAAF,GAAa,GAAb,GAAmBH,QAA1B;AACD,KAXqB,CAAtB;AAaA,WAAO1B,UAAU,CAACsB,aAAa,CAACD,SAAS,GAAG,CAAH,GAAOC,aAAa,CAACE,MAAd,GAAuB,CAAxC,CAAd,CAAjB;AACD;;AAED,SAAO,IAAP;AACD;AAGD,OAAO,SAASD,gBAAT,CAA0BO,CAA1B,EAA6BC,CAA7B,EAAgC;AACrC,SAAOxC,cAAc,CAACuC,CAAD,EAAIC,CAAJ,CAArB;AACD","sourcesContent":["import {\n  isObject,\n  sortBy\n} from 'min-dash';\n\nimport {\n  pointDistance\n} from '../util/Geometry';\n\nimport intersectPaths from 'path-intersection';\n\n\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\n\n\nexport function roundPoint(point) {\n\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n\n\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Object}\n */\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n\n\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {Object} trbl\n *\n * @return {Bounds}\n */\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n\n\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Point}\n */\nexport function getMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n\n\n// orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Bounds} rect\n * @param {Bounds} reference\n * @param {Point|Number} padding\n *\n * @return {String} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\nexport function getOrientation(rect, reference, padding) {\n\n  padding = padding || 0;\n\n  // make sure we can use an object, too\n  // for individual { x, y } padding\n  if (!isObject(padding)) {\n    padding = { x: padding, y: padding };\n  }\n\n\n  var rectOrientation = asTRBL(rect),\n      referenceOrientation = asTRBL(reference);\n\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\n\n  var vertical = top ? 'top' : (bottom ? 'bottom' : null),\n      horizontal = left ? 'left' : (right ? 'right' : null);\n\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n}\n\n\n// intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {PathDef} elementPath\n * @param {PathDef} linePath\n * @param {Boolean} cropStart crop from start or end\n *\n * @return {Point}\n */\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n\n  var intersections = getIntersections(elementPath, linePath);\n\n  // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function(i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n\n      distance = 100 - distance;\n\n      distance = (distance < 10 ? '0' : '') + distance;\n\n      // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n      return i.segment2 + '#' + distance;\n    });\n\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n\n  return null;\n}\n\n\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}"]},"metadata":{},"sourceType":"module"}