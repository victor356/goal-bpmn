{"ast":null,"code":"import { pick, assign } from 'min-dash';\nimport { resizeBounds, ensureConstraints, computeChildrenBBox, getMinResizeBounds } from './ResizeUtil';\nimport { asTRBL, roundBounds } from '../../layout/LayoutUtil';\nvar DEFAULT_MIN_WIDTH = 10;\n/**\n * A component that provides resizing of shapes on the canvas.\n *\n * The following components are part of shape resize:\n *\n *  * adding resize handles,\n *  * creating a visual during resize\n *  * checking resize rules\n *  * committing a change once finished\n *\n *\n * ## Customizing\n *\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\n * and providing the following parameters through the 'context':\n *\n *   * minDimensions ({ width, height }): minimum shape dimensions\n *\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\n *     gap between the minimum bounding box and the container\n *\n * f.ex:\n *\n * ```javascript\n * eventBus.on('resize.start', 1500, function(event) {\n *   var context = event.context,\n *\n *  context.minDimensions = { width: 140, height: 120 };\n *\n *  // Passing general padding\n *  context.childrenBoxPadding = 30;\n *\n *  // Passing padding to a specific side\n *  context.childrenBoxPadding.left = 20;\n * });\n * ```\n */\n\nexport default function Resize(eventBus, rules, modeling, dragging) {\n  this._dragging = dragging;\n  this._rules = rules;\n  var self = this;\n  /**\n   * Handle resize move by specified delta.\n   *\n   * @param {Object} context\n   * @param {Point} delta\n   */\n\n  function handleMove(context, delta) {\n    var shape = context.shape,\n        direction = context.direction,\n        resizeConstraints = context.resizeConstraints,\n        newBounds;\n    context.delta = delta;\n    newBounds = resizeBounds(shape, direction, delta); // ensure constraints during resize\n\n    context.newBounds = ensureConstraints(newBounds, resizeConstraints); // update + cache executable state\n\n    context.canExecute = self.canResize(context);\n  }\n  /**\n   * Handle resize start.\n   *\n   * @param  {Object} context\n   */\n\n\n  function handleStart(context) {\n    var resizeConstraints = context.resizeConstraints,\n        // evaluate minBounds for backwards compatibility\n    minBounds = context.minBounds;\n\n    if (resizeConstraints !== undefined) {\n      return;\n    }\n\n    if (minBounds === undefined) {\n      minBounds = self.computeMinResizeBox(context);\n    }\n\n    context.resizeConstraints = {\n      min: asTRBL(minBounds)\n    };\n  }\n  /**\n   * Handle resize end.\n   *\n   * @param  {Object} context\n   */\n\n\n  function handleEnd(context) {\n    var shape = context.shape,\n        canExecute = context.canExecute,\n        newBounds = context.newBounds;\n\n    if (canExecute) {\n      // ensure we have actual pixel values for new bounds\n      // (important when zoom level was > 1 during move)\n      newBounds = roundBounds(newBounds); // perform the actual resize\n\n      modeling.resizeShape(shape, newBounds);\n    }\n  }\n\n  eventBus.on('resize.start', function (event) {\n    handleStart(event.context);\n  });\n  eventBus.on('resize.move', function (event) {\n    var delta = {\n      x: event.dx,\n      y: event.dy\n    };\n    handleMove(event.context, delta);\n  });\n  eventBus.on('resize.end', function (event) {\n    handleEnd(event.context);\n  });\n}\n\nResize.prototype.canResize = function (context) {\n  var rules = this._rules;\n  var ctx = pick(context, ['newBounds', 'shape', 'delta', 'direction']);\n  return rules.allowed('shape.resize', ctx);\n};\n/**\n * Activate a resize operation.\n *\n * You may specify additional contextual information and must specify a\n * resize direction during activation of the resize event.\n *\n * @param {MouseEvent} event\n * @param {djs.model.Shape} shape\n * @param {Object|String} contextOrDirection\n */\n\n\nResize.prototype.activate = function (event, shape, contextOrDirection) {\n  var dragging = this._dragging,\n      context,\n      direction;\n\n  if (typeof contextOrDirection === 'string') {\n    contextOrDirection = {\n      direction: contextOrDirection\n    };\n  }\n\n  context = assign({\n    shape: shape\n  }, contextOrDirection);\n  direction = context.direction;\n\n  if (!direction) {\n    throw new Error('must provide a direction (nw|se|ne|sw)');\n  }\n\n  var referencePoint = {\n    x: /w/.test(direction) ? shape.x : shape.x + shape.width,\n    y: /n/.test(direction) ? shape.y : shape.y + shape.height\n  };\n  dragging.init(event, referencePoint, 'resize', {\n    autoActivate: true,\n    cursor: 'resize-' + (/nw|se/.test(direction) ? 'nwse' : 'nesw'),\n    data: {\n      shape: shape,\n      context: context\n    }\n  });\n};\n\nResize.prototype.computeMinResizeBox = function (context) {\n  var shape = context.shape,\n      direction = context.direction,\n      minDimensions,\n      childrenBounds;\n  minDimensions = context.minDimensions || {\n    width: DEFAULT_MIN_WIDTH,\n    height: DEFAULT_MIN_WIDTH\n  }; // get children bounds\n\n  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding); // get correct minimum bounds from given resize direction\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\n\n  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\n};\n\nResize.$inject = ['eventBus', 'rules', 'modeling', 'dragging'];","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/features/resize/Resize.js"],"names":["pick","assign","resizeBounds","ensureConstraints","computeChildrenBBox","getMinResizeBounds","asTRBL","roundBounds","DEFAULT_MIN_WIDTH","Resize","eventBus","rules","modeling","dragging","_dragging","_rules","self","handleMove","context","delta","shape","direction","resizeConstraints","newBounds","canExecute","canResize","handleStart","minBounds","undefined","computeMinResizeBox","min","handleEnd","resizeShape","on","event","x","dx","y","dy","prototype","ctx","allowed","activate","contextOrDirection","Error","referencePoint","test","width","height","init","autoActivate","cursor","data","minDimensions","childrenBounds","childrenBoxPadding","$inject"],"mappings":"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","sourcesContent":["import {\n  pick,\n  assign\n} from 'min-dash';\n\nimport {\n  resizeBounds,\n  ensureConstraints,\n  computeChildrenBBox,\n  getMinResizeBounds\n} from './ResizeUtil';\n\nimport {\n  asTRBL,\n  roundBounds\n} from '../../layout/LayoutUtil';\n\nvar DEFAULT_MIN_WIDTH = 10;\n\n\n/**\n * A component that provides resizing of shapes on the canvas.\n *\n * The following components are part of shape resize:\n *\n *  * adding resize handles,\n *  * creating a visual during resize\n *  * checking resize rules\n *  * committing a change once finished\n *\n *\n * ## Customizing\n *\n * It's possible to customize the resizing behaviour by intercepting 'resize.start'\n * and providing the following parameters through the 'context':\n *\n *   * minDimensions ({ width, height }): minimum shape dimensions\n *\n *   * childrenBoxPadding ({ left, top, bottom, right } || number):\n *     gap between the minimum bounding box and the container\n *\n * f.ex:\n *\n * ```javascript\n * eventBus.on('resize.start', 1500, function(event) {\n *   var context = event.context,\n *\n *  context.minDimensions = { width: 140, height: 120 };\n *\n *  // Passing general padding\n *  context.childrenBoxPadding = 30;\n *\n *  // Passing padding to a specific side\n *  context.childrenBoxPadding.left = 20;\n * });\n * ```\n */\nexport default function Resize(eventBus, rules, modeling, dragging) {\n\n  this._dragging = dragging;\n  this._rules = rules;\n\n  var self = this;\n\n\n  /**\n   * Handle resize move by specified delta.\n   *\n   * @param {Object} context\n   * @param {Point} delta\n   */\n  function handleMove(context, delta) {\n\n    var shape = context.shape,\n        direction = context.direction,\n        resizeConstraints = context.resizeConstraints,\n        newBounds;\n\n    context.delta = delta;\n\n    newBounds = resizeBounds(shape, direction, delta);\n\n    // ensure constraints during resize\n    context.newBounds = ensureConstraints(newBounds, resizeConstraints);\n\n    // update + cache executable state\n    context.canExecute = self.canResize(context);\n  }\n\n  /**\n   * Handle resize start.\n   *\n   * @param  {Object} context\n   */\n  function handleStart(context) {\n\n    var resizeConstraints = context.resizeConstraints,\n        // evaluate minBounds for backwards compatibility\n        minBounds = context.minBounds;\n\n    if (resizeConstraints !== undefined) {\n      return;\n    }\n\n    if (minBounds === undefined) {\n      minBounds = self.computeMinResizeBox(context);\n    }\n\n    context.resizeConstraints = {\n      min: asTRBL(minBounds)\n    };\n  }\n\n  /**\n   * Handle resize end.\n   *\n   * @param  {Object} context\n   */\n  function handleEnd(context) {\n    var shape = context.shape,\n        canExecute = context.canExecute,\n        newBounds = context.newBounds;\n\n    if (canExecute) {\n      // ensure we have actual pixel values for new bounds\n      // (important when zoom level was > 1 during move)\n      newBounds = roundBounds(newBounds);\n\n      // perform the actual resize\n      modeling.resizeShape(shape, newBounds);\n    }\n  }\n\n\n  eventBus.on('resize.start', function(event) {\n    handleStart(event.context);\n  });\n\n  eventBus.on('resize.move', function(event) {\n    var delta = {\n      x: event.dx,\n      y: event.dy\n    };\n\n    handleMove(event.context, delta);\n  });\n\n  eventBus.on('resize.end', function(event) {\n    handleEnd(event.context);\n  });\n\n}\n\n\nResize.prototype.canResize = function(context) {\n  var rules = this._rules;\n\n  var ctx = pick(context, [ 'newBounds', 'shape', 'delta', 'direction' ]);\n\n  return rules.allowed('shape.resize', ctx);\n};\n\n/**\n * Activate a resize operation.\n *\n * You may specify additional contextual information and must specify a\n * resize direction during activation of the resize event.\n *\n * @param {MouseEvent} event\n * @param {djs.model.Shape} shape\n * @param {Object|String} contextOrDirection\n */\nResize.prototype.activate = function(event, shape, contextOrDirection) {\n  var dragging = this._dragging,\n      context,\n      direction;\n\n  if (typeof contextOrDirection === 'string') {\n    contextOrDirection = {\n      direction: contextOrDirection\n    };\n  }\n\n  context = assign({ shape: shape }, contextOrDirection);\n\n  direction = context.direction;\n\n  if (!direction) {\n    throw new Error('must provide a direction (nw|se|ne|sw)');\n  }\n\n  var referencePoint = {\n    x: /w/.test(direction) ? shape.x : shape.x + shape.width,\n    y: /n/.test(direction) ? shape.y : shape.y + shape.height\n  };\n\n  dragging.init(event, referencePoint, 'resize', {\n    autoActivate: true,\n    cursor: 'resize-' + (/nw|se/.test(direction) ? 'nwse' : 'nesw'),\n    data: {\n      shape: shape,\n      context: context\n    }\n  });\n};\n\nResize.prototype.computeMinResizeBox = function(context) {\n  var shape = context.shape,\n      direction = context.direction,\n      minDimensions,\n      childrenBounds;\n\n  minDimensions = context.minDimensions || {\n    width: DEFAULT_MIN_WIDTH,\n    height: DEFAULT_MIN_WIDTH\n  };\n\n  // get children bounds\n  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);\n\n  // get correct minimum bounds from given resize direction\n  // basically ensures that the minBounds is max(childrenBounds, minDimensions)\n  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);\n};\n\n\nResize.$inject = [\n  'eventBus',\n  'rules',\n  'modeling',\n  'dragging'\n];"]},"metadata":{},"sourceType":"module"}