{"ast":null,"code":"import { is } from '../../util/ModelUtil';\nimport { getMid, asTRBL, getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nimport { find, reduce } from 'min-dash';\nvar DEFAULT_HORIZONTAL_DISTANCE = 50;\nvar MAX_HORIZONTAL_DISTANCE = 250; // padding to detect element placement\n\nvar PLACEMENT_DETECTION_PAD = 10;\n/**\n * Always try to place element right of source;\n * compute actual distance from previous nodes in flow.\n */\n\nexport function getFlowNodePosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source);\n  var horizontalDistance = getFlowNodeDistance(source, element);\n  var orientation = 'left',\n      rowSize = 80,\n      margin = 30;\n\n  if (is(source, 'bpmn:BoundaryEvent')) {\n    orientation = getOrientation(source, source.host, -25);\n\n    if (orientation.indexOf('top') !== -1) {\n      margin *= -1;\n    }\n  }\n\n  function getVerticalDistance(orient) {\n    if (orient.indexOf('top') != -1) {\n      return -1 * rowSize;\n    } else if (orient.indexOf('bottom') != -1) {\n      return rowSize;\n    } else {\n      return 0;\n    }\n  }\n\n  var position = {\n    x: sourceTrbl.right + horizontalDistance + element.width / 2,\n    y: sourceMid.y + getVerticalDistance(orientation)\n  };\n  var escapeDirection = {\n    y: {\n      margin: margin,\n      rowSize: rowSize\n    }\n  };\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n/**\n * Compute best distance between source and target,\n * based on existing connections to and from source.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n *\n * @return {Number} distance\n */\n\nexport function getFlowNodeDistance(source, element) {\n  var sourceTrbl = asTRBL(source); // is connection a reference to consider?\n\n  function isReference(c) {\n    return is(c, 'bpmn:SequenceFlow');\n  }\n\n  function toTargetNode(weight) {\n    return function (shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function (shape) {\n          var shapeTrbl = asTRBL(shape);\n          return shapeTrbl.left - sourceTrbl.right;\n        }\n      };\n    };\n  }\n\n  function toSourceNode(weight) {\n    return function (shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function (shape) {\n          var shapeTrbl = asTRBL(shape);\n          return sourceTrbl.left - shapeTrbl.right;\n        }\n      };\n    };\n  } // we create a list of nodes to take into consideration\n  // for calculating the optimal flow node distance\n  //\n  //   * weight existing target nodes higher than source nodes\n  //   * only take into account individual nodes once\n  //\n\n\n  var nodes = reduce([].concat(getTargets(source, isReference).map(toTargetNode(5)), getSources(source, isReference).map(toSourceNode(1))), function (nodes, node) {\n    // filter out shapes connected twice via source or target\n    nodes[node.shape.id + '__weight_' + node.weight] = node;\n    return nodes;\n  }, {}); // compute distances between source and incoming nodes;\n  // group at the same time by distance and expose the\n  // favourite distance as { fav: { count, value } }.\n\n  var distancesGrouped = reduce(nodes, function (result, node) {\n    var shape = node.shape,\n        weight = node.weight,\n        distanceTo = node.distanceTo;\n    var fav = result.fav,\n        currentDistance,\n        currentDistanceCount,\n        currentDistanceEntry;\n    currentDistance = distanceTo(shape); // ignore too far away peers\n    // or non-left to right modeled nodes\n\n    if (currentDistance < 0 || currentDistance > MAX_HORIZONTAL_DISTANCE) {\n      return result;\n    }\n\n    currentDistanceEntry = result[String(currentDistance)] = result[String(currentDistance)] || {\n      value: currentDistance,\n      count: 0\n    }; // inc diff count\n\n    currentDistanceCount = currentDistanceEntry.count += 1 * weight;\n\n    if (!fav || fav.count < currentDistanceCount) {\n      result.fav = currentDistanceEntry;\n    }\n\n    return result;\n  }, {});\n\n  if (distancesGrouped.fav) {\n    return distancesGrouped.fav.value;\n  } else {\n    return DEFAULT_HORIZONTAL_DISTANCE;\n  }\n}\n/**\n * Always try to place text annotations top right of source.\n */\n\nexport function getTextAnnotationPosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var position = {\n    x: sourceTrbl.right + element.width / 2,\n    y: sourceTrbl.top - 50 - element.height / 2\n  };\n  var escapeDirection = {\n    y: {\n      margin: -30,\n      rowSize: 20\n    }\n  };\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n/**\n * Always put element bottom right of source.\n */\n\nexport function getDataElementPosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var position = {\n    x: sourceTrbl.right - 10 + element.width / 2,\n    y: sourceTrbl.bottom + 40 + element.width / 2\n  };\n  var escapeDirection = {\n    x: {\n      margin: 30,\n      rowSize: 30\n    }\n  };\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n/**\n * Always put element right of source per default.\n */\n\nexport function getDefaultPosition(source, element) {\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source); // simply put element right next to source\n\n  return {\n    x: sourceTrbl.right + DEFAULT_HORIZONTAL_DISTANCE + element.width / 2,\n    y: sourceMid.y\n  };\n}\n/**\n * Returns all connected elements around the given source.\n *\n * This includes:\n *\n *   - connected elements\n *   - host connected elements\n *   - attachers connected elements\n *\n * @param  {djs.model.Shape} source\n * @param  {djs.model.Shape} element\n *\n * @return {Array<djs.model.Shape>}\n */\n\nfunction getAutoPlaceClosure(source, element) {\n  var allConnected = getConnected(source);\n\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function (shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n\n  return allConnected;\n}\n/**\n * Return target at given position, if defined.\n *\n * This takes connected elements from host and attachers\n * into account, too.\n */\n\n\nexport function getConnectedAtPosition(source, position, element) {\n  var bounds = {\n    x: position.x - element.width / 2,\n    y: position.y - element.height / 2,\n    width: element.width,\n    height: element.height\n  };\n  var closure = getAutoPlaceClosure(source, element);\n  return find(closure, function (target) {\n    if (target === element) {\n      return false;\n    }\n\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n    return orientation === 'intersect';\n  });\n}\n/**\n * Returns a new, position for the given element\n * based on the given element that is not occupied\n * by some element connected to source.\n *\n * Take into account the escapeDirection (where to move\n * on positining clashes) in the computation.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n * @param {Point} position\n * @param {Object} escapeDelta\n *\n * @return {Point}\n */\n\nexport function deconflictPosition(source, element, position, escapeDelta) {\n  function nextPosition(existingElement) {\n    var newPosition = {\n      x: position.x,\n      y: position.y\n    };\n    ['x', 'y'].forEach(function (axis) {\n      var axisDelta = escapeDelta[axis];\n\n      if (!axisDelta) {\n        return;\n      }\n\n      var dimension = axis === 'x' ? 'width' : 'height';\n      var margin = axisDelta.margin,\n          rowSize = axisDelta.rowSize;\n\n      if (margin < 0) {\n        newPosition[axis] = Math.min(existingElement[axis] + margin - element[dimension] / 2, position[axis] - rowSize + margin);\n      } else {\n        newPosition[axis] = Math.max(existingTarget[axis] + existingTarget[dimension] + margin + element[dimension] / 2, position[axis] + rowSize + margin);\n      }\n    });\n    return newPosition;\n  }\n\n  var existingTarget; // deconflict position until free slot is found\n\n  while (existingTarget = getConnectedAtPosition(source, position, element)) {\n    position = nextPosition(existingTarget);\n  }\n\n  return position;\n} // helpers //////////////////////\n\nfunction noneFilter() {\n  return true;\n}\n\nfunction getConnected(element, connectionFilter) {\n  return [].concat(getTargets(element, connectionFilter), getSources(element, connectionFilter));\n}\n\nfunction getSources(shape, connectionFilter) {\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.incoming.filter(connectionFilter).map(function (c) {\n    return c.source;\n  });\n}\n\nfunction getTargets(shape, connectionFilter) {\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.outgoing.filter(connectionFilter).map(function (c) {\n    return c.target;\n  });\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/auto-place/AutoPlaceUtil.js"],"names":["is","getMid","asTRBL","getOrientation","find","reduce","DEFAULT_HORIZONTAL_DISTANCE","MAX_HORIZONTAL_DISTANCE","PLACEMENT_DETECTION_PAD","getFlowNodePosition","source","element","sourceTrbl","sourceMid","horizontalDistance","getFlowNodeDistance","orientation","rowSize","margin","host","indexOf","getVerticalDistance","orient","position","x","right","width","y","escapeDirection","deconflictPosition","isReference","c","toTargetNode","weight","shape","distanceTo","shapeTrbl","left","toSourceNode","nodes","concat","getTargets","map","getSources","node","id","distancesGrouped","result","fav","currentDistance","currentDistanceCount","currentDistanceEntry","String","value","count","getTextAnnotationPosition","top","height","getDataElementPosition","bottom","getDefaultPosition","getAutoPlaceClosure","allConnected","getConnected","attachers","shapes","attacher","getConnectedAtPosition","bounds","closure","target","escapeDelta","nextPosition","existingElement","newPosition","forEach","axis","axisDelta","dimension","Math","min","max","existingTarget","noneFilter","connectionFilter","incoming","filter","outgoing"],"mappings":"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","sourcesContent":["import { is } from '../../util/ModelUtil';\n\nimport {\n  getMid,\n  asTRBL,\n  getOrientation\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  find,\n  reduce\n} from 'min-dash';\n\nvar DEFAULT_HORIZONTAL_DISTANCE = 50;\n\nvar MAX_HORIZONTAL_DISTANCE = 250;\n\n// padding to detect element placement\nvar PLACEMENT_DETECTION_PAD = 10;\n\n\n/**\n * Always try to place element right of source;\n * compute actual distance from previous nodes in flow.\n */\nexport function getFlowNodePosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n  var sourceMid = getMid(source);\n\n  var horizontalDistance = getFlowNodeDistance(source, element);\n\n  var orientation = 'left',\n      rowSize = 80,\n      margin = 30;\n\n  if (is(source, 'bpmn:BoundaryEvent')) {\n    orientation = getOrientation(source, source.host, -25);\n\n    if (orientation.indexOf('top') !== -1) {\n      margin *= -1;\n    }\n  }\n\n  function getVerticalDistance(orient) {\n    if (orient.indexOf('top') != -1) {\n      return -1 * rowSize;\n    } else if (orient.indexOf('bottom') != -1) {\n      return rowSize;\n    } else {\n      return 0;\n    }\n  }\n\n  var position = {\n    x: sourceTrbl.right + horizontalDistance + element.width / 2,\n    y: sourceMid.y + getVerticalDistance(orientation)\n  };\n\n  var escapeDirection = {\n    y: {\n      margin: margin,\n      rowSize: rowSize\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n\n\n/**\n * Compute best distance between source and target,\n * based on existing connections to and from source.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n *\n * @return {Number} distance\n */\nexport function getFlowNodeDistance(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  // is connection a reference to consider?\n  function isReference(c) {\n    return is(c, 'bpmn:SequenceFlow');\n  }\n\n  function toTargetNode(weight) {\n\n    return function(shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function(shape) {\n          var shapeTrbl = asTRBL(shape);\n\n          return shapeTrbl.left - sourceTrbl.right;\n        }\n      };\n    };\n  }\n\n  function toSourceNode(weight) {\n    return function(shape) {\n      return {\n        shape: shape,\n        weight: weight,\n        distanceTo: function(shape) {\n          var shapeTrbl = asTRBL(shape);\n\n          return sourceTrbl.left - shapeTrbl.right;\n        }\n      };\n    };\n  }\n\n  // we create a list of nodes to take into consideration\n  // for calculating the optimal flow node distance\n  //\n  //   * weight existing target nodes higher than source nodes\n  //   * only take into account individual nodes once\n  //\n  var nodes = reduce([].concat(\n    getTargets(source, isReference).map(toTargetNode(5)),\n    getSources(source, isReference).map(toSourceNode(1))\n  ), function(nodes, node) {\n    // filter out shapes connected twice via source or target\n    nodes[node.shape.id + '__weight_' + node.weight] = node;\n\n    return nodes;\n  }, {});\n\n  // compute distances between source and incoming nodes;\n  // group at the same time by distance and expose the\n  // favourite distance as { fav: { count, value } }.\n  var distancesGrouped = reduce(nodes, function(result, node) {\n\n    var shape = node.shape,\n        weight = node.weight,\n        distanceTo = node.distanceTo;\n\n    var fav = result.fav,\n        currentDistance,\n        currentDistanceCount,\n        currentDistanceEntry;\n\n    currentDistance = distanceTo(shape);\n\n    // ignore too far away peers\n    // or non-left to right modeled nodes\n    if (currentDistance < 0 || currentDistance > MAX_HORIZONTAL_DISTANCE) {\n      return result;\n    }\n\n    currentDistanceEntry = result[String(currentDistance)] =\n      result[String(currentDistance)] || {\n        value: currentDistance,\n        count: 0\n      };\n\n    // inc diff count\n    currentDistanceCount = currentDistanceEntry.count += 1 * weight;\n\n    if (!fav || fav.count < currentDistanceCount) {\n      result.fav = currentDistanceEntry;\n    }\n\n    return result;\n  }, { });\n\n\n  if (distancesGrouped.fav) {\n    return distancesGrouped.fav.value;\n  } else {\n    return DEFAULT_HORIZONTAL_DISTANCE;\n  }\n}\n\n\n/**\n * Always try to place text annotations top right of source.\n */\nexport function getTextAnnotationPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var position = {\n    x: sourceTrbl.right + element.width / 2,\n    y: sourceTrbl.top - 50 - element.height / 2\n  };\n\n  var escapeDirection = {\n    y: {\n      margin: -30,\n      rowSize: 20\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n\n\n/**\n * Always put element bottom right of source.\n */\nexport function getDataElementPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var position = {\n    x: sourceTrbl.right - 10 + element.width / 2,\n    y: sourceTrbl.bottom + 40 + element.width / 2\n  };\n\n  var escapeDirection = {\n    x: {\n      margin: 30,\n      rowSize: 30\n    }\n  };\n\n  return deconflictPosition(source, element, position, escapeDirection);\n}\n\n\n/**\n * Always put element right of source per default.\n */\nexport function getDefaultPosition(source, element) {\n\n  var sourceTrbl = asTRBL(source);\n\n  var sourceMid = getMid(source);\n\n  // simply put element right next to source\n  return {\n    x: sourceTrbl.right + DEFAULT_HORIZONTAL_DISTANCE + element.width / 2,\n    y: sourceMid.y\n  };\n}\n\n\n/**\n * Returns all connected elements around the given source.\n *\n * This includes:\n *\n *   - connected elements\n *   - host connected elements\n *   - attachers connected elements\n *\n * @param  {djs.model.Shape} source\n * @param  {djs.model.Shape} element\n *\n * @return {Array<djs.model.Shape>}\n */\nfunction getAutoPlaceClosure(source, element) {\n\n  var allConnected = getConnected(source);\n\n  if (source.host) {\n    allConnected = allConnected.concat(getConnected(source.host));\n  }\n\n  if (source.attachers) {\n    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {\n      return shapes.concat(getConnected(attacher));\n    }, []));\n  }\n\n  return allConnected;\n}\n\n/**\n * Return target at given position, if defined.\n *\n * This takes connected elements from host and attachers\n * into account, too.\n */\nexport function getConnectedAtPosition(source, position, element) {\n\n  var bounds = {\n    x: position.x - (element.width / 2),\n    y: position.y - (element.height / 2),\n    width: element.width,\n    height: element.height\n  };\n\n  var closure = getAutoPlaceClosure(source, element);\n\n  return find(closure, function(target) {\n\n    if (target === element) {\n      return false;\n    }\n\n    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);\n\n    return orientation === 'intersect';\n  });\n}\n\n\n/**\n * Returns a new, position for the given element\n * based on the given element that is not occupied\n * by some element connected to source.\n *\n * Take into account the escapeDirection (where to move\n * on positining clashes) in the computation.\n *\n * @param {djs.model.Shape} source\n * @param {djs.model.Shape} element\n * @param {Point} position\n * @param {Object} escapeDelta\n *\n * @return {Point}\n */\nexport function deconflictPosition(source, element, position, escapeDelta) {\n\n  function nextPosition(existingElement) {\n\n    var newPosition = {\n      x: position.x,\n      y: position.y\n    };\n\n    [ 'x', 'y' ].forEach(function(axis) {\n\n      var axisDelta = escapeDelta[axis];\n\n      if (!axisDelta) {\n        return;\n      }\n\n      var dimension = axis === 'x' ? 'width' : 'height';\n\n      var margin = axisDelta.margin,\n          rowSize = axisDelta.rowSize;\n\n      if (margin < 0) {\n        newPosition[axis] = Math.min(\n          existingElement[axis] + margin - element[dimension] / 2,\n          position[axis] - rowSize + margin\n        );\n      } else {\n        newPosition[axis] = Math.max(\n          existingTarget[axis] + existingTarget[dimension] + margin + element[dimension] / 2,\n          position[axis] + rowSize + margin\n        );\n      }\n    });\n\n    return newPosition;\n  }\n\n  var existingTarget;\n\n  // deconflict position until free slot is found\n  while ((existingTarget = getConnectedAtPosition(source, position, element))) {\n    position = nextPosition(existingTarget);\n  }\n\n  return position;\n}\n\n\n\n// helpers //////////////////////\n\nfunction noneFilter() {\n  return true;\n}\n\nfunction getConnected(element, connectionFilter) {\n  return [].concat(\n    getTargets(element, connectionFilter),\n    getSources(element, connectionFilter)\n  );\n}\n\nfunction getSources(shape, connectionFilter) {\n\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.incoming.filter(connectionFilter).map(function(c) {\n    return c.source;\n  });\n}\n\nfunction getTargets(shape, connectionFilter) {\n\n  if (!connectionFilter) {\n    connectionFilter = noneFilter;\n  }\n\n  return shape.outgoing.filter(connectionFilter).map(function(c) {\n    return c.target;\n  });\n}"]},"metadata":{},"sourceType":"module"}