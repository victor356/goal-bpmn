{"ast":null,"code":"import { pick, assign, forEach, bind } from 'min-dash';\nimport { parseName as parseNameNs } from './ns';\n/**\n * A utility to build element descriptors.\n */\n\nexport default function DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\nDescriptorBuilder.prototype.build = function () {\n  return pick(this, ['ns', 'name', 'allTypes', 'allTypesByName', 'properties', 'propertiesByName', 'bodyProperty', 'idProperty']);\n};\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\n\n\nDescriptorBuilder.prototype.addProperty = function (p, idx, validate) {\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\nDescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error('property <' + newProperty.ns.name + '> must be id property ' + 'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n    if (!newProperty.isBody) {\n      throw new Error('property <' + newProperty.ns.name + '> must be body property ' + 'to refine <' + oldProperty.ns.name + '>');\n    } // TODO: Check compatibility\n\n\n    this.setBodyProperty(newProperty, false);\n  } // validate existence and get location of old property\n\n\n  var idx = props.indexOf(oldProperty);\n\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  } // remove old property\n\n\n  props.splice(idx, 1); // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n\n  this.addProperty(newProperty, replace ? undefined : idx, rename); // make new property available under old name\n\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\nDescriptorBuilder.prototype.redefineProperty = function (p, targetPropertyName, replace) {\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n  var name = parseNameNs(parts[0], nsPrefix);\n  var attrName = parseNameNs(parts[1], name.prefix).name;\n  var redefinedProperty = this.propertiesByName[attrName];\n\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function (p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function (p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function (p, validate) {\n  if (validate && this.bodyProperty) {\n    throw new Error('body property defined multiple times ' + '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function (p, validate) {\n  if (validate && this.idProperty) {\n    throw new Error('id property defined multiple times ' + '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function (p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error('property <' + propertyName + '> already defined; ' + 'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' + '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function (name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function (t, inherited) {\n  var typesByName = this.allTypesByName,\n      types = this.allTypes;\n  var typeName = t.name;\n\n  if (typeName in typesByName) {\n    return;\n  }\n\n  forEach(t.properties, bind(function (p) {\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n    var replaces = p.replaces,\n        redefines = p.redefines; // add replace/redefine support\n\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n\n      this.addProperty(p);\n    }\n  }, this));\n  types.push(t);\n  typesByName[typeName] = t;\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/moddle/lib/descriptor-builder.js"],"names":["pick","assign","forEach","bind","parseName","parseNameNs","DescriptorBuilder","nameNs","ns","name","allTypes","allTypesByName","properties","propertiesByName","prototype","build","addProperty","p","idx","validate","undefined","addNamedProperty","splice","push","replaceProperty","oldProperty","newProperty","replace","oldNameNs","props","rename","isId","Error","setIdProperty","isBody","setBodyProperty","indexOf","localName","redefineProperty","targetPropertyName","nsPrefix","prefix","parts","split","attrName","redefinedProperty","redefines","propsByName","assertNotDefined","removeNamedProperty","bodyProperty","idProperty","propertyName","definedProperty","definedBy","hasProperty","addTrait","t","inherited","typesByName","types","typeName","Object","defineProperty","value","replaces"],"mappings":"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","sourcesContent":["import {\n  pick,\n  assign,\n  forEach,\n  bind\n} from 'min-dash';\n\nimport {\n  parseName as parseNameNs\n} from './ns';\n\n\n/**\n * A utility to build element descriptors.\n */\nexport default function DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\n\nDescriptorBuilder.prototype.build = function() {\n  return pick(this, [\n    'ns',\n    'name',\n    'allTypes',\n    'allTypesByName',\n    'properties',\n    'propertiesByName',\n    'bodyProperty',\n    'idProperty'\n  ]);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\n\nDescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be id property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n\n    if (!newProperty.isBody) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be body property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\n\nDescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n\n  var name = parseNameNs(parts[0], nsPrefix);\n  var attrName = parseNameNs(parts[1], name.prefix).name;\n\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function(p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n  if (validate && this.bodyProperty) {\n    throw new Error(\n      'body property defined multiple times ' +\n      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n  if (validate && this.idProperty) {\n    throw new Error(\n      'id property defined multiple times ' +\n      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error(\n      'property <' + propertyName + '> already defined; ' +\n      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function(name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n  var typesByName = this.allTypesByName,\n      types = this.allTypes;\n\n  var typeName = t.name;\n\n  if (typeName in typesByName) {\n    return;\n  }\n\n  forEach(t.properties, bind(function(p) {\n\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n\n    var replaces = p.replaces,\n        redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this));\n\n  types.push(t);\n  typesByName[typeName] = t;\n};"]},"metadata":{},"sourceType":"module"}