{"ast":null,"code":"import { getOrientation } from 'diagram-js/lib/layout/LayoutUtil';\nexport function getBoundaryAttachment(position, targetBounds) {\n  var orientation = getOrientation(position, targetBounds, -15);\n\n  if (orientation !== 'intersect') {\n    return orientation;\n  } else {\n    return null;\n  }\n} // participant snapping box implementation //////////////////////\n\nimport { is } from '../../util/ModelUtil';\nimport { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';\nimport { collectLanes, getLanesRoot } from '../modeling/util/LaneUtil';\nvar abs = Math.abs,\n    min = Math.min,\n    max = Math.max;\n\nfunction addToTrbl(trbl, attr, value, choice) {\n  var current = trbl[attr]; // make sure to set the value if it does not exist\n  // or apply the correct value by comparing against\n  // choice(value, currentValue)\n\n  trbl[attr] = current === undefined ? value : choice(value, current);\n}\n\nfunction addMin(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, min);\n}\n\nfunction addMax(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, max);\n}\n\nvar LANE_MIN_HEIGHT = 60,\n    LANE_MIN_WIDTH = 300,\n    LANE_RIGHT_PADDING = 20,\n    LANE_LEFT_PADDING = 50,\n    LANE_TOP_PADDING = 20,\n    LANE_BOTTOM_PADDING = 20;\nexport function getParticipantSizeConstraints(laneShape, resizeDirection, balanced) {\n  var lanesRoot = getLanesRoot(laneShape);\n  var isFirst = true,\n      isLast = true; // max top/bottom size for lanes\n\n  var allLanes = collectLanes(lanesRoot, [lanesRoot]);\n  var laneTrbl = asTRBL(laneShape);\n  var maxTrbl = {},\n      minTrbl = {};\n\n  if (/e/.test(resizeDirection)) {\n    minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;\n  } else if (/w/.test(resizeDirection)) {\n    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;\n  }\n\n  allLanes.forEach(function (other) {\n    var otherTrbl = asTRBL(other);\n\n    if (/n/.test(resizeDirection)) {\n      if (otherTrbl.top < laneTrbl.top - 10) {\n        isFirst = false;\n      } // max top size (based on next element)\n\n\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);\n      } // min top size (based on self or nested element)\n\n\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n    }\n\n    if (/s/.test(resizeDirection)) {\n      if (otherTrbl.bottom > laneTrbl.bottom + 10) {\n        isLast = false;\n      } // max bottom size (based on previous element)\n\n\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      } // min bottom size (based on self or nested element)\n\n\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n    }\n  }); // max top/bottom/left/right size based on flow nodes\n\n  var flowElements = lanesRoot.children.filter(function (s) {\n    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));\n  });\n  flowElements.forEach(function (flowElement) {\n    var flowElementTrbl = asTRBL(flowElement);\n\n    if (isFirst && /n/.test(resizeDirection)) {\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\n    }\n\n    if (/e/.test(resizeDirection)) {\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\n    }\n\n    if (isLast && /s/.test(resizeDirection)) {\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\n    }\n\n    if (/w/.test(resizeDirection)) {\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\n    }\n  });\n  return {\n    min: minTrbl,\n    max: maxTrbl\n  };\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/bpmn-js/lib/features/snapping/BpmnSnappingUtil.js"],"names":["getOrientation","getBoundaryAttachment","position","targetBounds","orientation","is","asTRBL","collectLanes","getLanesRoot","abs","Math","min","max","addToTrbl","trbl","attr","value","choice","current","undefined","addMin","addMax","LANE_MIN_HEIGHT","LANE_MIN_WIDTH","LANE_RIGHT_PADDING","LANE_LEFT_PADDING","LANE_TOP_PADDING","LANE_BOTTOM_PADDING","getParticipantSizeConstraints","laneShape","resizeDirection","balanced","lanesRoot","isFirst","isLast","allLanes","laneTrbl","maxTrbl","minTrbl","test","right","left","forEach","other","otherTrbl","top","bottom","flowElements","children","filter","s","hidden","waypoints","flowElement","flowElementTrbl"],"mappings":"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","sourcesContent":["import {\n  getOrientation\n} from 'diagram-js/lib/layout/LayoutUtil';\n\n\nexport function getBoundaryAttachment(position, targetBounds) {\n\n  var orientation = getOrientation(position, targetBounds, -15);\n\n  if (orientation !== 'intersect') {\n    return orientation;\n  } else {\n    return null;\n  }\n}\n\n\n// participant snapping box implementation //////////////////////\n\nimport { is } from '../../util/ModelUtil';\n\nimport {\n  asTRBL\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  collectLanes,\n  getLanesRoot\n} from '../modeling/util/LaneUtil';\n\nvar abs = Math.abs,\n    min = Math.min,\n    max = Math.max;\n\n\nfunction addToTrbl(trbl, attr, value, choice) {\n\n  var current = trbl[attr];\n\n  // make sure to set the value if it does not exist\n  // or apply the correct value by comparing against\n  // choice(value, currentValue)\n  trbl[attr] = current === undefined ? value : choice(value, current);\n}\n\nfunction addMin(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, min);\n}\n\nfunction addMax(trbl, attr, value) {\n  return addToTrbl(trbl, attr, value, max);\n}\n\n\nvar LANE_MIN_HEIGHT = 60,\n    LANE_MIN_WIDTH = 300,\n    LANE_RIGHT_PADDING = 20,\n    LANE_LEFT_PADDING = 50,\n    LANE_TOP_PADDING = 20,\n    LANE_BOTTOM_PADDING = 20;\n\n\nexport function getParticipantSizeConstraints(laneShape, resizeDirection, balanced) {\n\n  var lanesRoot = getLanesRoot(laneShape);\n\n  var isFirst = true,\n      isLast = true;\n\n  // max top/bottom size for lanes\n\n  var allLanes = collectLanes(lanesRoot, [ lanesRoot ]);\n\n  var laneTrbl = asTRBL(laneShape);\n\n  var maxTrbl = {},\n      minTrbl = {};\n\n  if (/e/.test(resizeDirection)) {\n    minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;\n  } else\n  if (/w/.test(resizeDirection)) {\n    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;\n  }\n\n  allLanes.forEach(function(other) {\n\n    var otherTrbl = asTRBL(other);\n\n    if (/n/.test(resizeDirection)) {\n\n      if (otherTrbl.top < (laneTrbl.top - 10)) {\n        isFirst = false;\n      }\n\n      // max top size (based on next element)\n      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {\n        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n\n      // min top size (based on self or nested element)\n      if (abs(laneTrbl.top - otherTrbl.top) < 5) {\n        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n    }\n\n    if (/s/.test(resizeDirection)) {\n\n      if (otherTrbl.bottom > (laneTrbl.bottom + 10)) {\n        isLast = false;\n      }\n\n      // max bottom size (based on previous element)\n      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {\n        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);\n      }\n\n      // min bottom size (based on self or nested element)\n      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {\n        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);\n      }\n    }\n  });\n\n\n  // max top/bottom/left/right size based on flow nodes\n\n  var flowElements = lanesRoot.children.filter(function(s) {\n    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));\n  });\n\n  flowElements.forEach(function(flowElement) {\n\n    var flowElementTrbl = asTRBL(flowElement);\n\n    if (isFirst && /n/.test(resizeDirection)) {\n      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);\n    }\n\n    if (/e/.test(resizeDirection)) {\n      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);\n    }\n\n    if (isLast && /s/.test(resizeDirection)) {\n      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);\n    }\n\n    if (/w/.test(resizeDirection)) {\n      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);\n    }\n  });\n\n\n  return {\n    min: minTrbl,\n    max: maxTrbl\n  };\n}"]},"metadata":{},"sourceType":"module"}