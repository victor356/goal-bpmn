{"ast":null,"code":"import { filter, forEach, debounce, bind } from 'min-dash';\nimport SnapContext from './SnapContext';\nimport { mid, isSnapped, setSnapped } from './SnapUtil';\nvar HIGHER_PRIORITY = 1250;\nimport { append as svgAppend, attr as svgAttr, classes as svgClasses, create as svgCreate } from 'tiny-svg';\nvar SNAP_TOLERANCE = 7;\n/**\n * A general purpose snapping component for diagram elements.\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\n\nexport default function Snapping(eventBus, canvas) {\n  this._canvas = canvas;\n  var self = this;\n  eventBus.on(['shape.move.start', 'create.start'], function (event) {\n    self.initSnap(event);\n  });\n  eventBus.on(['shape.move.move', 'shape.move.end', 'create.move', 'create.end'], HIGHER_PRIORITY, function (event) {\n    if (event.originalEvent && event.originalEvent.ctrlKey) {\n      return;\n    }\n\n    if (isSnapped(event)) {\n      return;\n    }\n\n    self.snap(event);\n  });\n  eventBus.on(['shape.move.cleanup', 'create.cleanup'], function (event) {\n    self.hide();\n  }); // delay hide by 1000 seconds since last match\n\n  this._asyncHide = debounce(bind(this.hide, this), 1000);\n}\nSnapping.$inject = ['eventBus', 'canvas'];\n\nSnapping.prototype.initSnap = function (event) {\n  var context = event.context,\n      shape = context.shape,\n      snapContext = context.snapContext;\n\n  if (!snapContext) {\n    snapContext = context.snapContext = new SnapContext();\n  }\n\n  var snapMid = mid(shape, event);\n  snapContext.setSnapOrigin('mid', {\n    x: snapMid.x - event.x,\n    y: snapMid.y - event.y\n  });\n  return snapContext;\n};\n\nSnapping.prototype.snap = function (event) {\n  var context = event.context,\n      snapContext = context.snapContext,\n      shape = context.shape,\n      target = context.target,\n      snapLocations = snapContext.getSnapLocations();\n\n  if (!target) {\n    return;\n  }\n\n  var snapPoints = snapContext.pointsForTarget(target);\n\n  if (!snapPoints.initialized) {\n    this.addTargetSnaps(snapPoints, shape, target);\n    snapPoints.initialized = true;\n  }\n\n  var snapping = {\n    x: isSnapped(event, 'x'),\n    y: isSnapped(event, 'y')\n  };\n  forEach(snapLocations, function (location) {\n    var snapOrigin = snapContext.getSnapOrigin(location);\n    var snapCurrent = {\n      x: event.x + snapOrigin.x,\n      y: event.y + snapOrigin.y\n    }; // snap on both axis, if not snapped already\n\n    forEach(['x', 'y'], function (axis) {\n      var locationSnapping;\n\n      if (!snapping[axis]) {\n        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);\n\n        if (locationSnapping !== undefined) {\n          snapping[axis] = {\n            value: locationSnapping,\n            originValue: locationSnapping - snapOrigin[axis]\n          };\n        }\n      }\n    }); // no more need to snap, drop out of interation\n\n    if (snapping.x && snapping.y) {\n      return false;\n    }\n  }); // show snap visuals\n\n  this.showSnapLine('vertical', snapping.x && snapping.x.value);\n  this.showSnapLine('horizontal', snapping.y && snapping.y.value); // adjust event { x, y, dx, dy } and mark as snapping\n\n  forEach(['x', 'y'], function (axis) {\n    var axisSnapping = snapping[axis];\n\n    if (typeof axisSnapping === 'object') {\n      // set as snapped and adjust the x and/or y position of the event\n      setSnapped(event, axis, axisSnapping.originValue);\n    }\n  });\n};\n\nSnapping.prototype._createLine = function (orientation) {\n  var root = this._canvas.getLayer('snap'); // var line = root.path('M0,0 L0,0').addClass('djs-snap-line');\n\n\n  var line = svgCreate('path');\n  svgAttr(line, {\n    d: 'M0,0 L0,0'\n  });\n  svgClasses(line).add('djs-snap-line');\n  svgAppend(root, line);\n  return {\n    update: function (position) {\n      if (typeof position !== 'number') {\n        svgAttr(line, {\n          display: 'none'\n        });\n      } else {\n        if (orientation === 'horizontal') {\n          svgAttr(line, {\n            d: 'M-100000,' + position + ' L+100000,' + position,\n            display: ''\n          });\n        } else {\n          svgAttr(line, {\n            d: 'M ' + position + ',-100000 L ' + position + ', +100000',\n            display: ''\n          });\n        }\n      }\n    }\n  };\n};\n\nSnapping.prototype._createSnapLines = function () {\n  this._snapLines = {\n    horizontal: this._createLine('horizontal'),\n    vertical: this._createLine('vertical')\n  };\n};\n\nSnapping.prototype.showSnapLine = function (orientation, position) {\n  var line = this.getSnapLine(orientation);\n\n  if (line) {\n    line.update(position);\n  }\n\n  this._asyncHide();\n};\n\nSnapping.prototype.getSnapLine = function (orientation) {\n  if (!this._snapLines) {\n    this._createSnapLines();\n  }\n\n  return this._snapLines[orientation];\n};\n\nSnapping.prototype.hide = function () {\n  forEach(this._snapLines, function (l) {\n    l.update();\n  });\n};\n\nSnapping.prototype.addTargetSnaps = function (snapPoints, shape, target) {\n  var siblings = this.getSiblings(shape, target);\n  forEach(siblings, function (s) {\n    snapPoints.add('mid', mid(s));\n  });\n};\n\nSnapping.prototype.getSiblings = function (element, target) {\n  // snap to all siblings that are not hidden, labels, attached to element or element itself\n  return target && filter(target.children, function (e) {\n    return !e.hidden && !e.labelTarget && e.host !== element && e !== element;\n  });\n};","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/features/snapping/Snapping.js"],"names":["filter","forEach","debounce","bind","SnapContext","mid","isSnapped","setSnapped","HIGHER_PRIORITY","append","svgAppend","attr","svgAttr","classes","svgClasses","create","svgCreate","SNAP_TOLERANCE","Snapping","eventBus","canvas","_canvas","self","on","event","initSnap","originalEvent","ctrlKey","snap","hide","_asyncHide","$inject","prototype","context","shape","snapContext","snapMid","setSnapOrigin","x","y","target","snapLocations","getSnapLocations","snapPoints","pointsForTarget","initialized","addTargetSnaps","snapping","location","snapOrigin","getSnapOrigin","snapCurrent","axis","locationSnapping","undefined","value","originValue","showSnapLine","axisSnapping","_createLine","orientation","root","getLayer","line","d","add","update","position","display","_createSnapLines","_snapLines","horizontal","vertical","getSnapLine","l","siblings","getSiblings","s","element","children","e","hidden","labelTarget","host"],"mappings":"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","sourcesContent":["import {\n  filter,\n  forEach,\n  debounce,\n  bind\n} from 'min-dash';\n\nimport SnapContext from './SnapContext';\n\nimport {\n  mid,\n  isSnapped,\n  setSnapped\n} from './SnapUtil';\n\nvar HIGHER_PRIORITY = 1250;\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate\n} from 'tiny-svg';\n\nvar SNAP_TOLERANCE = 7;\n\n\n/**\n * A general purpose snapping component for diagram elements.\n *\n * @param {EventBus} eventBus\n * @param {Canvas} canvas\n */\nexport default function Snapping(eventBus, canvas) {\n\n  this._canvas = canvas;\n\n  var self = this;\n\n  eventBus.on([ 'shape.move.start', 'create.start' ], function(event) {\n    self.initSnap(event);\n  });\n\n  eventBus.on([ 'shape.move.move', 'shape.move.end', 'create.move', 'create.end' ], HIGHER_PRIORITY, function(event) {\n\n    if (event.originalEvent && event.originalEvent.ctrlKey) {\n      return;\n    }\n\n    if (isSnapped(event)) {\n      return;\n    }\n\n    self.snap(event);\n  });\n\n  eventBus.on([ 'shape.move.cleanup', 'create.cleanup' ], function(event) {\n    self.hide();\n  });\n\n  // delay hide by 1000 seconds since last match\n  this._asyncHide = debounce(bind(this.hide, this), 1000);\n}\n\nSnapping.$inject = [ 'eventBus', 'canvas' ];\n\n\nSnapping.prototype.initSnap = function(event) {\n\n  var context = event.context,\n      shape = context.shape,\n      snapContext = context.snapContext;\n\n  if (!snapContext) {\n    snapContext = context.snapContext = new SnapContext();\n  }\n\n  var snapMid = mid(shape, event);\n\n  snapContext.setSnapOrigin('mid', {\n    x: snapMid.x - event.x,\n    y: snapMid.y - event.y\n  });\n\n  return snapContext;\n};\n\n\nSnapping.prototype.snap = function(event) {\n\n  var context = event.context,\n      snapContext = context.snapContext,\n      shape = context.shape,\n      target = context.target,\n      snapLocations = snapContext.getSnapLocations();\n\n  if (!target) {\n    return;\n  }\n\n  var snapPoints = snapContext.pointsForTarget(target);\n\n  if (!snapPoints.initialized) {\n    this.addTargetSnaps(snapPoints, shape, target);\n\n    snapPoints.initialized = true;\n  }\n\n\n  var snapping = {\n    x: isSnapped(event, 'x'),\n    y: isSnapped(event, 'y')\n  };\n\n\n  forEach(snapLocations, function(location) {\n\n    var snapOrigin = snapContext.getSnapOrigin(location);\n\n    var snapCurrent = {\n      x: event.x + snapOrigin.x,\n      y: event.y + snapOrigin.y\n    };\n\n    // snap on both axis, if not snapped already\n    forEach([ 'x', 'y' ], function(axis) {\n      var locationSnapping;\n\n      if (!snapping[axis]) {\n        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);\n\n        if (locationSnapping !== undefined) {\n          snapping[axis] = {\n            value: locationSnapping,\n            originValue: locationSnapping - snapOrigin[axis]\n          };\n        }\n      }\n    });\n\n    // no more need to snap, drop out of interation\n    if (snapping.x && snapping.y) {\n      return false;\n    }\n  });\n\n\n  // show snap visuals\n\n  this.showSnapLine('vertical', snapping.x && snapping.x.value);\n  this.showSnapLine('horizontal', snapping.y && snapping.y.value);\n\n\n  // adjust event { x, y, dx, dy } and mark as snapping\n  forEach([ 'x', 'y' ], function(axis) {\n\n    var axisSnapping = snapping[axis];\n\n    if (typeof axisSnapping === 'object') {\n      // set as snapped and adjust the x and/or y position of the event\n      setSnapped(event, axis, axisSnapping.originValue);\n    }\n  });\n};\n\n\nSnapping.prototype._createLine = function(orientation) {\n\n  var root = this._canvas.getLayer('snap');\n\n  // var line = root.path('M0,0 L0,0').addClass('djs-snap-line');\n\n  var line = svgCreate('path');\n  svgAttr(line, { d: 'M0,0 L0,0' });\n  svgClasses(line).add('djs-snap-line');\n\n  svgAppend(root, line);\n\n  return {\n    update: function(position) {\n\n      if (typeof position !== 'number') {\n        svgAttr(line, { display: 'none' });\n      } else {\n        if (orientation === 'horizontal') {\n          svgAttr(line, {\n            d: 'M-100000,' + position + ' L+100000,' + position,\n            display: ''\n          });\n        } else {\n          svgAttr(line, {\n            d: 'M ' + position + ',-100000 L ' + position + ', +100000',\n            display: ''\n          });\n        }\n      }\n    }\n  };\n};\n\n\nSnapping.prototype._createSnapLines = function() {\n\n  this._snapLines = {\n    horizontal: this._createLine('horizontal'),\n    vertical: this._createLine('vertical')\n  };\n};\n\nSnapping.prototype.showSnapLine = function(orientation, position) {\n\n  var line = this.getSnapLine(orientation);\n\n  if (line) {\n    line.update(position);\n  }\n\n  this._asyncHide();\n};\n\nSnapping.prototype.getSnapLine = function(orientation) {\n  if (!this._snapLines) {\n    this._createSnapLines();\n  }\n\n  return this._snapLines[orientation];\n};\n\nSnapping.prototype.hide = function() {\n  forEach(this._snapLines, function(l) {\n    l.update();\n  });\n};\n\nSnapping.prototype.addTargetSnaps = function(snapPoints, shape, target) {\n\n  var siblings = this.getSiblings(shape, target);\n\n  forEach(siblings, function(s) {\n    snapPoints.add('mid', mid(s));\n  });\n\n};\n\nSnapping.prototype.getSiblings = function(element, target) {\n\n  // snap to all siblings that are not hidden, labels, attached to element or element itself\n  return target && filter(target.children, function(e) {\n    return !e.hidden && !e.labelTarget && e.host !== element && e !== element;\n  });\n};\n"]},"metadata":{},"sourceType":"module"}