{"ast":null,"code":"import inherits from 'inherits';\nimport { getBBox as getBoundingBox } from '../../util/Elements';\nimport { asTRBL, asBounds } from '../../layout/LayoutUtil';\nimport { assign, flatten, forEach, isArray, values, groupBy } from 'min-dash';\nimport CommandInterceptor from '../../command/CommandInterceptor';\n/**\n * An auto resize component that takes care of expanding a parent element\n * if child elements are created or moved close the parents edge.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\n\nexport default function AutoResize(eventBus, elementRegistry, modeling, rules) {\n  CommandInterceptor.call(this, eventBus);\n  this._elementRegistry = elementRegistry;\n  this._modeling = modeling;\n  this._rules = rules;\n  var self = this;\n  this.postExecuted(['shape.create'], function (event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        parent = context.parent || context.newParent;\n\n    if (hints && (hints.root === false || hints.autoResize === false)) {\n      return;\n    }\n\n    self._expand([shape], parent);\n  });\n  this.postExecuted(['elements.move'], function (event) {\n    var context = event.context,\n        elements = flatten(values(context.closure.topLevel)),\n        hints = context.hints;\n    var autoResize = hints ? hints.autoResize : true;\n\n    if (autoResize === false) {\n      return;\n    }\n\n    var expandings = groupBy(elements, function (element) {\n      return element.parent.id;\n    });\n    forEach(expandings, function (elements, parentId) {\n      // optionally filter elements to be considered when resizing\n      if (isArray(autoResize)) {\n        elements = elements.filter(function (element) {\n          return autoResize.indexOf(element) !== -1;\n        });\n      }\n\n      self._expand(elements, parentId);\n    });\n  });\n  this.postExecuted(['shape.toggleCollapse'], function (event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape;\n\n    if (hints && (hints.root === false || hints.autoResize === false)) {\n      return;\n    }\n\n    if (shape.collapsed) {\n      return;\n    }\n\n    self._expand(shape.children || [], shape);\n  });\n  this.postExecuted(['shape.resize'], function (event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        parent = shape.parent;\n\n    if (hints && (hints.root === false || hints.autoResize === false)) {\n      return;\n    }\n\n    if (parent) {\n      self._expand([shape], parent);\n    }\n  });\n}\nAutoResize.$inject = ['eventBus', 'elementRegistry', 'modeling', 'rules'];\ninherits(AutoResize, CommandInterceptor);\n/**\n * Calculate the new bounds of the target shape, given\n * a number of elements have been moved or added into the parent.\n *\n * This method considers the current size, the added elements as well as\n * the provided padding for the new bounds.\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape} target\n */\n\nAutoResize.prototype._getOptimalBounds = function (elements, target) {\n  var offset = this.getOffset(target),\n      padding = this.getPadding(target);\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\n      targetTrbl = asTRBL(target);\n  var newTrbl = {};\n\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\n    newTrbl.top = elementsTrbl.top - offset.top;\n  }\n\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\n    newTrbl.left = elementsTrbl.left - offset.left;\n  }\n\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\n    newTrbl.right = elementsTrbl.right + offset.right;\n  }\n\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\n  }\n\n  return asBounds(assign({}, targetTrbl, newTrbl));\n};\n/**\n * Expand the target shape respecting rules, offset and padding\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape|String} target|targetId\n */\n\n\nAutoResize.prototype._expand = function (elements, target) {\n  if (typeof target === 'string') {\n    target = this._elementRegistry.get(target);\n  }\n\n  var allowed = this._rules.allowed('element.autoResize', {\n    elements: elements,\n    target: target\n  });\n\n  if (!allowed) {\n    return;\n  } // calculate the new bounds\n\n\n  var newBounds = this._getOptimalBounds(elements, target);\n\n  if (!boundsChanged(newBounds, target)) {\n    return;\n  } // resize the parent shape\n\n\n  this.resize(target, newBounds);\n  var parent = target.parent; // recursively expand parent elements\n\n  if (parent) {\n    this._expand([target], parent);\n  }\n};\n/**\n * Get the amount to expand the given shape in each direction.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {Object} {top, bottom, left, right}\n */\n\n\nAutoResize.prototype.getOffset = function (shape) {\n  return {\n    top: 60,\n    bottom: 60,\n    left: 100,\n    right: 100\n  };\n};\n/**\n * Get the activation threshold for each side for which\n * resize triggers.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {Object} {top, bottom, left, right}\n */\n\n\nAutoResize.prototype.getPadding = function (shape) {\n  return {\n    top: 2,\n    bottom: 2,\n    left: 15,\n    right: 15\n  };\n};\n/**\n * Perform the actual resize operation.\n *\n * @param {djs.model.Shape} target\n * @param {Object} newBounds\n */\n\n\nAutoResize.prototype.resize = function (target, newBounds) {\n  this._modeling.resizeShape(target, newBounds);\n};\n\nfunction boundsChanged(newBounds, oldBounds) {\n  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/SPM2021-MTV/frontend/node_modules/diagram-js/lib/features/auto-resize/AutoResize.js"],"names":["inherits","getBBox","getBoundingBox","asTRBL","asBounds","assign","flatten","forEach","isArray","values","groupBy","CommandInterceptor","AutoResize","eventBus","elementRegistry","modeling","rules","call","_elementRegistry","_modeling","_rules","self","postExecuted","event","context","hints","shape","parent","newParent","root","autoResize","_expand","elements","closure","topLevel","expandings","element","id","parentId","filter","indexOf","collapsed","children","$inject","prototype","_getOptimalBounds","target","offset","getOffset","padding","getPadding","elementsTrbl","targetTrbl","newTrbl","top","left","right","bottom","get","allowed","newBounds","boundsChanged","resize","resizeShape","oldBounds","x","y","width","height"],"mappings":"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","sourcesContent":["import inherits from 'inherits';\n\nimport { getBBox as getBoundingBox } from '../../util/Elements';\n\nimport {\n  asTRBL,\n  asBounds\n} from '../../layout/LayoutUtil';\n\nimport {\n  assign,\n  flatten,\n  forEach,\n  isArray,\n  values,\n  groupBy\n} from 'min-dash';\n\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n\n/**\n * An auto resize component that takes care of expanding a parent element\n * if child elements are created or moved close the parents edge.\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n * @param {Modeling} modeling\n * @param {Rules} rules\n */\nexport default function AutoResize(eventBus, elementRegistry, modeling, rules) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this._elementRegistry = elementRegistry;\n  this._modeling = modeling;\n  this._rules = rules;\n\n  var self = this;\n\n  this.postExecuted([ 'shape.create' ], function(event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        parent = context.parent || context.newParent;\n\n    if (hints && (hints.root === false || hints.autoResize === false)) {\n      return;\n    }\n\n    self._expand([ shape ], parent);\n  });\n\n  this.postExecuted([ 'elements.move' ], function(event) {\n    var context = event.context,\n        elements = flatten(values(context.closure.topLevel)),\n        hints = context.hints;\n\n    var autoResize = hints ? hints.autoResize : true;\n\n    if (autoResize === false) {\n      return;\n    }\n\n    var expandings = groupBy(elements, function(element) {\n      return element.parent.id;\n    });\n\n    forEach(expandings, function(elements, parentId) {\n\n      // optionally filter elements to be considered when resizing\n      if (isArray(autoResize)) {\n        elements = elements.filter(function(element) {\n          return autoResize.indexOf(element) !== -1;\n        });\n      }\n\n      self._expand(elements, parentId);\n    });\n  });\n\n  this.postExecuted([ 'shape.toggleCollapse' ], function(event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape;\n\n    if (hints && (hints.root === false || hints.autoResize === false)) {\n      return;\n    }\n\n    if (shape.collapsed) {\n      return;\n    }\n\n    self._expand(shape.children || [], shape);\n  });\n\n  this.postExecuted([ 'shape.resize' ], function(event) {\n    var context = event.context,\n        hints = context.hints,\n        shape = context.shape,\n        parent = shape.parent;\n\n    if (hints && (hints.root === false || hints.autoResize === false)) {\n      return;\n    }\n\n    if (parent) {\n      self._expand([ shape ], parent);\n    }\n  });\n\n}\n\nAutoResize.$inject = [\n  'eventBus',\n  'elementRegistry',\n  'modeling',\n  'rules'\n];\n\ninherits(AutoResize, CommandInterceptor);\n\n\n/**\n * Calculate the new bounds of the target shape, given\n * a number of elements have been moved or added into the parent.\n *\n * This method considers the current size, the added elements as well as\n * the provided padding for the new bounds.\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape} target\n */\nAutoResize.prototype._getOptimalBounds = function(elements, target) {\n\n  var offset = this.getOffset(target),\n      padding = this.getPadding(target);\n\n  var elementsTrbl = asTRBL(getBoundingBox(elements)),\n      targetTrbl = asTRBL(target);\n\n  var newTrbl = {};\n\n  if (elementsTrbl.top - targetTrbl.top < padding.top) {\n    newTrbl.top = elementsTrbl.top - offset.top;\n  }\n\n  if (elementsTrbl.left - targetTrbl.left < padding.left) {\n    newTrbl.left = elementsTrbl.left - offset.left;\n  }\n\n  if (targetTrbl.right - elementsTrbl.right < padding.right) {\n    newTrbl.right = elementsTrbl.right + offset.right;\n  }\n\n  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {\n    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;\n  }\n\n  return asBounds(assign({}, targetTrbl, newTrbl));\n};\n\n\n/**\n * Expand the target shape respecting rules, offset and padding\n *\n * @param {Array<djs.model.Shape>} elements\n * @param {djs.model.Shape|String} target|targetId\n */\nAutoResize.prototype._expand = function(elements, target) {\n\n  if (typeof target === 'string') {\n    target = this._elementRegistry.get(target);\n  }\n\n  var allowed = this._rules.allowed('element.autoResize', {\n    elements: elements,\n    target: target\n  });\n\n  if (!allowed) {\n    return;\n  }\n\n  // calculate the new bounds\n  var newBounds = this._getOptimalBounds(elements, target);\n\n  if (!boundsChanged(newBounds, target)) {\n    return;\n  }\n\n  // resize the parent shape\n  this.resize(target, newBounds);\n\n  var parent = target.parent;\n\n  // recursively expand parent elements\n  if (parent) {\n    this._expand([ target ], parent);\n  }\n};\n\n\n/**\n * Get the amount to expand the given shape in each direction.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {Object} {top, bottom, left, right}\n */\nAutoResize.prototype.getOffset = function(shape) {\n  return { top: 60, bottom: 60, left: 100, right: 100 };\n};\n\n\n/**\n * Get the activation threshold for each side for which\n * resize triggers.\n *\n * @param {djs.model.Shape} shape\n *\n * @return {Object} {top, bottom, left, right}\n */\nAutoResize.prototype.getPadding = function(shape) {\n  return { top: 2, bottom: 2, left: 15, right: 15 };\n};\n\n\n/**\n * Perform the actual resize operation.\n *\n * @param {djs.model.Shape} target\n * @param {Object} newBounds\n */\nAutoResize.prototype.resize = function(target, newBounds) {\n  this._modeling.resizeShape(target, newBounds);\n};\n\n\nfunction boundsChanged(newBounds, oldBounds) {\n  return (\n    newBounds.x !== oldBounds.x ||\n    newBounds.y !== oldBounds.y ||\n    newBounds.width !== oldBounds.width ||\n    newBounds.height !== oldBounds.height\n  );\n}"]},"metadata":{},"sourceType":"module"}