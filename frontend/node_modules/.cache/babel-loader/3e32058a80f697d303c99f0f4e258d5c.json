{"ast":null,"code":"import { find, some, every, forEach } from 'min-dash';\nimport inherits from 'inherits';\nimport { is, getBusinessObject } from '../../util/ModelUtil';\nimport { isAny } from '../modeling/util/ModelingUtil';\nimport { isLabel } from '../../util/LabelUtil';\nimport { isExpanded, isEventSubProcess, isInterrupting, hasErrorEventDefinition, hasEscalationEventDefinition, hasCompensateEventDefinition } from '../../util/DiUtil';\nimport RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';\nimport { getBoundaryAttachment as isBoundaryAttachment } from '../snapping/BpmnSnappingUtil';\n/**\n * BPMN specific modeling rule\n */\n\nexport default function BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\ninherits(BpmnRules, RuleProvider);\nBpmnRules.$inject = ['eventBus'];\n\nBpmnRules.prototype.init = function () {\n  this.addRule('connection.start', function (context) {\n    var source = context.source;\n    return canStartConnection(source);\n  });\n  this.addRule('connection.create', function (context) {\n    var source = context.source,\n        target = context.target,\n        hints = context.hints || {},\n        targetParent = hints.targetParent,\n        targetAttach = hints.targetAttach; // don't allow incoming connections on\n    // newly created boundary events\n    // to boundary events\n\n    if (targetAttach) {\n      return false;\n    } // temporarily set target parent for scoping\n    // checks to work\n\n\n    if (targetParent) {\n      target.parent = targetParent;\n    }\n\n    try {\n      return canConnect(source, target);\n    } finally {\n      // unset temporary target parent\n      if (targetParent) {\n        target.parent = null;\n      }\n    }\n  });\n  this.addRule('connection.reconnectStart', function (context) {\n    var connection = context.connection,\n        source = context.hover || context.source,\n        target = connection.target;\n    return canConnect(source, target, connection);\n  });\n  this.addRule('connection.reconnectEnd', function (context) {\n    var connection = context.connection,\n        source = connection.source,\n        target = context.hover || context.target;\n    return canConnect(source, target, connection);\n  });\n  this.addRule('connection.updateWaypoints', function (context) {\n    // OK! but visually ignore\n    return null;\n  });\n  this.addRule('shape.resize', function (context) {\n    var shape = context.shape,\n        newBounds = context.newBounds;\n    return canResize(shape, newBounds);\n  });\n  this.addRule('elements.move', function (context) {\n    var target = context.target,\n        shapes = context.shapes,\n        position = context.position;\n    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target, position) || canInsert(shapes, target, position);\n  });\n  this.addRule('shape.create', function (context) {\n    return canCreate(context.shape, context.target, context.source, context.position);\n  });\n  this.addRule('shape.attach', function (context) {\n    return canAttach(context.shape, context.target, null, context.position);\n  });\n  this.addRule('element.copy', function (context) {\n    var collection = context.collection,\n        element = context.element;\n    return canCopy(collection, element);\n  });\n  this.addRule('element.paste', function (context) {\n    var parent = context.parent,\n        element = context.element,\n        position = context.position,\n        source = context.source,\n        target = context.target;\n\n    if (source || target) {\n      return canConnect(source, target);\n    }\n\n    return canAttach([element], parent, null, position) || canCreate(element, parent, null, position);\n  });\n  this.addRule('elements.paste', function (context) {\n    var tree = context.tree,\n        target = context.target;\n    return canPaste(tree, target);\n  });\n};\n\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\nBpmnRules.prototype.canMove = canMove;\nBpmnRules.prototype.canAttach = canAttach;\nBpmnRules.prototype.canReplace = canReplace;\nBpmnRules.prototype.canDrop = canDrop;\nBpmnRules.prototype.canInsert = canInsert;\nBpmnRules.prototype.canCreate = canCreate;\nBpmnRules.prototype.canConnect = canConnect;\nBpmnRules.prototype.canResize = canResize;\nBpmnRules.prototype.canCopy = canCopy;\n/**\n * Utility functions for rule checking\n */\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n * @return {Boolean}\n */\n\nfunction canStartConnection(element) {\n  if (nonExistingOrLabel(element)) {\n    return null;\n  }\n\n  return isAny(element, ['bpmn:FlowNode', 'bpmn:InteractionNode', 'bpmn:DataObjectReference', 'bpmn:DataStoreReference']);\n}\n\nfunction nonExistingOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction getOrganizationalParent(element) {\n  do {\n    if (is(element, 'bpmn:Process')) {\n      return getBusinessObject(element);\n    }\n\n    if (is(element, 'bpmn:Participant')) {\n      return getBusinessObject(element).processRef || getBusinessObject(element);\n    }\n  } while (element = element.parent);\n}\n\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\n\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') && hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\nfunction isForCompensation(e) {\n  return getBusinessObject(e).isForCompensation;\n}\n\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n      parentB = getOrganizationalParent(b);\n  return parentA === parentB;\n}\n\nfunction isMessageFlowSource(element) {\n  return is(element, 'bpmn:InteractionNode') && (!is(element, 'bpmn:Event') || is(element, 'bpmn:ThrowEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition'));\n}\n\nfunction isMessageFlowTarget(element) {\n  return is(element, 'bpmn:InteractionNode') && !isForCompensation(element) && (!is(element, 'bpmn:Event') || is(element, 'bpmn:CatchEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition'));\n}\n\nfunction getScopeParent(element) {\n  var parent = element;\n\n  while (parent = parent.parent) {\n    if (is(parent, 'bpmn:FlowElementsContainer')) {\n      return getBusinessObject(parent);\n    }\n\n    if (is(parent, 'bpmn:Participant')) {\n      return getBusinessObject(parent).processRef;\n    }\n  }\n\n  return null;\n}\n\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n      scopeParentB = getScopeParent(b);\n  return scopeParentA && scopeParentA === scopeParentB;\n}\n\nfunction hasEventDefinition(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n  return !!find(bo.eventDefinitions || [], function (definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n  return (bo.eventDefinitions || []).every(function (definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction isSequenceFlowSource(element) {\n  return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:EndEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateThrowEvent') && hasEventDefinition(element, 'bpmn:LinkEventDefinition')) && !isCompensationBoundary(element) && !isForCompensation(element);\n}\n\nfunction isSequenceFlowTarget(element) {\n  return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:StartEvent') && !is(element, 'bpmn:BoundaryEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateCatchEvent') && hasEventDefinition(element, 'bpmn:LinkEventDefinition')) && !isForCompensation(element);\n}\n\nfunction isEventBasedTarget(element) {\n  return is(element, 'bpmn:ReceiveTask') || is(element, 'bpmn:IntermediateCatchEvent') && (hasEventDefinition(element, 'bpmn:MessageEventDefinition') || hasEventDefinition(element, 'bpmn:TimerEventDefinition') || hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') || hasEventDefinition(element, 'bpmn:SignalEventDefinition'));\n}\n\nfunction isConnection(element) {\n  return element.waypoints;\n}\n\nfunction getParents(element) {\n  var parents = [];\n\n  while (element) {\n    element = element.parent;\n\n    if (element) {\n      parents.push(element);\n    }\n  }\n\n  return parents;\n}\n\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}\n\nfunction canConnect(source, target, connection) {\n  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {\n    return null;\n  }\n\n  if (!is(connection, 'bpmn:DataAssociation')) {\n    if (canConnectMessageFlow(source, target)) {\n      return {\n        type: 'bpmn:MessageFlow'\n      };\n    }\n\n    if (canConnectSequenceFlow(source, target)) {\n      return {\n        type: 'bpmn:SequenceFlow'\n      };\n    }\n  }\n\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n\n  if (canConnectAssociation(source, target)) {\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n\n  return false;\n}\n/**\n * Can an element be dropped into the target element\n *\n * @return {Boolean}\n */\n\n\nfunction canDrop(element, target, position) {\n  // can move labels everywhere\n  if (isLabel(element)) {\n    return true;\n  } // disallow to create elements on collapsed pools\n\n\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  } // allow to create new participants on\n  // on existing collaboration and process diagrams\n\n\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  } // allow moving DataInput / DataOutput within its original container only\n\n\n  if (isAny(element, ['bpmn:DataInput', 'bpmn:DataOutput'])) {\n    if (element.parent) {\n      return target === element.parent;\n    }\n  } // allow creating lanes on participants and other lanes only\n\n\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent')) {\n    return false;\n  } // drop flow elements onto flow element containers\n  // and participants\n\n\n  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n\n    return isAny(target, ['bpmn:Participant', 'bpmn:Lane']);\n  } // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n\n\n  if (isAny(element, ['bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference'])) {\n    return isAny(target, ['bpmn:Collaboration', 'bpmn:Lane', 'bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess']);\n  }\n\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration') || element.source.parent == target || element.target.parent == target;\n  }\n\n  return false;\n}\n\nfunction canPaste(tree, target) {\n  var topLevel = tree[0],\n      participants;\n\n  if (is(target, 'bpmn:Collaboration')) {\n    return every(topLevel, function (e) {\n      return e.type === 'bpmn:Participant';\n    });\n  }\n\n  if (is(target, 'bpmn:Process')) {\n    participants = some(topLevel, function (e) {\n      return e.type === 'bpmn:Participant';\n    });\n    return !(participants && target.children.length > 0);\n  } // disallow to create elements on collapsed pools\n\n\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  if (is(target, 'bpmn:FlowElementsContainer')) {\n    return isExpanded(target);\n  }\n\n  return isAny(target, ['bpmn:Collaboration', 'bpmn:Lane', 'bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess']);\n}\n\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\n\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n/**\n * We treat IntermediateThrowEvents as boundary events during create,\n * this must be reflected in the rules.\n */\n\n\nfunction isBoundaryCandidate(element) {\n  return isBoundaryEvent(element) || is(element, 'bpmn:IntermediateThrowEvent') && !element.parent;\n}\n\nfunction isReceiveTaskAfterEventBasedGateway(element) {\n  return is(element, 'bpmn:ReceiveTask') && find(element.incoming, function (incoming) {\n    return is(incoming.source, 'bpmn:EventBasedGateway');\n  });\n}\n\nfunction canAttach(elements, target, source, position) {\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  } // disallow appending as boundary event\n\n\n  if (source) {\n    return false;\n  } // only (re-)attach one element at a time\n\n\n  if (elements.length !== 1) {\n    return false;\n  }\n\n  var element = elements[0]; // do not attach labels\n\n  if (isLabel(element)) {\n    return false;\n  } // only handle boundary events\n\n\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  } // allow default move operation\n\n\n  if (!target) {\n    return true;\n  } // disallow drop on event sub processes\n\n\n  if (isEventSubProcess(target)) {\n    return false;\n  } // only allow drop on non compensation activities\n\n\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  } // only attach to subprocess border\n\n\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  } // do not attach on receive tasks after event based gateways\n\n\n  if (isReceiveTaskAfterEventBasedGateway(target)) {\n    return false;\n  }\n\n  return 'attach';\n}\n/**\n * Defines how to replace elements for a given target.\n *\n * Returns an array containing all elements which will be replaced.\n *\n * @example\n *\n *  [{ id: 'IntermediateEvent_2',\n *     type: 'bpmn:StartEvent'\n *   },\n *   { id: 'IntermediateEvent_5',\n *     type: 'bpmn:EndEvent'\n *   }]\n *\n * @param  {Array} elements\n * @param  {Object} target\n *\n * @return {Object} an object containing all elements which have to be replaced\n */\n\n\nfunction canReplace(elements, target, position) {\n  if (!target) {\n    return false;\n  }\n\n  var canExecute = {\n    replacements: []\n  };\n  forEach(elements, function (element) {\n    if (!isEventSubProcess(target)) {\n      if (is(element, 'bpmn:StartEvent') && element.type !== 'label' && canDrop(element, target)) {\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        } // replace an error/escalation/compansate start event by a blank interrupting start event\n        // when the target is not an event sub process\n\n\n        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') && element.type !== 'label') {\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n  return canExecute.replacements.length ? canExecute : false;\n}\n\nfunction canMove(elements, target) {\n  // do not move selection containing boundary events\n  if (some(elements, isBoundaryEvent)) {\n    return false;\n  } // do not move selection containing lanes\n\n\n  if (some(elements, isLane)) {\n    return false;\n  } // allow default move check to start move operation\n\n\n  if (!target) {\n    return true;\n  }\n\n  return elements.every(function (element) {\n    return canDrop(element, target);\n  });\n}\n\nfunction canCreate(shape, target, source, position) {\n  if (!target) {\n    return false;\n  }\n\n  if (isLabel(target)) {\n    return null;\n  }\n\n  if (isSame(source, target)) {\n    return false;\n  } // ensure we do not drop the element\n  // into source\n\n\n  if (source && isParent(source, target)) {\n    return false;\n  }\n\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\n\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);\n  }\n\n  if (is(shape, 'bpmn:Lane')) {\n    return !newBounds || newBounds.width >= 130 && newBounds.height >= 60;\n  }\n\n  if (is(shape, 'bpmn:Participant')) {\n    return !newBounds || newBounds.width >= 250 && newBounds.height >= 50;\n  }\n\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Check, whether one side of the relationship\n * is a text annotation.\n */\n\n\nfunction isOneTextAnnotation(source, target) {\n  var sourceTextAnnotation = isTextAnnotation(source),\n      targetTextAnnotation = isTextAnnotation(target);\n  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;\n}\n\nfunction canConnectAssociation(source, target) {\n  // do not connect connections\n  if (isConnection(source) || isConnection(target)) {\n    return false;\n  } // compensation boundary events are exception\n\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return true;\n  } // don't connect parent <-> child\n\n\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  } // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n\n\n  return isOneTextAnnotation(source, target);\n}\n\nfunction canConnectMessageFlow(source, target) {\n  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);\n}\n\nfunction canConnectSequenceFlow(source, target) {\n  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\n\nfunction canConnectDataAssociation(source, target) {\n  if (isAny(source, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(target, ['bpmn:Activity', 'bpmn:ThrowEvent'])) {\n    return {\n      type: 'bpmn:DataInputAssociation'\n    };\n  }\n\n  if (isAny(target, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(source, ['bpmn:Activity', 'bpmn:CatchEvent'])) {\n    return {\n      type: 'bpmn:DataOutputAssociation'\n    };\n  }\n\n  return false;\n}\n\nfunction canInsert(shape, flow, position) {\n  if (!flow) {\n    return false;\n  }\n\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n\n    shape = shape[0];\n  }\n\n  if (flow.source === shape || flow.target === shape) {\n    return false;\n  } // return true if we can drop on the\n  // underlying flow parent\n  //\n  // at this point we are not really able to talk\n  // about connection rules (yet)\n\n\n  return isAny(flow, ['bpmn:SequenceFlow', 'bpmn:MessageFlow']) && !isLabel(flow) && is(shape, 'bpmn:FlowNode') && !is(shape, 'bpmn:BoundaryEvent') && canDrop(shape, flow.parent, position);\n}\n\nfunction contains(collection, element) {\n  return collection && element && collection.indexOf(element) !== -1;\n}\n\nfunction canCopy(collection, element) {\n  if (is(element, 'bpmn:Lane') && !contains(collection, element.parent)) {\n    return false;\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent') && !contains(collection, element.host)) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Vittorio/Documents/GitHub/goal-bpmn/frontend/node_modules/bpmn-js/lib/features/rules/BpmnRules.js"],"names":["find","some","every","forEach","inherits","is","getBusinessObject","isAny","isLabel","isExpanded","isEventSubProcess","isInterrupting","hasErrorEventDefinition","hasEscalationEventDefinition","hasCompensateEventDefinition","RuleProvider","getBoundaryAttachment","isBoundaryAttachment","BpmnRules","eventBus","call","$inject","prototype","init","addRule","context","source","canStartConnection","target","hints","targetParent","targetAttach","parent","canConnect","connection","hover","shape","newBounds","canResize","shapes","position","canAttach","canReplace","canMove","canInsert","canCreate","collection","element","canCopy","tree","canPaste","canConnectMessageFlow","canConnectSequenceFlow","canConnectDataAssociation","canConnectAssociation","canDrop","nonExistingOrLabel","isSame","a","b","getOrganizationalParent","processRef","isTextAnnotation","isCompensationBoundary","hasEventDefinition","isForCompensation","e","isSameOrganization","parentA","parentB","isMessageFlowSource","hasEventDefinitionOrNone","isMessageFlowTarget","getScopeParent","isSameScope","scopeParentA","scopeParentB","eventDefinition","bo","eventDefinitions","definition","isSequenceFlowSource","isSequenceFlowTarget","isEventBasedTarget","isConnection","waypoints","getParents","parents","push","isParent","possibleParent","allParents","indexOf","type","connectDataAssociation","associationDirection","topLevel","participants","children","length","isBoundaryEvent","isLane","isBoundaryCandidate","isReceiveTaskAfterEventBasedGateway","incoming","elements","Array","isArray","canExecute","replacements","oldElementId","id","newElementType","width","height","isOneTextAnnotation","sourceTextAnnotation","targetTextAnnotation","flow","contains","host"],"mappings":"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","sourcesContent":["import {\n  find,\n  some,\n  every,\n  forEach\n} from 'min-dash';\n\nimport inherits from 'inherits';\n\nimport {\n  is,\n  getBusinessObject\n} from '../../util/ModelUtil';\n\nimport {\n  isAny\n} from '../modeling/util/ModelingUtil';\n\nimport {\n  isLabel\n} from '../../util/LabelUtil';\n\nimport {\n  isExpanded,\n  isEventSubProcess,\n  isInterrupting,\n  hasErrorEventDefinition,\n  hasEscalationEventDefinition,\n  hasCompensateEventDefinition\n} from '../../util/DiUtil';\n\nimport RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';\n\nimport {\n  getBoundaryAttachment as isBoundaryAttachment\n} from '../snapping/BpmnSnappingUtil';\n\n\n/**\n * BPMN specific modeling rule\n */\nexport default function BpmnRules(eventBus) {\n  RuleProvider.call(this, eventBus);\n}\n\ninherits(BpmnRules, RuleProvider);\n\nBpmnRules.$inject = [ 'eventBus' ];\n\nBpmnRules.prototype.init = function() {\n\n  this.addRule('connection.start', function(context) {\n    var source = context.source;\n\n    return canStartConnection(source);\n  });\n\n  this.addRule('connection.create', function(context) {\n    var source = context.source,\n        target = context.target,\n        hints = context.hints || {},\n        targetParent = hints.targetParent,\n        targetAttach = hints.targetAttach;\n\n    // don't allow incoming connections on\n    // newly created boundary events\n    // to boundary events\n    if (targetAttach) {\n      return false;\n    }\n\n    // temporarily set target parent for scoping\n    // checks to work\n    if (targetParent) {\n      target.parent = targetParent;\n    }\n\n    try {\n      return canConnect(source, target);\n    } finally {\n      // unset temporary target parent\n      if (targetParent) {\n        target.parent = null;\n      }\n    }\n  });\n\n  this.addRule('connection.reconnectStart', function(context) {\n\n    var connection = context.connection,\n        source = context.hover || context.source,\n        target = connection.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.reconnectEnd', function(context) {\n\n    var connection = context.connection,\n        source = connection.source,\n        target = context.hover || context.target;\n\n    return canConnect(source, target, connection);\n  });\n\n  this.addRule('connection.updateWaypoints', function(context) {\n    // OK! but visually ignore\n    return null;\n  });\n\n  this.addRule('shape.resize', function(context) {\n\n    var shape = context.shape,\n        newBounds = context.newBounds;\n\n    return canResize(shape, newBounds);\n  });\n\n  this.addRule('elements.move', function(context) {\n\n    var target = context.target,\n        shapes = context.shapes,\n        position = context.position;\n\n    return canAttach(shapes, target, null, position) ||\n           canReplace(shapes, target, position) ||\n           canMove(shapes, target, position) ||\n           canInsert(shapes, target, position);\n  });\n\n  this.addRule('shape.create', function(context) {\n    return canCreate(\n      context.shape,\n      context.target,\n      context.source,\n      context.position\n    );\n  });\n\n  this.addRule('shape.attach', function(context) {\n\n    return canAttach(\n      context.shape,\n      context.target,\n      null,\n      context.position\n    );\n  });\n\n  this.addRule('element.copy', function(context) {\n    var collection = context.collection,\n        element = context.element;\n\n    return canCopy(collection, element);\n  });\n\n  this.addRule('element.paste', function(context) {\n    var parent = context.parent,\n        element = context.element,\n        position = context.position,\n        source = context.source,\n        target = context.target;\n\n    if (source || target) {\n      return canConnect(source, target);\n    }\n\n    return canAttach([ element ], parent, null, position) || canCreate(element, parent, null, position);\n  });\n\n  this.addRule('elements.paste', function(context) {\n    var tree = context.tree,\n        target = context.target;\n\n    return canPaste(tree, target);\n  });\n};\n\nBpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;\n\nBpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;\n\nBpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;\n\nBpmnRules.prototype.canConnectAssociation = canConnectAssociation;\n\nBpmnRules.prototype.canMove = canMove;\n\nBpmnRules.prototype.canAttach = canAttach;\n\nBpmnRules.prototype.canReplace = canReplace;\n\nBpmnRules.prototype.canDrop = canDrop;\n\nBpmnRules.prototype.canInsert = canInsert;\n\nBpmnRules.prototype.canCreate = canCreate;\n\nBpmnRules.prototype.canConnect = canConnect;\n\nBpmnRules.prototype.canResize = canResize;\n\nBpmnRules.prototype.canCopy = canCopy;\n\n/**\n * Utility functions for rule checking\n */\n\n/**\n * Checks if given element can be used for starting connection.\n *\n * @param  {Element} source\n * @return {Boolean}\n */\nfunction canStartConnection(element) {\n  if (nonExistingOrLabel(element)) {\n    return null;\n  }\n\n  return isAny(element, [\n    'bpmn:FlowNode',\n    'bpmn:InteractionNode',\n    'bpmn:DataObjectReference',\n    'bpmn:DataStoreReference'\n  ]);\n}\n\nfunction nonExistingOrLabel(element) {\n  return !element || isLabel(element);\n}\n\nfunction isSame(a, b) {\n  return a === b;\n}\n\nfunction getOrganizationalParent(element) {\n\n  do {\n    if (is(element, 'bpmn:Process')) {\n      return getBusinessObject(element);\n    }\n\n    if (is(element, 'bpmn:Participant')) {\n      return (\n        getBusinessObject(element).processRef ||\n        getBusinessObject(element)\n      );\n    }\n  } while ((element = element.parent));\n\n}\n\nfunction isTextAnnotation(element) {\n  return is(element, 'bpmn:TextAnnotation');\n}\n\nfunction isCompensationBoundary(element) {\n  return is(element, 'bpmn:BoundaryEvent') &&\n         hasEventDefinition(element, 'bpmn:CompensateEventDefinition');\n}\n\nfunction isForCompensation(e) {\n  return getBusinessObject(e).isForCompensation;\n}\n\nfunction isSameOrganization(a, b) {\n  var parentA = getOrganizationalParent(a),\n      parentB = getOrganizationalParent(b);\n\n  return parentA === parentB;\n}\n\nfunction isMessageFlowSource(element) {\n  return (\n    is(element, 'bpmn:InteractionNode') && (\n      !is(element, 'bpmn:Event') || (\n        is(element, 'bpmn:ThrowEvent') &&\n        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n      )\n    )\n  );\n}\n\nfunction isMessageFlowTarget(element) {\n  return (\n    is(element, 'bpmn:InteractionNode') &&\n    !isForCompensation(element) && (\n      !is(element, 'bpmn:Event') || (\n        is(element, 'bpmn:CatchEvent') &&\n        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')\n      )\n    )\n  );\n}\n\nfunction getScopeParent(element) {\n\n  var parent = element;\n\n  while ((parent = parent.parent)) {\n\n    if (is(parent, 'bpmn:FlowElementsContainer')) {\n      return getBusinessObject(parent);\n    }\n\n    if (is(parent, 'bpmn:Participant')) {\n      return getBusinessObject(parent).processRef;\n    }\n  }\n\n  return null;\n}\n\nfunction isSameScope(a, b) {\n  var scopeParentA = getScopeParent(a),\n      scopeParentB = getScopeParent(b);\n\n  return scopeParentA && (scopeParentA === scopeParentB);\n}\n\nfunction hasEventDefinition(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return !!find(bo.eventDefinitions || [], function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction hasEventDefinitionOrNone(element, eventDefinition) {\n  var bo = getBusinessObject(element);\n\n  return (bo.eventDefinitions || []).every(function(definition) {\n    return is(definition, eventDefinition);\n  });\n}\n\nfunction isSequenceFlowSource(element) {\n  return (\n    is(element, 'bpmn:FlowNode') &&\n    !is(element, 'bpmn:EndEvent') &&\n    !isEventSubProcess(element) &&\n    !(is(element, 'bpmn:IntermediateThrowEvent') &&\n      hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n    ) &&\n    !isCompensationBoundary(element) &&\n    !isForCompensation(element)\n  );\n}\n\nfunction isSequenceFlowTarget(element) {\n  return (\n    is(element, 'bpmn:FlowNode') &&\n    !is(element, 'bpmn:StartEvent') &&\n    !is(element, 'bpmn:BoundaryEvent') &&\n    !isEventSubProcess(element) &&\n    !(is(element, 'bpmn:IntermediateCatchEvent') &&\n      hasEventDefinition(element, 'bpmn:LinkEventDefinition')\n    ) &&\n    !isForCompensation(element)\n  );\n}\n\nfunction isEventBasedTarget(element) {\n  return (\n    is(element, 'bpmn:ReceiveTask') || (\n      is(element, 'bpmn:IntermediateCatchEvent') && (\n        hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||\n        hasEventDefinition(element, 'bpmn:SignalEventDefinition')\n      )\n    )\n  );\n}\n\nfunction isConnection(element) {\n  return element.waypoints;\n}\n\nfunction getParents(element) {\n\n  var parents = [];\n\n  while (element) {\n    element = element.parent;\n\n    if (element) {\n      parents.push(element);\n    }\n  }\n\n  return parents;\n}\n\nfunction isParent(possibleParent, element) {\n  var allParents = getParents(element);\n  return allParents.indexOf(possibleParent) !== -1;\n}\n\nfunction canConnect(source, target, connection) {\n\n  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {\n    return null;\n  }\n\n  if (!is(connection, 'bpmn:DataAssociation')) {\n\n    if (canConnectMessageFlow(source, target)) {\n      return { type: 'bpmn:MessageFlow' };\n    }\n\n    if (canConnectSequenceFlow(source, target)) {\n      return { type: 'bpmn:SequenceFlow' };\n    }\n  }\n\n  var connectDataAssociation = canConnectDataAssociation(source, target);\n\n  if (connectDataAssociation) {\n    return connectDataAssociation;\n  }\n\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return {\n      type: 'bpmn:Association',\n      associationDirection: 'One'\n    };\n  }\n\n  if (canConnectAssociation(source, target)) {\n\n    return {\n      type: 'bpmn:Association'\n    };\n  }\n\n  return false;\n}\n\n/**\n * Can an element be dropped into the target element\n *\n * @return {Boolean}\n */\nfunction canDrop(element, target, position) {\n\n  // can move labels everywhere\n  if (isLabel(element)) {\n    return true;\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  // allow to create new participants on\n  // on existing collaboration and process diagrams\n  if (is(element, 'bpmn:Participant')) {\n    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');\n  }\n\n  // allow moving DataInput / DataOutput within its original container only\n  if (isAny(element, [ 'bpmn:DataInput', 'bpmn:DataOutput' ])) {\n\n    if (element.parent) {\n      return target === element.parent;\n    }\n  }\n\n  // allow creating lanes on participants and other lanes only\n  if (is(element, 'bpmn:Lane')) {\n    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent')) {\n    return false;\n  }\n\n  // drop flow elements onto flow element containers\n  // and participants\n  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {\n    if (is(target, 'bpmn:FlowElementsContainer')) {\n      return isExpanded(target);\n    }\n\n    return isAny(target, [ 'bpmn:Participant', 'bpmn:Lane' ]);\n  }\n\n  // account for the fact that data associations are always\n  // rendered and moved to top (Process or Collaboration level)\n  //\n  // artifacts may be placed wherever, too\n  if (isAny(element, [ 'bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference' ])) {\n    return isAny(target, [\n      'bpmn:Collaboration',\n      'bpmn:Lane',\n      'bpmn:Participant',\n      'bpmn:Process',\n      'bpmn:SubProcess' ]);\n  }\n\n  if (is(element, 'bpmn:MessageFlow')) {\n    return is(target, 'bpmn:Collaboration')\n      || element.source.parent == target\n      || element.target.parent == target;\n  }\n\n  return false;\n}\n\nfunction canPaste(tree, target) {\n  var topLevel = tree[0],\n      participants;\n\n  if (is(target, 'bpmn:Collaboration')) {\n    return every(topLevel, function(e) {\n      return e.type === 'bpmn:Participant';\n    });\n  }\n\n  if (is(target, 'bpmn:Process')) {\n    participants = some(topLevel, function(e) {\n      return e.type === 'bpmn:Participant';\n    });\n\n    return !(participants && target.children.length > 0);\n  }\n\n  // disallow to create elements on collapsed pools\n  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {\n    return false;\n  }\n\n  if (is(target, 'bpmn:FlowElementsContainer')) {\n    return isExpanded(target);\n  }\n\n  return isAny(target, [\n    'bpmn:Collaboration',\n    'bpmn:Lane',\n    'bpmn:Participant',\n    'bpmn:Process',\n    'bpmn:SubProcess' ]);\n}\n\nfunction isBoundaryEvent(element) {\n  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');\n}\n\nfunction isLane(element) {\n  return is(element, 'bpmn:Lane');\n}\n\n/**\n * We treat IntermediateThrowEvents as boundary events during create,\n * this must be reflected in the rules.\n */\nfunction isBoundaryCandidate(element) {\n  return isBoundaryEvent(element) ||\n        (is(element, 'bpmn:IntermediateThrowEvent') && !element.parent);\n}\n\nfunction isReceiveTaskAfterEventBasedGateway(element) {\n  return (\n    is(element, 'bpmn:ReceiveTask') &&\n    find(element.incoming, function(incoming) {\n      return is(incoming.source, 'bpmn:EventBasedGateway');\n    })\n  );\n}\n\n\nfunction canAttach(elements, target, source, position) {\n\n  if (!Array.isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  // disallow appending as boundary event\n  if (source) {\n    return false;\n  }\n\n  // only (re-)attach one element at a time\n  if (elements.length !== 1) {\n    return false;\n  }\n\n  var element = elements[0];\n\n  // do not attach labels\n  if (isLabel(element)) {\n    return false;\n  }\n\n  // only handle boundary events\n  if (!isBoundaryCandidate(element)) {\n    return false;\n  }\n\n  // allow default move operation\n  if (!target) {\n    return true;\n  }\n\n  // disallow drop on event sub processes\n  if (isEventSubProcess(target)) {\n    return false;\n  }\n\n  // only allow drop on non compensation activities\n  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {\n    return false;\n  }\n\n  // only attach to subprocess border\n  if (position && !isBoundaryAttachment(position, target)) {\n    return false;\n  }\n\n  // do not attach on receive tasks after event based gateways\n  if (isReceiveTaskAfterEventBasedGateway(target)) {\n    return false;\n  }\n\n  return 'attach';\n}\n\n\n/**\n * Defines how to replace elements for a given target.\n *\n * Returns an array containing all elements which will be replaced.\n *\n * @example\n *\n *  [{ id: 'IntermediateEvent_2',\n *     type: 'bpmn:StartEvent'\n *   },\n *   { id: 'IntermediateEvent_5',\n *     type: 'bpmn:EndEvent'\n *   }]\n *\n * @param  {Array} elements\n * @param  {Object} target\n *\n * @return {Object} an object containing all elements which have to be replaced\n */\nfunction canReplace(elements, target, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  var canExecute = {\n    replacements: []\n  };\n\n  forEach(elements, function(element) {\n\n    if (!isEventSubProcess(target)) {\n\n      if (is(element, 'bpmn:StartEvent') &&\n          element.type !== 'label' &&\n          canDrop(element, target)) {\n\n        // replace a non-interrupting start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (!isInterrupting(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n\n        // replace an error/escalation/compansate start event by a blank interrupting start event\n        // when the target is not an event sub process\n        if (hasErrorEventDefinition(element) ||\n            hasEscalationEventDefinition(element) ||\n            hasCompensateEventDefinition(element)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:StartEvent'\n          });\n        }\n      }\n    }\n\n    if (!is(target, 'bpmn:Transaction')) {\n      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') &&\n          element.type !== 'label') {\n\n        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:EndEvent'\n          });\n        }\n\n        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {\n          canExecute.replacements.push({\n            oldElementId: element.id,\n            newElementType: 'bpmn:BoundaryEvent'\n          });\n        }\n      }\n    }\n  });\n\n  return canExecute.replacements.length ? canExecute : false;\n}\n\nfunction canMove(elements, target) {\n\n  // do not move selection containing boundary events\n  if (some(elements, isBoundaryEvent)) {\n    return false;\n  }\n\n  // do not move selection containing lanes\n  if (some(elements, isLane)) {\n    return false;\n  }\n\n  // allow default move check to start move operation\n  if (!target) {\n    return true;\n  }\n\n  return elements.every(function(element) {\n    return canDrop(element, target);\n  });\n}\n\nfunction canCreate(shape, target, source, position) {\n\n  if (!target) {\n    return false;\n  }\n\n  if (isLabel(target)) {\n    return null;\n  }\n\n  if (isSame(source, target)) {\n    return false;\n  }\n\n  // ensure we do not drop the element\n  // into source\n  if (source && isParent(source, target)) {\n    return false;\n  }\n\n  return canDrop(shape, target, position) || canInsert(shape, target, position);\n}\n\nfunction canResize(shape, newBounds) {\n  if (is(shape, 'bpmn:SubProcess')) {\n    return (\n      isExpanded(shape) && (\n        !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)\n      )\n    );\n  }\n\n  if (is(shape, 'bpmn:Lane')) {\n    return !newBounds || (newBounds.width >= 130 && newBounds.height >= 60);\n  }\n\n  if (is(shape, 'bpmn:Participant')) {\n    return !newBounds || (newBounds.width >= 250 && newBounds.height >= 50);\n  }\n\n  if (isTextAnnotation(shape)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Check, whether one side of the relationship\n * is a text annotation.\n */\nfunction isOneTextAnnotation(source, target) {\n\n  var sourceTextAnnotation = isTextAnnotation(source),\n      targetTextAnnotation = isTextAnnotation(target);\n\n  return (\n    (sourceTextAnnotation || targetTextAnnotation) &&\n    (sourceTextAnnotation !== targetTextAnnotation)\n  );\n}\n\n\nfunction canConnectAssociation(source, target) {\n\n  // do not connect connections\n  if (isConnection(source) || isConnection(target)) {\n    return false;\n  }\n\n  // compensation boundary events are exception\n  if (isCompensationBoundary(source) && isForCompensation(target)) {\n    return true;\n  }\n\n  // don't connect parent <-> child\n  if (isParent(target, source) || isParent(source, target)) {\n    return false;\n  }\n\n  // allow connection of associations between <!TextAnnotation> and <TextAnnotation>\n  return isOneTextAnnotation(source, target);\n}\n\nfunction canConnectMessageFlow(source, target) {\n\n  return isMessageFlowSource(source) &&\n         isMessageFlowTarget(target) &&\n        !isSameOrganization(source, target);\n}\n\nfunction canConnectSequenceFlow(source, target) {\n\n  return isSequenceFlowSource(source) &&\n         isSequenceFlowTarget(target) &&\n         isSameScope(source, target) &&\n         !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));\n}\n\n\nfunction canConnectDataAssociation(source, target) {\n\n  if (isAny(source, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(target, [ 'bpmn:Activity', 'bpmn:ThrowEvent' ])) {\n    return { type: 'bpmn:DataInputAssociation' };\n  }\n\n  if (isAny(target, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&\n      isAny(source, [ 'bpmn:Activity', 'bpmn:CatchEvent' ])) {\n    return { type: 'bpmn:DataOutputAssociation' };\n  }\n\n  return false;\n}\n\nfunction canInsert(shape, flow, position) {\n\n  if (!flow) {\n    return false;\n  }\n\n  if (Array.isArray(shape)) {\n    if (shape.length !== 1) {\n      return false;\n    }\n\n    shape = shape[0];\n  }\n\n  if (flow.source === shape ||\n      flow.target === shape) {\n    return false;\n  }\n\n  // return true if we can drop on the\n  // underlying flow parent\n  //\n  // at this point we are not really able to talk\n  // about connection rules (yet)\n\n  return (\n    isAny(flow, [ 'bpmn:SequenceFlow', 'bpmn:MessageFlow' ]) &&\n    !isLabel(flow) &&\n    is(shape, 'bpmn:FlowNode') &&\n    !is(shape, 'bpmn:BoundaryEvent') &&\n    canDrop(shape, flow.parent, position));\n}\n\nfunction contains(collection, element) {\n  return (collection && element) && collection.indexOf(element) !== -1;\n}\n\nfunction canCopy(collection, element) {\n  if (is(element, 'bpmn:Lane') && !contains(collection, element.parent)) {\n    return false;\n  }\n\n  if (is(element, 'bpmn:BoundaryEvent') && !contains(collection, element.host)) {\n    return false;\n  }\n\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}